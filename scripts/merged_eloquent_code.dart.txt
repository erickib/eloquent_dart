// File: C:\MyDartProjects\eloquent\lib\eloquent.dart
library eloquent;

export 'src/query/expression.dart';
export 'src/query/query_builder.dart';

export 'src/query/join_clause.dart';

export 'src/grammar.dart'; //BaseGrammar
export 'src/query/grammars/query_grammar.dart';
export 'src/query/processors/processor.dart';
export 'src/query/grammars/query_postgres_grammar.dart';

export 'src/schema/grammars/schema_grammar.dart';
export 'src/schema/grammars/schema_postgres_grammar.dart';
export 'src/schema/blueprint.dart';

export 'src/connection_interface.dart';
export 'src/connection_resolver_interface.dart';
export 'src/connection.dart';
export 'src/postgres_connection.dart';
export 'src/database_manager.dart';
export 'src/detects_lost_connections.dart';

export 'src/connectors/connector_interface.dart';
export 'src/connectors/connector.dart';
export 'src/connectors/postgres_connector.dart';
export 'src/connectors/connection_factory.dart';

export 'src/capsule/manager.dart';

export 'src/utils/utils.dart';

export 'src/support/fluent.dart';

export 'src/exceptions/invalid_argument_exception.dart';
export 'src/exceptions/logic_exception.dart';
export 'src/exceptions/query_exception.dart';

//PDO

export 'src/pdo/core/pdo_execution_context.dart';
export 'src/pdo/core/pdo_result.dart';
export 'src/pdo/core/pdo_interface.dart';
export 'src/pdo/core/pdo_config.dart';

export '/src/pdo/core/constants.dart';

// File: C:\MyDartProjects\eloquent\lib\src\capsule\manager.dart
import 'package:eloquent/eloquent.dart';
import 'package:eloquent/src/container/container.dart';
import 'package:eloquent/src/schema/schema_builder.dart';

//with CapsuleManagerTrait
class Manager {
  ///
  /// The current globally used instance.
  ///
  /// @var object
  ///
  static Manager? instance;

  ///
  /// The container instance.
  ///
  /// @var \Illuminate\Contracts\Container\Container
  ///
  late Container container;

  ///
  /// Setup the IoC container instance.
  ///
  /// @param  \Illuminate\Contracts\Container\Container  $container
  /// @return void
  ///
  void setupContainer(Container containerP) {
    this.container = containerP;

    if (!this.container.bound('config')) {
      this.container.instance('config', Fluent());
    }
  }

  ///
  /// Make this capsule instance available globally.
  ///
  /// @return void
  ///
  void setAsGlobal() {
    instance = this;
  }

  ///
  /// Get the IoC container instance.
  ///
  /// @return \Illuminate\Contracts\Container\Container
  ///
  Container? getContainer() {
    return this.container;
  }

  ///
  /// Set the IoC container instance.
  ///
  /// @param  \Illuminate\Contracts\Container\Container  $container
  /// @return void
  ///
  void setContainer(Container containerP) {
    this.container = containerP;
  }

  ///
  ///  The database manager instance.
  ///
  ///  @var \Illuminate\Database\DatabaseManager
  ///
  late DatabaseManager manager;

  ///
  ///  Create a new database capsule manager.
  ///
  ///  @param  \Illuminate\Container\Container|null  $container
  ///  @return void
  ///
  Manager([Container? container]) {
    this.setupContainer(container ?? Container());

    // Once we have the container setup, we will setup the default configuration
    // options in the container "config" binding. This will make the database
    // manager behave correctly since all the correct binding are in place.
    this.setupDefaultConfiguration();
    this.setupManager();
  }

  ///
  ///  Setup the default database configuration options.
  ///
  ///  @return void
  ///
  void setupDefaultConfiguration() {
    //this.container['config']['database.fetch'] = PDO_FETCH_ASSOC;
    this.container['config']['database.default'] = 'default';
  }

  ///
  ///  Build the database manager instance.
  ///
  ///  @return void
  ///
  void setupManager() {
    var factory = ConnectionFactory(this.container);
    this.manager = DatabaseManager(this.container, factory);
  }

  ///
  ///  Get a connection instance from the global manager.
  ///
  ///  @param  string  $connection
  ///  @return \Illuminate\Database\Connection
  ///
  Future<Connection> connection([String? connection]) async {
    return await instance!.getConnection(connection);
  }

  ///
  ///  Get a fluent query builder instance.
  ///
  ///  @param  string  $table
  ///  @param  string  $connection
  ///  @return \Illuminate\Database\Query\Builder
  ///
  Future<QueryBuilder> table(String table, [String? connectionP]) async {
    final com = await instance!.connection(connectionP);
    return com.table(table);
  }

  ///
  ///  Get a schema builder instance.
  ///
  ///  @param  string  $connection
  ///  @return \Illuminate\Database\Schema\Builder
  ///
  Future<SchemaBuilder> schema([String? connectionP]) async {
    final com = await instance!.connection(connectionP);
    return com.getSchemaBuilder();
  }

  ///
  ///  Get a registered connection instance.
  ///
  ///  @param  string  $name
  ///  @return \Illuminate\Database\Connection
  ///
  Future<Connection> getConnection([String? name]) async {
    return await this.manager.connection(name);
  }

  ///
  ///  Register a connection with the manager.
  ///
  ///  @param  array   $config
  ///  @param  string  $name
  ///  @return void
  /// 
  /// ```dart
  /// 
  /// ```
  /// 
  void addConnection(Map<String, dynamic> config, [String name = 'default']) {
    var connections = this.container['config']['database.connections'];
    if (connections == null) {
      connections = {name: config};
    } else {
      connections[name] = config;
    }
    this.container['config']['database.connections'] = connections;
  }

  ///
  ///  Bootstrap Eloquent so it is ready for usage.
  ///
  ///  @return void
  ///
  void bootEloquent() {
    //Eloquent::setConnectionResolver(this.manager);

    // If we have an event dispatcher instance, we will go ahead and register it
    // with the Eloquent ORM, allowing for model callbacks while creating and
    // updating "model" instances; however, if it not necessary to operate.
    // if ($dispatcher = this.getEventDispatcher()) {
    //     Eloquent::setEventDispatcher($dispatcher);
    // }
  }

  ///
  ///  Set the fetch mode for the database connections.
  ///
  ///  @param  int  $fetchMode
  ///  @return $this
  ///
  Manager setFetchMode(int fetchMode) {
    this.container['config']['database.fetch'] = fetchMode;
    return this;
  }

  ///
  ///  Get the database manager instance.
  ///
  ///  @return \Illuminate\Database\DatabaseManager
  ///
  DatabaseManager getDatabaseManager() {
    return this.manager;
  }

  ///
  ///  Get the current event dispatcher instance.
  ///
  ///  @return \Illuminate\Contracts\Events\Dispatcher|null
  ///
  dynamic getEventDispatcher() {
    if (this.container.bound('events')) {
      return this.container['events'];
    }
  }

  ///
  ///  Set the event dispatcher instance to be used by connections.
  ///
  ///  @param  \Illuminate\Contracts\Events\Dispatcher  $dispatcher
  ///  @return void
  ///
  void setEventDispatcher($dispatcher) {
    this.container.instance('events', $dispatcher);
  }

  ///
  ///  Dynamically pass methods to the default connection.
  ///
  ///  @param  string  $method
  ///  @param  array   $parameters
  ///  @return mixed
  ///
  // public static function __callStatic($method, $parameters)
  // {
  //     return call_user_func_array([static::connection(), $method], $parameters);
  // }
}

// File: C:\MyDartProjects\eloquent\lib\src\connection.dart
import 'package:eloquent/eloquent.dart';
import 'package:eloquent/src/schema/schema_builder.dart';

/// posgresql Connection implementation
class Connection with DetectsLostConnections implements ConnectionInterface {
  /// default query Timeout =  300 seconds
  static const defaultTimeout = const Duration(seconds: 300);

  ///
  /// The active PDO connection.
  ///
  /// @var PDO
  ///
  PDOExecutionContext pdo;

  ///
  /// The active PDO connection used for reads.
  ///
  /// @var PDO
  ///
  PDOExecutionContext? readPdo;

  ///
  /// The reconnector instance for the connection.
  ///
  /// @var callable
  ///
  Future<dynamic> Function(Connection)? reconnector;

  ///
  /// The query grammar implementation.
  ///
  /// @var \Illuminate\Database\Query\Grammars\Grammar
  ///
  late QueryGrammar queryGrammar;

  ///
  /// The schema grammar implementation.
  ///
  /// @var \Illuminate\Database\Schema\Grammars\Grammar
  ///
  SchemaGrammar? schemaGrammar;

  ///
  /// The query post processor implementation.
  ///
  /// @var \Illuminate\Database\Query\Processors\Processor
  ///
  Processor? postProcessor;

  ///
  /// The event dispatcher instance.
  ///
  /// @var \Illuminate\Contracts\Events\Dispatcher
  ///
  //protected events;

  ///
  /// The number of active transactions.
  ///
  /// @var int
  ///
  int transactions = 0;

  ///
  /// All of the queries run against the connection.
  ///
  /// @var array
  ///
  List queryLog = [];

  ///
  /// Indicates whether queries are being logged.
  ///
  /// @var bool
  ///
  bool loggingQueries = false;

  ///
  /// Indicates if the connection is in a "dry run".
  ///
  /// @var bool
  ///
  bool pretendingProp = false;

  ///
  /// The name of the connected database.
  ///
  /// @var string
  ///
  late String _databaseName;

  ///
  /// The instance of Doctrine connection.
  ///
  /// @var \Doctrine\DBAL\Connection
  ///
  // protected doctrineConnection;

  ///
  /// The table prefix for the connection.
  ///
  /// @var string
  ///
  String _tablePrefix = '';

  ///
  /// The database connection configuration options.
  ///
  /// @var array
  ///
  Map<String, dynamic> _config = {};

  int tryReconnectLimit = 10;
  int tryReconnectCount = 0;

  ///
  /// Create a new database connection instance.
  ///
  /// @param  \PDO     pdo
  /// @param  String   database
  /// @param  String   tablePrefix
  /// @param  array    config
  /// @return void
  ///
  Connection(this.pdo,
      [this._databaseName = '',
      this._tablePrefix = '',
      this._config = const <String, dynamic>{}]) {
    //this.pdo = pdoP;
    // print('call Connection construct');
    // First we will setup the default properties. We keep track of the DB
    // name we are connected to since it is needed when some reflective
    // type commands are run such as checking whether a table exists.

    // We need to initialize a query grammar and the query post processors
    // which are both very important parts of the database abstractions
    // so we initialize these to their default values while starting.
    useDefaultQueryGrammar();
    useDefaultPostProcessor();
  }

  ///
  /// Set the query grammar to the default implementation.
  ///
  /// @return void
  ///
  void useDefaultQueryGrammar() {
    this.queryGrammar = getDefaultQueryGrammar();
  }

  ///
  /// Get the default query grammar instance.
  ///
  /// @return \Illuminate\Database\Query\Grammars\Grammar
  ///
  QueryGrammar getDefaultQueryGrammar() {
    return QueryGrammar();
  }

  ///
  /// Set the schema grammar to the default implementation.
  ///
  /// @return void
  ///
  void useDefaultSchemaGrammar() {
    this.schemaGrammar = getDefaultSchemaGrammar();
  }

  ///
  /// Get the default schema grammar instance.
  ///
  /// @return \Illuminate\Database\Schema\Grammars\Grammar
  ///
  dynamic getDefaultSchemaGrammar() {}

  ///
  /// Set the query post processor to the default implementation.
  ///
  /// @return void
  ///
  void useDefaultPostProcessor() {
    this.postProcessor = getDefaultPostProcessor();
  }

  ///
  /// Get the default post processor instance.
  ///
  /// @return \Illuminate\Database\Query\Processors\Processor
  ///
  Processor getDefaultPostProcessor() {
    return Processor();
  }

  ///
  /// Get a schema builder instance for the connection.
  ///
  /// @return \Illuminate\Database\Schema\Builder
  ///
  SchemaBuilder getSchemaBuilder() {
    if (Utils.is_null(schemaGrammar)) {
      useDefaultSchemaGrammar();
    }
    return SchemaBuilder(this);
  }

  ///
  /// Begin a fluent query against a database table.
  ///
  /// @param  String  $table
  /// @return \Illuminate\Database\Query\Builder
  ///
  QueryBuilder table(String table) {
    return this.query().from(table);
  }

  ///
  /// Get a new query builder instance.
  ///
  /// @return \Illuminate\Database\Query\Builder
  ///
  QueryBuilder query() {
    return QueryBuilder(this, this.getQueryGrammar(), this.getPostProcessor());
  }

  ///
  /// Get a new raw query expression.
  ///
  /// @param  mixed  $value
  /// @return \Illuminate\Database\Query\Expression
  ///
  QueryExpression raw(dynamic value) {
    return QueryExpression(value);
  }

  ///
  /// Run a select statement and return a single result.
  ///
  /// @param  String  $query
  /// @param  array   $bindings
  /// @return mixed
  ///
  Future<Map<String, dynamic>?> selectOne(String query,
      [bindings = const [], int? timeoutInSeconds]) async {
    final records = await this.select(
      query,
      bindings,
    );
    return records.isNotEmpty ? records.first : null;
  }

  ///
  /// Run a select statement against the database.
  ///
  /// @param  String  $query
  /// @param  array   $bindings
  /// @return array
  ///
  Future<List<Map<String, dynamic>>> selectFromWriteConnection(query,
      [bindings = const []]) {
    return this.select(query, bindings, false);
  }

  ///
  /// Run a select statement against the database.
  ///
  /// @param  String  $query
  /// @param  array  $bindings
  /// @param  bool  $useReadPdo
  /// @return array
  ///
  Future<List<Map<String, dynamic>>> select(String query,
      [List bindings = const [],
      bool useReadPdo = true,
      int? timeoutInSeconds]) async {
    //print('Connection@select timeout $timeoutInSeconds');

    final res = await this.run(query, bindings,
        (me, query, bindings, timeoutInSeconds) async {
      if (me.pretending()) {
        return [];
      }
      // For select statements, we'll simply execute the query and return an array
      // of the database result set. Each element in the array will be a single
      // row from the database table, and will either be an array or objects.
      final pdoL = me.getPdoForSelect(useReadPdo);
      final params = me.prepareBindings(bindings);
      return pdoL.query(query, params, timeoutInSeconds);
    }, timeoutInSeconds);

    return res as List<Map<String, dynamic>>;
  }

  ///
  /// Get the PDO connection to use for a select query.
  ///
  /// @param  bool  $useReadPdo
  /// @return \PDO
  ///
  PDOExecutionContext getPdoForSelect([bool useReadPdo = true]) {
    return useReadPdo ? this.getReadPdo() : this.getPdo();
  }

  ///
  /// Run an insert statement against the database.
  ///
  /// @param  String  $query
  /// @param  array   $bindings
  /// @return bool
  ///
  Future<PDOResults> insert(query,
      [bindings = const [], int? timeoutInSeconds]) async {
    return this.statement(query, bindings, timeoutInSeconds);
  }

  ///
  /// Run an update statement against the database.
  ///
  /// @param  String  $query
  /// @param  array   $bindings
  /// @return int
  ///
  Future<int> update(String query,
      [List bindings = const [], int? timeoutInSeconds]) {
    return this.affectingStatement(query, bindings, timeoutInSeconds);
  }

  ///
  /// Run a delete statement against the database.
  ///
  /// @param  String  $query
  /// @param  array   $bindings
  /// @return int
  ///
  Future<int> delete(String query,
      [List bindings = const [], int? timeoutInSeconds]) {
    return this.affectingStatement(query, bindings, timeoutInSeconds);
  }

  ///
  /// Execute an SQL statement and return the boolean result.
  ///
  /// @param  String  $query
  /// @param  array   $bindings
  /// @return bool
  ///
  Future<PDOResults> statement(String query,
      [bindingsP = const [], int? timeoutInSeconds]) async {
    final resp = await this.run(query, bindingsP,
        (me, query, bindings, timeoutInSeconds) async {
      if (me.pretending()) {
        return true;
      }

      final pdoL = me.getPdo();
      final params = me.prepareBindings(bindings);
      return await pdoL.query(query, params, timeoutInSeconds);
    }, timeoutInSeconds);

    return resp as PDOResults;
  }

  /// simple execute command on database
  ///  Executa uma instrução SQL e retornar o número de linhas afetadas
  Future<dynamic> execute(String query, [int? timeoutInSeconds]) async {
    final resp = await this.run(query, [],
        (me, query, bindings, timeoutInSeconds) async {
      if (me.pretending()) {
        return true;
      }

      var pdoL = me.getPdo();
      var res = await pdoL.execute(query, timeoutInSeconds);

      return [res];
    }, timeoutInSeconds);

    return resp;
  }

  ///
  /// Run an SQL statement and get the number of rows affected.
  ///
  /// @param  String  $query
  /// @param  array   $bindings
  /// @return int
  ///
  Future<int> affectingStatement(String query,
      [List<dynamic> bindingsP = const [], int? timeoutInSeconds]) async {
    final resp = await this.run(query, bindingsP,
        (me, query, bindings, timeoutInSeconds) async {
      if (me.pretending()) {
        return 0;
      }

      // For update or delete statements, we want to get the number of rows affected
      // by the statement and return that back to the developer. We'll first need
      // to execute the statement and then we'll use PDO to fetch the affected.
      final _pdo = me.getPdo();
      final params = me.prepareBindings(bindings);
      final res = await _pdo.query(query, params, timeoutInSeconds);
      return res.rowsAffected;
    }, timeoutInSeconds);

    return resp as int;
  }

  ///
  /// Run a raw, unprepared query against the PDO connection.
  ///
  /// @param  String  $query
  /// @return bool
  ///
  Future<int> unprepared(String query, [int? timeoutInSeconds]) async {
    final resp = await this.run(query, [],
        (me, query, bindings, timeoutInSeconds) async {
      if (me.pretending()) {
        return true;
      }

      return me.getPdo().execute(query, timeoutInSeconds);
    }, timeoutInSeconds);
    return resp as int;
  }

  ///
  /// Prepare the query bindings for execution.
  ///
  /// @param  array  bindings
  /// @return array
  ///
  dynamic prepareBindings(List<dynamic> bindings) {
    var grammar = getQueryGrammar();

    for (var i = 0; i < bindings.length; i++) {
      var key = i;
      var value = bindings[key];
      // We need to transform all instances of DateTimeInterface into the actual
      // date string. Each query grammar maintains its own date string format
      // so we'll just ask the grammar for the format to get from the date.
      if (value is DateTime) {
        bindings[key] = Utils.formatDate(value, grammar.getDateFormat());
      } else if (value == false) {
        bindings[key] = 0;
      }
    }

    return bindings;
  }

  ///
  /// Execute a Closure within a transaction.
  ///
  /// @param  Function  callback
  /// @return mixed
  ///
  /// @throws \Throwable
  Future<dynamic> transaction(Future<dynamic> Function(Connection ctx) callback,
      [int? timeoutInSeconds]) async {
    var result = this.pdo.pdoInstance.runInTransaction((pdoCtx) {
      final newConnection = Connection(
          pdoCtx, this._databaseName, this._tablePrefix, this._config);
      return callback(newConnection);
    });

    return result;
  }

  ///
  /// Start a new database transaction.
  ///
  /// @return void
  ///
  // Future<dynamic> beginTransaction() async {
  // this.transactions++;
  // if (this.transactions == 1) {
  //   this.pdo!.beginTransaction();
  // } else if (this.transactions > 1 &&
  //     this.queryGrammar.supportsSavepoints()) {
  //   this.pdo!.exec(this
  //       .queryGrammar
  //       .compileSavepoint('trans' + this.transactions.toString()));
  // }
  // this.fireConnectionEvent('beganTransaction');
  //throw UnimplementedError();
  // this.pdo!.beginTransaction();
  // }

  ///
  /// Commit the active database transaction.
  ///
  /// @return void
  ///
  // Future<dynamic> commit([dynamic transaction]) async {
  // if (this.transactions == 1) {
  //   this.pdo!.commit();
  // }
  // --this.transactions;
  // this.fireConnectionEvent('committed');
  //throw UnimplementedError();
  // return this.pdo!.commit(transaction);
  //}

  ///
  /// Rollback the active database transaction.
  ///
  /// @return void
  ///
  //Future<dynamic> rollBack([dynamic transaction]) async {
  // if (this.transactions == 1) {
  //   await this.pdo!.rollBack();
  // } else if (this.transactions > 1 &&
  //     this.queryGrammar.supportsSavepoints()) {
  //   //  await this.pdo!.exec(this
  //   //       .queryGrammar
  //   //       .compileSavepointRollBack('trans' + this.transactions.toString()));
  //   throw UnimplementedError();
  // }

  // this.transactions = Utils.int_max(0, this.transactions - 1);
  // this.fireConnectionEvent('rollingBack');
  //return this.pdo!.rollBack(transaction);
  //}

  ///
  /// Get the number of active transactions.
  ///
  /// @return int
  ///
  int transactionLevel() {
    return this.transactions;
  }

  ///
  /// Execute the given callback in "dry run" mode.
  ///
  /// @param  \Closure  $callback
  /// @return array
  ///
  Future<dynamic> pretend(Function callback) async {
    var loggingQueries = this.loggingQueries;

    this.enableQueryLog();
    this.pretendingProp = true;
    this.queryLog = [];

    // Basically to make the database connection "pretend", we will just return
    // the default values for all the query methods, then we will return an
    // array of queries that were "executed" within the Closure callback.
    callback(this);
    this.pretendingProp = false;
    this.loggingQueries = loggingQueries;
    return this.queryLog;
  }

  ///
  /// Run a SQL statement and log its execution context.
  ///
  /// @param  String    $query
  /// @param  array     $bindings
  /// @param  \Closure  $callback
  /// @return mixed
  ///
  /// @throws \Illuminate\Database\QueryException
  ///
  Future<dynamic> run(
      String query,
      dynamic bindings,
      Future<dynamic> Function(Connection con, String query, dynamic bindings,
              int? timeoutInSeconds)
          callback,
      [int? timeoutInSeconds]) async {
    //this.reconnectIfMissingConnection();

    //var start = Utils.microtime();
    var result;
    // Here we will run this query. If an exception occurs we'll determine if it was
    // caused by a connection that has been lost. If that is the cause, we'll try
    // to re-establish connection and re-run the query with a fresh connection.
    try {
      // print('Connection@run');
      result = await this
          .runQueryCallback(query, bindings, callback, timeoutInSeconds);
      //print('Connection@run $result');
    } catch (e) {
      //  print('Connection@run error $e $e');
      // result = await this
      //     .tryAgainIfCausedByLostConnection(e, query, bindings, callback, timeoutInSeconds);

      if (this.causedByLostConnection(e) &&
          tryReconnectCount < tryReconnectLimit) {
        await Future.delayed(Duration(milliseconds: 1000));
        // print('Eloquent@tryAgainIfCausedByLostConnection try reconnect...');
        tryReconnectLimit++;
        await this.reconnect();
        tryReconnectLimit = 0;
        return await this
            .runQueryCallback(query, bindings, callback, timeoutInSeconds);
      }
      rethrow;
    }

    // Once we have run the query we will calculate the time that it took to run and
    // then log the query, bindings, and execution time so we will report them on
    // the event that the developer needs them. We'll log time in milliseconds.
    //var time = this.getElapsedTime(start);

    //this.logQuery(query, bindings, time);

    return result;
  }

  ///
  /// Run a SQL statement.
  ///
  /// @param  String    $query
  /// @param  array     $bindings
  /// @param  \Closure  $callback
  /// @return mixed
  ///
  /// @throws \Illuminate\Database\QueryException
  ///
  Future<dynamic> runQueryCallback(
      String query,
      bindings,
      Future<dynamic> Function(Connection con, String query, dynamic bindings,
              int? timeoutInSeconds)
          callback,
      int? timeoutInSeconds) async {
    // To execute the statement, we'll simply call the callback, which will actually
    // run the SQL against the PDO connection. Then we can calculate the time it
    // took to execute and log the query SQL, bindings and time in our memory.
    var result;
    //try {
    result = await callback(this, query, bindings, timeoutInSeconds);
    //}

    // If an exception occurs when attempting to run a query, we'll format the error
    // message to include the bindings with SQL, which will make this exception a
    // lot more helpful to the developer instead of just the database's errors.
    // catch (e) {
    //   throw new QueryException(query, this.prepareBindings(bindings), e);
    // }

    return result;
  }

  ///
  /// Handle a query exception that occurred during query execution.
  ///
  /// @param  \Illuminate\Database\QueryException  $e
  /// @param  String    $query
  /// @param  array     $bindings
  /// @param  \Closure  $callback
  /// @return mixed
  ///
  /// @throws \Illuminate\Database\QueryException
  ///
  Future<dynamic> tryAgainIfCausedByLostConnection(
      dynamic e,
      String query,
      bindings,
      Future<dynamic> Function(
              Connection, String, dynamic, int? timeoutInSeconds)
          callback,
      int? timeoutInSeconds,
      {int delay = 1000}) async {
    if (this.causedByLostConnection(e) &&
        tryReconnectCount < tryReconnectLimit) {
      await Future.delayed(Duration(milliseconds: delay));
      // print('Eloquent@tryAgainIfCausedByLostConnection try reconnect...');
      tryReconnectLimit++;
      await this.reconnect();
      tryReconnectLimit = 0;
      return await this
          .runQueryCallback(query, bindings, callback, timeoutInSeconds);
    }
    // print('tryAgainIfCausedByLostConnection');
    throw e;
  }

  ///
  /// Disconnect from the underlying PDO connection.
  ///
  /// @return void
  ///
  Future<void> disconnect() async {
    // this.setPdo(null).setReadPdo(null);
    //throw UnimplementedError();
    //print('Connection@disconnect');
    try {
      await this.pdo.pdoInstance.close();
    } catch (e, s) {
      print('eloquent@disconnect error $e $s');
    }
  }

  ///
  /// Reconnect to the database.
  ///
  /// @return void
  ///
  /// @throws \LogicException
  ///
  Future<void> reconnect() async {
    //print('Connection@reconnect() ${this.reconnector}');
    if (this.reconnector != null) {
      return await this.reconnector!(this);
    }

    throw LogicException('Lost connection and no reconnector available.');
  }

  ///
  /// Reconnect to the database if a PDO connection is missing.
  ///
  /// @return void
  ///
  Future<void> reconnectIfMissingConnection() async {
    if (Utils.is_null(this.getPdo()) || Utils.is_null(this.getReadPdo())) {
      await this.reconnect();
    }
  }

  ///
  /// Log a query in the connection's query log.
  ///
  /// @param  String  $query
  /// @param  array   $bindings
  /// @param  float|null  $time
  /// @return void
  ///
  dynamic logQuery(String query, bindings, [time = null]) {
    // if (isset(this.events)) {
    //     this.events->fire(new Events\QueryExecuted(
    //         $query, $bindings, $time, $this
    //     ));
    // }

    if (this.loggingQueries) {
      this.queryLog.add({'query': query, 'bindings': bindings, 'time': time});
    }
  }

  ///
  /// Register a database query listener with the connection.
  ///
  /// @param  \Closure  $callback
  /// @return void
  ///
  dynamic listen(Function callback) {
    // if (isset(this.events)) {
    //     this.events->listen(Events\QueryExecuted::class, $callback);
    // }
    throw UnimplementedError();
  }

  ///
  /// Fire an event for this connection.
  ///
  /// @param  String  $event
  /// @return void
  ///
  void fireConnectionEvent(String event) {
    // if (! isset(this.events)) {
    //     return;
    // }

    // switch ($event) {
    //     case 'beganTransaction':
    //         return this.events->fire(new Events\TransactionBeginning($this));
    //     case 'committed':
    //         return this.events->fire(new Events\TransactionCommitted($this));
    //     case 'rollingBack':
    //         return this.events->fire(new Events\TransactionRolledBack($this));
    // }
    throw UnimplementedError();
  }

  ///
  /// Get the elapsed time since a given starting point.
  ///
  /// @param  int    $start
  /// @return float
  ///
  dynamic getElapsedTime(int start) {
    return Utils.round((Utils.microtime() - start) * 1000);
  }

  ///
  /// Is Doctrine available?
  ///
  /// @return bool
  ///
  bool isDoctrineAvailable() {
    //return class_exists('Doctrine\DBAL\Connection');
    return false;
  }

  ///
  /// Get a Doctrine Schema Column instance.
  ///
  /// @param  String  $table
  /// @param  String  $column
  /// @return \Doctrine\DBAL\Schema\Column
  ///
  dynamic getDoctrineColumn($table, $column) {
    // $schema = this.getDoctrineSchemaManager();
    // return $schema->listTableDetails($table)->getColumn($column);
    return null;
  }

  ///
  /// Get the Doctrine DBAL schema manager for the connection.
  ///
  /// @return \Doctrine\DBAL\Schema\AbstractSchemaManager
  ///
  dynamic getDoctrineSchemaManager() {
    //return this.getDoctrineDriver()->getSchemaManager(this.getDoctrineConnection());
    return null;
  }

  ///
  /// Get the Doctrine DBAL database connection instance.
  ///
  /// @return \Doctrine\DBAL\Connection
  ///
  dynamic getDoctrineConnection() {
    // if (is_null(this.doctrineConnection)) {
    //     $driver = this.getDoctrineDriver();

    //     $data = ['pdo' => this.pdo, 'dbname' => this.getConfig('database')];

    //     this.doctrineConnection = new DoctrineConnection($data, $driver);
    // }

    // return this.doctrineConnection;
    return null;
  }

  ///
  /// Get the current PDO connection.
  ///
  /// @return \PDO
  ///
  PDOExecutionContext getPdo() {
    return this.pdo;
  }

  ///
  /// Get the current PDO connection used for reading.
  ///
  /// @return \PDO
  ///
  PDOExecutionContext getReadPdo() {
    if (this.transactions >= 1) {
      return this.getPdo();
    }

    return this.readPdo ?? this.pdo;
  }

  ///
  /// Set the PDO connection.
  ///
  /// @param  \PDO|null  $pdo
  /// @return $this
  ///
  dynamic setPdo(PDOExecutionContext pdo) {
    if (this.transactions >= 1) {
      //RuntimeException
      throw Exception("Can't swap PDO instance while within transaction.");
    }

    this.pdo = pdo;

    return this;
  }

  ///
  /// Set the PDO connection used for reading.
  ///
  /// @param  \PDO|null  $pdo
  /// @return $this
  ///
  dynamic setReadPdo($pdo) {
    this.readPdo = $pdo;
    return this;
  }

  ///
  /// Set the reconnect instance on the connection.
  ///
  /// @param  callable  $reconnector
  /// @return $this
  ///
  dynamic setReconnector(Future<dynamic> Function(Connection) reconnectorP) {
    this.reconnector = reconnectorP;
    return this;
  }

  ///
  /// Get the database connection name.
  ///
  /// @return string|null
  ///
  dynamic getName() {
    return this.getConfig('name');
  }

  ///
  /// Get an option from the configuration options.
  ///
  /// @param  String  $option
  /// @return mixed
  ///
  dynamic getConfig(String option) {
    //return Arr::get(this.config, $option);
    //print('getConfig ${this._config}');
    //throw UnimplementedError();
    return this._config[option];
  }

  Map<String, dynamic> getConfigs() {
    return this._config;
  }

  ///
  /// Get the PDO driver name.
  ///
  /// @return string
  ///
  String getDriverName() {
    //return this.pdo->getAttribute(PDO::ATTR_DRIVER_NAME);
    return 'teste';
  }

  ///
  /// Get the query grammar used by the connection.
  ///
  /// @return \Illuminate\Database\Query\Grammars\Grammar
  ///
  QueryGrammar getQueryGrammar() {
    return this.queryGrammar;
  }

  ///
  /// Set the query grammar used by the connection.
  ///
  /// @param  \Illuminate\Database\Query\Grammars\Grammar  $grammar
  /// @return void
  ///
  void setQueryGrammar(QueryGrammar grammarP) {
    this.queryGrammar = grammarP;
  }

  ///
  /// Get the schema grammar used by the connection.
  ///
  /// @return \Illuminate\Database\Schema\Grammars\Grammar
  ///
  SchemaGrammar getSchemaGrammar() {
    return this.schemaGrammar!;
  }

  ///
  /// Set the schema grammar used by the connection.
  ///
  /// @param  \Illuminate\Database\Schema\Grammars\Grammar  $grammar
  /// @return void
  ///
  void setSchemaGrammar(SchemaGrammar grammarP) {
    this.schemaGrammar = grammarP;
  }

  ///
  /// Get the query post processor used by the connection.
  ///
  /// @return \Illuminate\Database\Query\Processors\Processor
  ///
  dynamic getPostProcessor() {
    return this.postProcessor;
  }

  ///
  /// Set the query post processor used by the connection.
  ///
  /// @param  \Illuminate\Database\Query\Processors\Processor  $processor
  /// @return void
  ///
  dynamic setPostProcessor(Processor processor) {
    this.postProcessor = processor;
  }

  ///
  /// Get the event dispatcher used by the connection.
  ///
  /// @return \Illuminate\Contracts\Events\Dispatcher
  ///
  dynamic getEventDispatcher() {
    //return this.events;
    throw UnimplementedError();
  }

  ///
  /// Set the event dispatcher instance on the connection.
  ///
  /// @param  \Illuminate\Contracts\Events\Dispatcher  $events
  /// @return void
  ///
  dynamic setEventDispatcher($events) {
    //this.events = $events;
    throw UnimplementedError();
  }

  ///
  /// Determine if the connection in a "dry run".
  ///
  /// @return bool
  ///
  bool pretending() {
    return this.pretending == true;
  }

  ///
  /// Get the connection query log.
  ///
  /// @return array
  ///
  dynamic getQueryLog() {
    return this.queryLog;
  }

  ///
  /// Clear the query log.
  ///
  /// @return void
  ///
  dynamic flushQueryLog() {
    this.queryLog = [];
  }

  ///
  /// Enable the query log on the connection.
  ///
  /// @return void
  ///
  dynamic enableQueryLog() {
    this.loggingQueries = true;
  }

  ///
  /// Disable the query log on the connection.
  ///
  /// @return void
  ///
  void disableQueryLog() {
    this.loggingQueries = false;
  }

  ///
  /// Determine whether we're logging queries.
  ///
  /// @return bool
  ///
  bool logging() {
    return this.loggingQueries;
  }

  ///
  /// Get the name of the connected database.
  ///
  /// @return string
  ///
  String getDatabaseName() {
    return this._databaseName;
  }

  ///
  /// Set the name of the connected database.
  ///
  /// @param  String  $database
  /// @return string
  ///
  void setDatabaseName(String database) {
    this._databaseName = database;
  }

  ///
  /// Get the table prefix for the connection.
  ///
  /// @return string
  ///
  String getTablePrefix() {
    return this._tablePrefix;
  }

  ///
  /// Set the table prefix in use by the connection.
  ///
  /// @param  String  $prefix
  /// @return void
  ///
  void setTablePrefix(String prefix) {
    this._tablePrefix = prefix;

    this.getQueryGrammar().setTablePrefix(prefix);
  }

  ///
  /// Set the table prefix and return the grammar.
  ///
  /// @param  \Illuminate\Database\Grammar  $grammar
  /// @return \Illuminate\Database\Grammar
  ///
  dynamic withTablePrefix(BaseGrammar grammar) {
    grammar.setTablePrefix(this._tablePrefix);

    return grammar;
  }
}

// File: C:\MyDartProjects\eloquent\lib\src\connection_interface.dart
import 'package:eloquent/eloquent.dart';

const listVoid = [];

abstract class ConnectionInterface {
  ///
  /// Begin a fluent query against a database table.
  ///
  /// [table]  String  table
  ///  @return \Illuminate\Database\Query\Builder
  ///
  QueryBuilder table(String table);

  ///
  /// Get a new raw query expression.
  ///
  /// [value]  dynamic
  /// @return Expression
  ///
  QueryExpression raw(dynamic value);

  ///
  /// Run a select statement and return a single result.
  ///
  /// [query]  String
  /// [bindings]  List
  /// @return dynamic
  ///
  Future<Map<String, dynamic>?> selectOne(String query,
      [List bindings = listVoid, int? timeoutInSeconds]);

  ///
  /// Run a select statement against the database.
  ///
  /// [query]  String
  /// [bindings]  List
  /// @return array
  ///
  Future<List<Map<String, dynamic>>> select(String query,
      [List bindings = listVoid,
      bool useReadPdo = true,
      int? timeoutInSeconds]);

  ///
  /// Run an insert statement against the database.
  ///
  /// [query]  String
  /// [bindings]  List
  /// @return bool
  ///
  Future<PDOResults> insert(String query,
      [List bindings = listVoid, int? timeoutInSeconds]);

  ///
  /// Run an update statement against the database.
  ///
  /// [query]  String
  /// [bindings]  List
  /// @return int
  ///
  Future<dynamic> update(String query,
      [List bindings = listVoid, int? timeoutInSeconds]);

  ///
  /// Run a delete statement against the database.
  ///
  /// [query]  String
  /// [bindings]  List
  /// @return int
  ///
  Future<int> delete(String query,
      [List bindings = listVoid, int? timeoutInSeconds]);

  ///
  /// Execute an SQL statement and return the boolean result.
  ///
  /// [query] string
  /// [bindings]  List
  /// @return bool
  ///
  Future<PDOResults> statement(String query,
      [List bindings = listVoid, int? timeoutInSeconds]);

  ///
  /// Run an SQL statement and get the number of rows affected.
  ///
  /// [query] String
  /// [bindings]  List
  /// @return int
  ///
  Future<int> affectingStatement(String query,
      [List bindings = listVoid, int? timeoutInSeconds]);

  ///
  /// Run a raw, unprepared query against the PDO connection.
  ///
  /// [query]  String
  /// @return bool
  ///
  Future<int> unprepared(String query, int? timeoutInSeconds);

  ///
  /// Prepare the query bindings for execution.
  ///
  /// [bindings]  List
  ///  Returns `List`
  ///
  dynamic prepareBindings(List bindings);

  ///
  /// Execute a Closure within a transaction.
  ///
  /// [callback] Function \Closure
  /// Returns `dynamic`
  ///
  /// @throws \Throwable
  ///
  Future<dynamic> transaction(
      Future<dynamic> Function(Connection ctx) callback, [int? timeoutInSeconds]);

  ///
  /// Start a new database transaction.
  ///
  /// Returns `void`
  ///
  //Future<dynamic> beginTransaction();

  ///
  /// Commit the active database transaction.
  ///
  /// Returns `void`
  ///
  //Future<dynamic> commit([dynamic transaction]);

  ///
  /// Rollback the active database transaction.
  ///
  /// Returns `void`
  ///
  //Future<dynamic> rollBack([dynamic transaction]);

  ///
  /// Get the number of active transactions.
  ///
  /// Returns `int`
  ///
  int transactionLevel();

  ///
  /// Execute the given callback in "dry run" mode.
  ///
  /// [callback]  Function
  /// Returns `List`
  ///
  Future<dynamic> pretend(Function callback);
}

// File: C:\MyDartProjects\eloquent\lib\src\connection_resolver_interface.dart
import '../eloquent.dart';

abstract class ConnectionResolverInterface {
  ///
  /// Get a database connection instance.
  ///
  /// @param  string  $name
  /// @return \Illuminate\Database\ConnectionInterface
  ///
  Future<ConnectionInterface> connection([String name]);

  ///
  /// Get the default connection name.
  ///
  /// @return string
  ///
  String getDefaultConnection();

  ///
  /// Set the default connection name.
  ///
  /// @param  string  $name
  /// @return void
  ///
  void setDefaultConnection(String name);
}

// File: C:\MyDartProjects\eloquent\lib\src\connectors\connection_factory.dart
import 'package:eloquent/eloquent.dart';
import 'package:eloquent/src/container/container.dart';
import 'package:eloquent/src/mysql_connection.dart';

import 'mysql_connector.dart';

class ConnectionFactory {
  /**
     * The IoC container instance.
     *
     * @var \Illuminate\Contracts\Container\Container
     */
  Container container;

  /**
     * Create a new connection factory instance.
     *
     * @param  \Illuminate\Contracts\Container\Container  $container
     * @return void
     */
  ConnectionFactory(this.container);

  ///
  /// Establish a PDO connection based on the configuration.
  ///
  /// @param  array   $config
  /// @param  string  $name
  /// @return \Illuminate\Database\Connection
  ///
  Future<Connection> make(Map<String, dynamic> configP,
      [String name = 'default']) {
    var config = parseConfig(configP, name);

    if (config['read'] != null) {
      return createReadWriteConnection(config);
    }

    return createSingleConnection(config);
  }

  ///
  /// Create a single database connection instance.
  ///
  /// @param  array  $config
  /// @return \Illuminate\Database\Connection
  ///
  Future<Connection> createSingleConnection(Map<String, dynamic> config) async {
    var conC = createConnector(config);

    var pdo = await conC.connect(config);

    return createConnection(
        config['driver'], pdo, config['database'], config['prefix'], config);
  }

  ///
  /// Create a single database connection instance.
  ///
  /// @param  array  $config
  /// @return \Illuminate\Database\Connection
  ///
  Future<Connection> createReadWriteConnection(
      Map<String, dynamic> config) async {
    var connection = await createSingleConnection(getWriteConfig(config));
    var pdo = await createReadPdo(config);
    connection.setReadPdo(pdo);
    return connection;
  }

  ///
  /// Create a new PDO instance for reading.
  ///
  /// @param  array  $config
  /// @return \PDO
  ///
  Future<PDOInterface> createReadPdo(Map<String, dynamic> config) async {
    var readConfig = getReadConfig(config);

    return createConnector(readConfig).connect(readConfig);
  }

  ///
  /// Get the read configuration for a read / write connection.
  ///
  /// @param  array  $config
  /// @return array
  ///
  Map<String, dynamic> getReadConfig(Map<String, dynamic> config) {
    var readConfig = getReadWriteConfig(config, 'read');

    if (readConfig['host'] != null && Utils.is_array(readConfig['host'])) {
      readConfig['host'] = Utils.count(readConfig['host']) > 1
          ? readConfig['host'][Utils.array_rand(readConfig['host'])]
          : readConfig['host'][0];
    }

    return mergeReadWriteConfig(config, readConfig);
  }

  ///
  /// Get the read configuration for a read / write connection.
  ///
  /// @param  array  $config
  /// @return array
  ///
  Map<String, dynamic> getWriteConfig(Map<String, dynamic> config) {
    var writeConfig = getReadWriteConfig(config, 'write');
    return mergeReadWriteConfig(config, writeConfig);
  }

  ///
  /// Get a read / write level configuration.
  ///
  /// @param  array   $config
  /// @param  string  $type
  /// @return array
  ///
  Map<String, dynamic> getReadWriteConfig(
      Map<String, dynamic> config, String type) {
    // if (config[type][0] != null) {
    //     return config[type][array_rand($config[$type])];
    // }

    return config[type];
  }

  ///
  /// Merge a configuration for a read / write connection.
  ///
  /// @param  array  $config
  /// @param  array  $merge
  /// @return array
  ///
  Map<String, dynamic> mergeReadWriteConfig(
      Map<String, dynamic> config, Map<String, dynamic> merge) {
    return Utils.map_except_sd(
        Utils.map_merge_sd(config, merge), ['read', 'write']);
  }

  ///
  /// Parse and prepare the database configuration.
  ///
  /// @param  Map<String,dynamic>   config
  /// @param  String  name
  /// @return Map<String,dynamic>
  ///
  Map<String, dynamic> parseConfig(Map<String, dynamic> config, String name) {
    var arr = Utils.map_add_sd(config, 'prefix', '');
    var result = Utils.map_add_sd(arr, 'name', name);
    return result;
  }

  ///
  ///  Create a connector instance based on the configuration.
  ///
  ///  @param  array  $config
  ///  @return \Illuminate\Database\Connectors\ConnectorInterface
  ///
  ///  @throws \InvalidArgumentException
  ///
  ConnectorInterface createConnector(Map<String, dynamic> config) {
    if (config['driver'] == null) {
      throw InvalidArgumentException('A driver must be specified.');
    }

    // if ($this->container->bound($key = "db.connector.{$config['driver']}")) {
    //     return $this->container->make($key);
    // }

    switch (config['driver']) {
      case 'mysql':
        return MySqlConnector();

      case 'pgsql':
        return PostgresConnector();

      // case 'sqlite':
      //     return new SQLiteConnector;

      // case 'sqlsrv':
      //     return new SqlServerConnector;
    }

    throw InvalidArgumentException("Unsupported driver [${config['driver']}]");
  }

  ///
  ///  Create a new Connection instance.
  ///
  ///  @param  string   $driver
  ///  @param  \PDO     $connection
  ///  @param  string   $database
  ///  @param  string   $prefix
  ///  @param  array    $config
  ///  @return \Illuminate\Database\Connection
  ///
  ///  @throws \InvalidArgumentException
  ///
  Connection createConnection(String driver, PDOInterface pdoP, String database,
      [String prefix = '', Map<String, dynamic> config = const {}]) {
    // if ($this->container->bound($key = "db.connection.{$driver}")) {
    //     return $this->container->make($key, [$connection, $database, $prefix, $config]);
    // }

    switch (driver) {
      case 'mysql':
        return MySqlConnection(pdoP, database, prefix, config);

      case 'pgsql':
        return PostgresConnection(pdoP, database, prefix, config);

      // case 'sqlite':
      //     return new SQLiteConnection($connection, $database, $prefix, $config);

      // case 'sqlsrv':
      //     return new SqlServerConnection($connection, $database, $prefix, $config);
    }

    throw InvalidArgumentException("Unsupported driver [$driver]");
  }
}

// File: C:\MyDartProjects\eloquent\lib\src\connectors\connector.dart
import '../../eloquent.dart';

abstract class Connector with DetectsLostConnections {
  ///
  /// The default PDO connection options.
  ///
  /// @var array
  ///
  Map<dynamic, dynamic> options = {};

  ///
  /// Get the PDO options based on the configuration.
  ///
  /// @param  array  $config
  /// @return array
  ///
  Map<dynamic, dynamic> getOptions(Map<dynamic, dynamic> config) {
    var optionsP = config['options'];
    //return array_diff_key(options, optionsP) + $options;
    //Utils.map_merge_sd(options, optionsP);
    if (optionsP != null) {
      return {...options, ...optionsP};
    }
    return options;
  }

  ///
  /// Create a new PDO connection.
  ///
  /// @param  string  $dsn
  /// @param  array   $config
  /// @param  array   $options
  /// @return \PDO
  ///
  dynamic createConnection(Map<String, dynamic> config);
}

// File: C:\MyDartProjects\eloquent\lib\src\connectors\connector_interface.dart


import '../pdo/core/pdo_interface.dart';

abstract class ConnectorInterface {
  ///
  /// Establish a database connection.
  ///
  /// @param  array  $config
  /// @return \PDO
  ///
  Future<PDOInterface> connect(Map<String, dynamic> config);
}

// File: C:\MyDartProjects\eloquent\lib\src\connectors\mysql_connector.dart
import 'package:eloquent/eloquent.dart';

import 'package:eloquent/src/pdo/mysql_client/mysql_client_pdo.dart';

class MySqlConnector extends Connector implements ConnectorInterface {
  ///
  /// The default PDO connection options.
  ///
  /// @var array
  ///
  Map<dynamic, dynamic> options = {};

  ///
  /// Establish a database connection.
  ///
  /// [config] Map<String, dynamic>
  /// @return PostgreSQLConnection \PDO
  ///
  Future<PDOInterface> connect(Map<String, dynamic> config) async {
    //final dsn = getDsn(config);
    //final options = getOptions(config);
    final connection = await createConnection(config);

    if (config.containsKey('database') && config['database'] != null) {
      await connection.execute("use `${config['database']}`;");
    }

    // var collation =config.containsKey('collation') ? config['collation'] : null;

    // Next we will set the "names" and "collation" on the clients connections so
    // a correct character set will be used by this client. The collation also
    // is set on the server but needs to be set here on this client objects.

    if (config.containsKey('charset') && config['charset'] != null) {
      var charset = config['charset'];

      var names = "set names '$charset'" +
          (config.containsKey('collation')
              ? " collate '${config['collation']}'"
              : '');

      await connection.execute(names);
    }
    // Next, we will check to see if a timezone has been specified in this config
    // and if it has we will issue a statement to modify the timezone with the
    // database. Setting this DB timezone is an optional configuration item.
    if (config.containsKey('timezone')) {
      await connection.execute('set time_zone="' + config['timezone'] + '"');
    }

    await this.setModes(connection, config);

    return connection;
  }

  ///
  /// Create a DSN string from a configuration.
  ///
  /// @param  array   $config
  /// @return string
  ///
  String getDsn(Map<String, dynamic> config) {
    // First we will create the basic DSN setup as well as the port if it is in
    // in the configuration options. This will give us the basic DSN we will
    // need to establish the PDO connections and return them back for use.

    final host = config['host'] != null ? "host=${config['host']};" : '';
    var dsn = "mysql:${host}dbname=${config['database']}";

    // If a port was specified, we will add it to this Postgres DSN connections
    // format. Once we have done that we are ready to return this connection
    // string back out for usage, as this has been fully constructed here.
    if (config['port'] != null) {
      dsn += ";port=${config['port']}";
    }

    if (config['sslmode'] != null) {
      dsn += ";sslmode=${config['sslmode']}";
    }

    // add charset to DSN
    if (config.containsKey('charset') && config['charset'] != null) {
      dsn = "$dsn;charset=${config['charset']}";
    }
    // add Pool opttions to DSN
    if (config['pool'] != null) {
      dsn += ";pool=${config['pool']}";
    }

    if (config['poolsize'] != null) {
      dsn += ";poolsize=${config['poolsize']}";
    }

    if (config['allowreconnect'] != null) {
      dsn += ";allowreconnect=${config['allowreconnect']}";
    }

    if (config['application_name'] != null) {
      dsn += ";application_name=${config['application_name']}";
    }

    return dsn;
  }

  ///
  /// Set the modes for the connection.
  ///
  /// @param  \PDO  $connection
  /// @param  array  $config
  /// @return void
  ///
  Future<void> setModes(
      PDOInterface connection, Map<String, dynamic> config) async {
    if (config.containsKey('modes')) {
      var modes = Utils.implode(',', config['modes']);

      connection.execute("set session sql_mode='" + modes + "'");
    } else if (config.containsKey('strict')) {
      if (config['strict'] != null) {
        await connection.execute(
            "set session sql_mode='ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION'");
      } else {
        await connection
            .execute("set session sql_mode='NO_ENGINE_SUBSTITUTION'");
      }
    }
  }

  ///
  /// Format the schema for the DSN.
  ///
  /// @param  array|string  $schema
  /// @return string
  ///
  String formatSchema(dynamic schema) {
    if (Utils.is_array(schema)) {
      return '"' + Utils.implode('", "', schema) + '"';
    } else {
      return '"' + schema + '"';
    }
  }

  ///
  /// Create a new PDO connection.
  ///
  /// @param  string  $dsn
  /// @param  array   $config
  /// @param  array   $options
  /// @return \PDO
  /// Aqui que cria a conexão com o Banco de Dados de fato
  ///
  Future<PDOInterface> createConnection(Map<String, dynamic> config) async {
    late PDOInterface pdo;

    final pdoConfig = PDOConfig.fromMap(config);

    pdo = MySqlClientPDO(pdoConfig);

    await pdo.connect();

    return pdo;
  }
}

// File: C:\MyDartProjects\eloquent\lib\src\connectors\postgres_connector.dart
import 'package:eloquent/eloquent.dart';
import 'package:eloquent/src/pdo/dargres/dargres_pdo.dart';
import 'package:eloquent/src/pdo/postgres/postgres_pdo.dart';
import 'package:eloquent/src/pdo/postgres_v3/postgres_v3_pdo.dart';

class PostgresConnector extends Connector implements ConnectorInterface {
  ///
  /// The default PDO connection options.
  ///
  /// @var array
  ///
  Map<dynamic, dynamic> options = {};

  ///
  /// Establish a database connection.
  ///
  /// [config] Map<String, dynamic>
  /// @return PostgreSQLConnection \PDO
  ///
  Future<PDOInterface> connect(Map<String, dynamic> config) async {
    // First we'll create the basic DSN and connection instance connecting to the
    // using the configuration option specified by the developer. We will also
    // set the default character set on the connections to UTF-8 by default.

    //var dsn = getDsn(config);
    //var options = getOptions(config);
    var connection = await createConnection(config);

    // if (config.containsKey('charset') && config['charset'] != null) {
    //   var charset = config['charset'];
    //   //await connection.execute("set names '$charset'");
    // }

    // Next, we will check to see if a timezone has been specified in this config
    // and if it has we will issue a statement to modify the timezone with the
    // database. Setting this DB timezone is an optional configuration item.

    // if (config.containsKey('timezone') && config['timezone'] != null) {
    //   var timezone = config['timezone'];
    //   await connection.execute("set timezone TO '$timezone'");
    // }

    // Unlike MySQL, Postgres allows the concept of "schema" and a default schema
    // may have been specified on the connections. If that is the case we will
    // set the default schema search paths to the specified database schema.
    // if (config.containsKey('schema') && config['schema'] != null) {
    //   var schema = formatSchema(config['schema']);
    //   await connection.execute("set search_path to $schema");
    // }

    // Postgres allows an application_name to be set by the user and this name is
    // used to when monitoring the application with pg_stat_activity. So we'll
    // determine if the option has been specified and run a statement if so.

    // if (config.containsKey('application_name') &&
    //     config['application_name'] != null) {
    //   var applicationName = config['application_name'];
    //   try {
    //     await connection.execute("set application_name to '$applicationName'");
    //   } catch (e) {
    //     print(
    //         'Eloquent: Unable to set the application_name for this PostgreSQL driver.');
    //   }
    // }

    return connection;
  }

  ///
  /// Create a DSN string from a configuration.
  ///
  /// @param  array   $config
  /// @return string
  ///
  String getDsn(Map<String, dynamic> config) {
    // First we will create the basic DSN setup as well as the port if it is in
    // in the configuration options. This will give us the basic DSN we will
    // need to establish the PDO connections and return them back for use.

    final host = config['host'] != null ? "host=${config['host']};" : '';
    var dsn = "pgsql:${host}dbname=${config['database']}";

    // If a port was specified, we will add it to this Postgres DSN connections
    // format. Once we have done that we are ready to return this connection
    // string back out for usage, as this has been fully constructed here.
    if (config['port'] != null) {
      dsn += ";port=${config['port']}";
    }

    if (config['sslmode'] != null) {
      dsn += ";sslmode=${config['sslmode']}";
    }

    // add charset to DSN
    if (config.containsKey('charset') && config['charset'] != null) {
      dsn = "$dsn;charset=${config['charset']}";
    }
    // add Pool opttions to DSN
    if (config['pool'] != null) {
      dsn += ";pool=${config['pool']}";
    }

    if (config['poolsize'] != null) {
      dsn += ";poolsize=${config['poolsize']}";
    }

    if (config['allowreconnect'] != null) {
      dsn += ";allowreconnect=${config['allowreconnect']}";
    }

    if (config['application_name'] != null) {
      dsn += ";application_name=${config['application_name']}";
    }

    if (config['schema'] != null) {
      dsn += ";schema=${formatSchema(config['schema'])}";
    }

    if (config['timezone'] != null) {
      dsn += ";timezone=${config['timezone']}";
    }

    return dsn;
  }

  ///
  /// Format the schema for the DSN.
  ///
  /// @param  array|string  $schema
  /// @return string
  ///
  String formatSchema(dynamic schema) {
    String result = '';
    if (schema is List<String>) {
      result = schema.map((e) => '"$e"').join(',');
    } else if (schema is String) {
      if (schema.contains(',')) {
        final parts = schema.split(',');
        result = parts.map((e) => '"$e"').join(',');
      } else {
        result = '"$schema"';
      }
    } else {
      throw Exception('schema is not String or List<String>');
    }
    return result;
  }

  ///
  /// Create a new PDO connection.
  ///
  /// @param  string  $dsn
  /// @param  array   $config
  /// @param  array   $options
  /// @return \PDO
  /// Aqui que cria a conexão com o Banco de Dados de fato
  ///
  Future<PDOInterface> createConnection(Map<String, dynamic> config) async {
    //print('postgres_connector@createConnection config: $config');

    if (config.containsKey('schema')) {
      config['schema'] = formatSchema(config['schema']);
    }
    final pdoConfig = PDOConfig.fromMap(config);
    late PDOInterface pdo;
    if (config['driver_implementation'] == 'postgres') {
      pdo = PostgresPDO(pdoConfig);
    } else if (config['driver_implementation'] == 'postgres_v3') {
      pdo = PostgresV3PDO(pdoConfig);
    } else if (config['driver_implementation'] == 'dargres') {
      pdo = DargresPDO(pdoConfig);
    } else {
      pdo = PostgresPDO(pdoConfig);
    }
    await pdo.connect();
    return pdo;
  }
}

// File: C:\MyDartProjects\eloquent\lib\src\container\container.dart
import 'package:eloquent/eloquent.dart';
import 'contextual_binding_builder.dart';

/// IoC Container,
class Container {
  //from method dynamic share(Closure $closure)
  static dynamic object;

  ///
  /// The current globally available container (if any).
  ///
  /// @var static
  ///
  static Container? instanceProp;

  ///
  /// An array of the types that have been resolved.
  ///
  /// @var array
  ///
  Map<String, dynamic> resolvedProp = {};

  ///
  /// The container's bindings.
  ///
  /// @var array
  ///
  Map<String, dynamic> bindings = {};

  ///
  /// The container's shared instances.
  ///
  /// @var array
  ///
  Map<String, dynamic> instances = {};

  ///
  /// The registered type aliases.
  ///
  /// @var array
  ///
  Map<String, dynamic> aliases = {};

  ///
  /// The extension closures for services.
  ///
  /// @var array
  ///
  Map<String, dynamic> extenders = {};

  ///
  /// All of the registered tags.
  ///
  /// @var array
  ///
  Map<String, dynamic> tags = {};

  ///
  /// The stack of concretions currently being built.
  ///
  /// @var array
  ///
  List buildStack = [];

  ///
  /// The contextual binding map.
  ///
  /// @var array
  ///
  Map contextual = {};

  ///
  /// All of the registered rebound callbacks.
  ///
  /// @var array
  ///
  Map reboundCallbacks = {};

  ///
  /// All of the global resolving callbacks.
  ///
  /// @var array
  ///
  List globalResolvingCallbacks = [];

  ///
  /// All of the global after resolving callbacks.
  ///
  /// @var array
  ///
  List globalAfterResolvingCallbacks = [];

  ///
  /// All of the resolving callbacks by class type.
  ///
  /// @var array
  ///
  List resolvingCallbacks = [];

  ///
  /// All of the after resolving callbacks by class type.
  ///
  /// @var array
  ///
  List afterResolvingCallbacks = [];

  ///
  /// Define a contextual binding.
  ///
  /// @param  string  $concrete
  /// @return \Illuminate\Contracts\Container\ContextualBindingBuilder
  ///
  ContextualBindingBuilder when(String concrete) {
    concrete = this.normalize(concrete);
    return ContextualBindingBuilder(this, concrete);
  }

  ///
  /// Determine if the given abstract type has been bound.
  ///
  /// @param  string  $abstract
  /// @return bool
  ///
  bool bound(dynamic abstractP) {
    var abstract = this.normalize(abstractP);

    return Utils.isset(this.bindings[abstract]) ||
        Utils.isset(this.instances[abstract]) ||
        this.isAlias(abstract);
  }

  ///
  /// Determine if the given abstract type has been resolved.
  ///
  /// @param  string  $abstract
  /// @return bool
  ///
  bool resolved(dynamic abstract) {
    abstract = this.normalize(abstract);

    if (this.isAlias(abstract)) {
      abstract = this.getAlias(abstract);
    }

    return Utils.isset(this.resolvedProp[abstract]) ||
        Utils.isset(this.instances[abstract]);
  }

  ///
  /// Determine if a given string is an alias.
  ///
  /// @param  string  $name
  /// @return bool
  ///
  bool isAlias(String name) {
    return Utils.isset(this.aliases[this.normalize(name)]);
  }

  ///
  /// Register a binding with the container.
  ///
  /// @param  string|array  $abstract
  /// @param  Function|String|null  $concrete
  /// @param  bool  $shared
  /// @return void
  ///
  void bind(abstract, [dynamic concrete, bool shared = false]) {
    //abstract = this.normalize(abstract);
    //concrete = this.normalize(concrete);

    // If the given types are actually an array, we will assume an alias is being
    // defined and will grab this "real" abstract class name and register this
    // alias with the container so that it can be used as a shortcut for it.
    if (Utils.is_map(abstract)) {
      var res = this.extractAlias(abstract);
      abstract = res.first;
      var alias = res.last;
      this.alias(abstract, alias);
    }

    // // If no concrete type was given, we will simply set the concrete type to the
    // // abstract type. After that, the concrete type to be registered as shared
    // // without being forced to state their classes in both of the parameters.
    this.dropStaleInstances(abstract);

    if (Utils.is_null(concrete)) {
      concrete = abstract;
    }

    // // If the factory is not a Closure, it means it is just a class name which is
    // // bound into this container to the abstract type and we will just wrap it
    // // up inside its own Closure to give us more convenience when extending.
    if (!(concrete is Function)) {
      concrete = this.getClosure(abstract, concrete);
    }

    this.bindings[abstract] = {'concrete': concrete, 'shared': shared};

    // // If the abstract type was already resolved in this container we'll fire the
    // // rebound listener so that any objects which have already gotten resolved
    // // can have their copy of the object updated via the listener callbacks.
    if (this.resolved(abstract)) {
      this.rebound(abstract);
    }
  }

  ///
  /// Get the Closure to be used when building a type.
  ///
  /// @param  string  $abstract
  /// @param  string  $concrete
  /// @return \Closure
  ///
  Function getClosure(String abstract, String concrete) {
    return ($c, [parameters = const []]) {
      //var methodName = (abstract == concrete) ? 'build' : 'make';
      //return Utils.call_method($c, methodName, [concrete, parameters]);
      throw UnimplementedError();
      // return $c->$method(concrete, parameters);
    };
  }

  ///
  /// Add a contextual binding to the container.
  ///
  /// @param  string  $concrete
  /// @param  string  $abstract
  /// @param  \Closure|string  $implementation
  /// @return void
  ///
  void addContextualBinding(
      dynamic concrete, dynamic abstract, dynamic implementation) {
    this.contextual[this.normalize(concrete)][this.normalize(abstract)] =
        this.normalize(implementation);
  }

  ///
  /// Register a binding if it hasn't already been registered.
  ///
  /// @param  string  $abstract
  /// @param  \Closure|string|null  $concrete
  /// @param  bool  $shared
  /// @return void
  ///
  void bindIf(String abstract, [dynamic concrete, bool shared = false]) {
    if (!this.bound(abstract)) {
      this.bind(abstract, concrete, shared);
    }
  }

  ///
  /// Register a shared binding in the container.
  ///
  /// @param  string|array  $abstract
  /// @param  \Closure|string|null  $concrete
  /// @return void
  ///
  void singleton(dynamic abstract, [dynamic concrete]) {
    this.bind(abstract, concrete, true);
  }

  ///
  /// Wrap a Closure such that it is shared.
  ///
  /// @param  \Closure  $closure
  /// @return \Closure
  ///
  Function share(Function closure) {
    return (container) {
      // We'll simply declare a static variable within the Closures and if it has
      // not been set we will execute the given Closures to resolve this value
      // and return it back to these consumers of the method as an instance.

      if (Utils.is_null(object)) {
        object = closure(container);
      }

      return object;
    };
  }

  ///
  /// "Extend" an abstract type in the container.
  ///
  /// @param  string    $abstract
  /// @param  \Closure  $closure
  /// @return void
  ///
  /// @throws \InvalidArgumentException
  ///
  void extend(dynamic abstractP, Function closure) {
    var abstract = this.normalize(abstractP);

    if (Utils.isset(this.instances[abstract])) {
      this.instances[abstract] = closure(this.instances[abstract], this);
      this.rebound(abstract);
    } else {
      this.extenders[abstract] ?? [];
      this.extenders[abstract].add(closure);
    }
  }

  ///
  /// Register an existing instance as shared in the container.
  ///
  /// @param  string  $abstract
  /// @param  mixed   $instance
  /// @return void
  ///
  void instance(String abstractP, dynamic instanceP) {
    var abstract = this.normalize(abstractP);

    // First, we will extract the alias from the abstract if it is an array so we
    // are using the correct name when binding the type. If we get an alias it
    // will be registered with the container so we can resolve it out later.
    if (Utils.is_map(abstract)) {
      var res = this.extractAlias(abstract);
      abstract = res.first;
      var alias = res.last;

      this.alias(abstract, alias);
    }

    this.aliases.remove(abstract);

    // // We'll check to determine if this type has been bound before, and if it has
    // // we will fire the rebound callbacks registered with the container and it
    // // can be updated with consuming classes that have gotten resolved here.
    var bound = this.bound(abstract);

    this.instances[abstract] = instanceP;

    if (bound) {
      this.rebound(abstract);
    }
  }

  ///
  /// Assign a set of tags to a given binding.
  ///
  /// @param  array|string  $abstracts
  /// @param  array|mixed   ...$tags
  /// @return void
  ///
  void tag(List abstracts, List<String> tags) {
    //var tags = Utils.is_array(tags) ? tags : array_slice(func_get_args(), 1);

    for (var tag in tags) {
      if (!Utils.isset(this.tags[tag])) {
        this.tags[tag] = [];
      }

      for (var abstract in abstracts) {
        this.tags[tag].add(this.normalize(abstract));
      }
    }
  }

  ///
  /// Resolve all of the bindings for a given tag.
  ///
  /// @param  string  $tag
  /// @return array
  ///
  dynamic tagged(String tag) {
    var results = [];

    if (Utils.isset(this.tags[tag])) {
      for (var abstract in this.tags[tag]) {
        results.add(this.make(abstract));
      }
    }

    return results;
  }

  ///
  /// Alias a type to a different name.
  ///
  /// @param  string  $abstract
  /// @param  string  $alias
  /// @return void
  ///
  void alias(String abstract, String alias) {
    this.aliases[alias] = this.normalize(abstract);
  }

  ///
  /// Extract the type and alias from a given definition.
  ///
  /// @param  array  $definition
  /// @return array
  ///
  List extractAlias(Map<String, dynamic> definition) {
    //current($definition)
    return [definition.entries.first.key, definition.entries.first.value];
  }

  ///
  /// Bind a new callback to an abstract's rebind event.
  ///
  /// @param  string    $abstract
  /// @param  \Closure  $callback
  /// @return mixed
  ///
  dynamic rebinding(String abstract, Function callback) {
    var key = this.normalize(abstract);
    this.reboundCallbacks[key] ?? [];
    this.reboundCallbacks[key].add(callback);

    if (this.bound(abstract)) {
      return this.make(abstract);
    }
  }

  ///
  /// Refresh an instance on the given target and method.
  ///
  /// @param  string  $abstract
  /// @param  mixed   $target
  /// @param  string  $method
  /// @return mixed
  ///
  dynamic refresh(abstract, target, String methodName) {
    return this.rebinding(this.normalize(abstract), (app, instance) {
      // target->{$method}($instance);
      //Utils.call_method(target, methodName, [instance]);
      throw UnimplementedError();
    });
  }

  ///
  /// Fire the "rebound" callbacks for the given abstract type.
  ///
  /// @param  string  $abstract
  /// @return void
  ///
  void rebound(abstract) {
    var instance = this.make(abstract);

    for (var callback in this.getReboundCallbacks(abstract)) {
      callback(this, instance);
    }
  }

  ///
  /// Get the rebound callbacks for a given type.
  ///
  /// @param  string  $abstract
  /// @return array
  ///
  dynamic getReboundCallbacks(abstract) {
    if (Utils.isset(this.reboundCallbacks[abstract])) {
      return this.reboundCallbacks[abstract];
    }

    return [];
  }

  ///
  /// Wrap the given closure such that its dependencies will be injected when executed.
  ///
  /// @param  \Closure  $callback
  /// @param  array  $parameters
  /// @return \Closure
  ///
  Function wrap(Function callback, [List parameters = const []]) {
    return () {
      return this.call(callback, parameters);
    };
  }

  ///
  /// Call the given Closure / class@method and inject its dependencies.
  ///
  /// @param  callable|string  $callback
  /// @param  array  $parameters
  /// @param  string|null  $defaultMethod
  /// @return mixed
  ///
  dynamic call(dynamic callback,
      [parameters = const [], String? defaultMethod]) {
    if (this.isCallableWithAtSign(callback) || defaultMethod != null) {
      return this.callClass(callback, parameters, defaultMethod);
    }

    var dependencies = this.getMethodDependencies(callback, parameters);

    return callback(dependencies);
  }

  ///
  /// Determine if the given string is in Class@method syntax.
  ///
  /// @param  mixed  $callback
  /// @return bool
  ///
  bool isCallableWithAtSign(dynamic callback) {
    return Utils.is_string(callback) && Utils.strpos(callback, '@') != false;
  }

  ///
  /// Get all dependencies for a given method.
  ///
  /// @param  callable|string  $callback
  /// @param  array  $parameters
  /// @return array
  ///
  dynamic getMethodDependencies(dynamic callback, [parameters = const []]) {
    // var dependencies = [];

    // for (this.getCallReflector(callback)->getParameters() as $parameter) {
    //     this.addDependencyForCallParameter($parameter, $parameters, $dependencies);
    // }

    // return array_merge($dependencies, $parameters);
  }

  ///
  /// Get the proper reflection instance for the given callback.
  ///
  /// @param  callable|string  $callback
  /// @return \ReflectionFunctionAbstract
  ///
  dynamic getCallReflector($callback) {
    // if (is_string($callback) && strpos($callback, '::') !== false) {
    //     $callback = explode('::', $callback);
    // }

    // if (is_array($callback)) {
    //     return new ReflectionMethod($callback[0], $callback[1]);
    // }

    // return new ReflectionFunction($callback);
  }

  ///
  /// Call a string reference to a class using Class@method syntax.
  ///
  /// @param  string  $target
  /// @param  array  $parameters
  /// @param  string|null  $defaultMethod
  /// @return mixed
  ///
  /// @throws \InvalidArgumentException
  ///
  dynamic callClass($target, [$parameters = const [], String? defaultMethod]) {
    var segments = Utils.explode('@', $target);

    // If the listener has an @ sign, we will assume it is being used to delimit
    // the class name from the handle method name. This allows for handlers
    // to run multiple handler methods in a single class for convenience.
    var method = Utils.count(segments) == 2 ? segments[1] : defaultMethod;

    if (Utils.is_null(method)) {
      throw InvalidArgumentException('Method not provided.');
    }

    return this.call([this.make(segments[0]), method], $parameters);
  }

  ///
  /// Resolve the given type from the container.
  ///
  /// @param  string  $abstract
  /// @param  array   $parameters
  /// @return mixed
  ///
  dynamic make(abstract, [dynamic parameters]) {
    abstract = this.getAlias(this.normalize(abstract));

    // If an instance of the type is currently being managed as a singleton we'll
    // just return an existing instance instead of instantiating new instances
    // so the developer can keep using the same objects instance every time.
    if (Utils.isset(this.instances[abstract])) {
      return this.instances[abstract];
    }

    var concrete = this.getConcrete(abstract);

    var objectL;
    // We're ready to instantiate an instance of the concrete type registered for
    // the binding. This will instantiate the types, as well as resolve any of
    // its "nested" dependencies recursively until all have gotten resolved.
    if (this.isBuildable(concrete, abstract)) {
      objectL = this.build(concrete, parameters);
    } else {
      objectL = this.make(concrete, parameters);
    }

    // If we defined any extenders for this type, we'll need to spin through them
    // and apply them to the object being built. This allows for the extension
    // of services, such as changing configuration or decorating the object.
    for (var extender in this.getExtenders(abstract)) {
      objectL = extender(objectL, this);
    }

    // If the requested type is registered as a singleton we'll want to cache off
    // the instances in "memory" so we can return it later without creating an
    // entirely new instance of an object on each subsequent request for it.
    if (this.isShared(abstract)) {
      this.instances[abstract] = objectL;
    }

    this.fireResolvingCallbacks(abstract, objectL);

    this.resolvedProp[abstract] = true;

    return objectL;
  }

  ///
  /// Get the concrete type for a given abstract.
  ///
  /// @param  string  $abstract
  /// @return mixed   $concrete
  ///
  dynamic getConcrete(String abstract) {
    var concrete = this.getContextualConcrete(abstract);
    if (!Utils.is_null(concrete)) {
      return concrete;
    }

    // If we don't have a registered resolver or concrete for the type, we'll just
    // assume each type is a concrete name and will attempt to resolve it as is
    // since the container should be able to resolve concretes automatically.
    if (!Utils.isset(this.bindings[abstract])) {
      return abstract;
    }

    return this.bindings[abstract]['concrete'];
  }

  ///
  /// Get the contextual concrete binding for the given abstract.
  ///
  /// @param  string  $abstract
  /// @return string|null
  ///
  String? getContextualConcrete(String abstract) {
    if (this.contextual[Utils.array_end(this.buildStack)] != null &&
        Utils.isset(
            this.contextual[Utils.array_end(this.buildStack)][abstract])) {
      return this.contextual[Utils.array_end(this.buildStack)][abstract];
    }

    return null;
  }

  ///
  /// Normalize the given class name by removing leading slashes.
  ///
  /// @param  mixed  $service
  /// @return mixed
  ///
  dynamic normalize(service) {
    // remove Backslash start of string
    return Utils.is_string(service) ? Utils.ltrim(service, '\\\\') : service;
  }

  ///
  /// Get the extender callbacks for a given type.
  ///
  /// @param  string  $abstract
  /// @return array
  ///
  dynamic getExtenders(dynamic abstract) {
    if (Utils.isset(this.extenders[abstract])) {
      return this.extenders[abstract];
    }

    return [];
  }

  ///
  /// Instantiate a concrete instance of the given type.
  ///
  /// @param  string  $concrete
  /// @param  array   $parameters
  /// @return mixed
  ///
  /// @throws \Illuminate\Contracts\Container\BindingResolutionException
  ///
  dynamic build(dynamic concrete, [dynamic parameters]) {
    // If the concrete type is actually a Closure, we will just execute it and
    // hand back the results of the functions, which allows functions to be
    // used as resolvers for more fine-tuned resolution of these objects.
    if (concrete is Function) {
      return concrete(parameters);
    }

    //var reflector = new ReflectionClass(concrete);
    // var reflector = reflect(concrete);

    // If the type is not instantiable, the developer is attempting to resolve
    // an abstract type such as an Interface of Abstract Class and there is
    // no binding registered for the abstractions so we need to bail out.
    // if (! $reflector->isInstantiable()) {
    //     if (! empty($this->buildStack)) {
    //         $previous = implode(', ', this. buildStack);

    //         $message = "Target [$concrete] is not instantiable while building [$previous].";
    //     } else {
    //         $message = "Target [$concrete] is not instantiable.";
    //     }

    //     throw new BindingResolutionException($message);
    // }

    // this.buildStack.add(concrete);

    // var constructor = $reflector->getConstructor();

    // // If there are no constructors, that means there are no dependencies then
    // // we can just resolve the instances of the objects right away, without
    // // resolving any other types or dependencies out of these containers.
    // if (Utils.is_null(constructor)) {
    //     Utils.array_pop(this.buildStack);

    //     return new $concrete;
    // }

    // $dependencies = $constructor->getParameters();

    // // Once we have all the constructor's parameters we can create each of the
    // // dependency instances and then use the reflection instances to make a
    // // new instance of this class, injecting the created dependencies in.
    // $parameters = this. keyParametersByArgument(
    //     $dependencies, $parameters
    // );

    // $instances = this. getDependencies(
    //     $dependencies, $parameters
    // );

    // array_pop($this->buildStack);

    // return $reflector->newInstanceArgs($instances);
  }

  ///
  /// Resolve all of the dependencies from the ReflectionParameters.
  ///
  /// @param  array  $parameters
  /// @param  array  $primitives
  /// @return array
  ///
  dynamic getDependencies(dynamic $parameters, [dynamic $primitives]) {
    // $dependencies = [];

    // foreach ($parameters as $parameter) {
    //     $dependency = $parameter->getClass();

    //     // If the class is null, it means the dependency is a string or some other
    //     // primitive type which we can not resolve since it is not a class and
    //     // we will just bomb out with an error since we have no-where to go.
    //     if (array_key_exists($parameter->name, $primitives)) {
    //         $dependencies[] = $primitives[$parameter->name];
    //     } elseif (is_null($dependency)) {
    //         $dependencies[] = this. resolveNonClass($parameter);
    //     } else {
    //         $dependencies[] = this. resolveClass($parameter);
    //     }
    // }

    // return $dependencies;
  }

  ///
  /// Resolve a non-class hinted dependency.
  ///
  /// @param  \ReflectionParameter  $parameter
  /// @return mixed
  ///
  /// @throws \Illuminate\Contracts\Container\BindingResolutionException
  ///
  dynamic resolveNonClass(dynamic $parameter) {
    // if (! is_null($concrete = this. getContextualConcrete('$'.$parameter->name))) {
    //     if ($concrete instanceof Closure) {
    //         return call_user_func($concrete, $this);
    //     } else {
    //         return $concrete;
    //     }
    // }

    // if ($parameter->isDefaultValueAvailable()) {
    //     return $parameter->getDefaultValue();
    // }

    // $message = "Unresolvable dependency resolving [$parameter] in class {$parameter->getDeclaringClass()->getName()}";

    // throw new BindingResolutionException($message);
  }

  ///
  /// Resolve a class based dependency from the container.
  ///
  /// @param  \ReflectionParameter  $parameter
  /// @return mixed
  ///
  /// @throws \Illuminate\Contracts\Container\BindingResolutionException
  ///
  dynamic resolveClass(dynamic $parameter) {
    // try {
    //     return this. make($parameter->getClass()->name);
    // }

    // // If we can not resolve the class instance, we will check to see if the value
    // // is optional, and if it is we will return the optional parameter value as
    // // the value of the dependency, similarly to how we do this with scalars.
    // catch (BindingResolutionException $e) {
    //     if ($parameter->isOptional()) {
    //         return $parameter->getDefaultValue();
    //     }

    //     throw $e;
    // }
  }

  ///
  /// If extra parameters are passed by numeric ID, rekey them by argument name.
  ///
  /// @param  array  $dependencies
  /// @param  array  $parameters
  /// @return array
  ///
  dynamic keyParametersByArgument(dynamic $dependencies, dynamic $parameters) {
    // foreach ($parameters as $key => $value) {
    //     if (is_numeric($key)) {
    //         unset($parameters[$key]);

    //         $parameters[$dependencies[$key]->name] = $value;
    //     }
    // }

    // return $parameters;
  }

  ///
  /// Register a new resolving callback.
  ///
  /// @param  string    $abstract
  /// @param  \Closure|null  $callback
  /// @return void
  ///
  dynamic resolving(abstract, [Function? callback]) {
    // if ($callback == null && $abstract instanceof Closure) {
    //     this. resolvingCallback($abstract);
    // } else {
    //     this. resolvingCallbacks[$this->normalize($abstract)][] = $callback;
    // }
  }

  ///
  /// Register a new after resolving callback for all types.
  ///
  /// @param  string   $abstract
  /// @param  \Closure|null $callback
  /// @return void
  ///
  dynamic afterResolving(abstract, [Function? callback]) {
    // if ($abstract instanceof Closure && $callback === null) {
    //     this. afterResolvingCallback($abstract);
    // } else {
    //     this. afterResolvingCallbacks[$this->normalize($abstract)][] = $callback;
    // }
  }

  ///
  /// Register a new resolving callback by type of its first argument.
  ///
  /// @param  \Closure  $callback
  /// @return void
  ///
  void resolvingCallback(Function $callback) {
    // $abstract = this. getFunctionHint($callback);

    // if ($abstract) {
    //     this. resolvingCallbacks[$abstract][] = $callback;
    // } else {
    //     this. globalResolvingCallbacks[] = $callback;
    // }
  }

  ///
  /// Register a new after resolving callback by type of its first argument.
  ///
  /// @param  \Closure  $callback
  /// @return void
  ///
  dynamic afterResolvingCallback(Function $callback) {
    // $abstract = this. getFunctionHint($callback);

    // if ($abstract) {
    //     this. afterResolvingCallbacks[$abstract][] = $callback;
    // } else {
    //     this. globalAfterResolvingCallbacks[] = $callback;
    // }
  }

  ///
  /// Get the type hint for this closure's first argument.
  ///
  /// @param  \Closure  $callback
  /// @return mixed
  ///
  dynamic getFunctionHint(Function $callback) {
    // $function = new ReflectionFunction($callback);

    // if ($function->getNumberOfParameters() == 0) {
    //     return;
    // }

    // $expected = $function->getParameters()[0];

    // if (! $expected->getClass()) {
    //     return;
    // }

    // return $expected->getClass()->name;
  }

  ///
  /// Fire all of the resolving callbacks.
  ///
  /// @param  string  $abstract
  /// @param  mixed   $object
  /// @return void
  ///
  dynamic fireResolvingCallbacks($abstract, $object) {
    // this. fireCallbackArray($object, this. globalResolvingCallbacks);

    // this. fireCallbackArray(
    //     $object, this. getCallbacksForType(
    //         $abstract, $object, this. resolvingCallbacks
    //     )
    // );

    // this. fireCallbackArray($object, this. globalAfterResolvingCallbacks);

    // this. fireCallbackArray(
    //     $object, this. getCallbacksForType(
    //         $abstract, $object, this. afterResolvingCallbacks
    //     )
    // );
  }

  ///
  /// Get all callbacks for a given type.
  ///
  /// @param  string  $abstract
  /// @param  object  $object
  /// @param  array   $callbacksPerType
  ///
  /// @return array
  ///
  dynamic getCallbacksForType($abstract, $object, dynamic $callbacksPerType) {
    // $results = [];

    // foreach ($callbacksPerType as $type => $callbacks) {
    //     if ($type === $abstract || $object instanceof $type) {
    //         $results = array_merge($results, $callbacks);
    //     }
    // }

    // return $results;
  }

  ///
  /// Fire an array of callbacks with an object.
  ///
  /// @param  mixed  $object
  /// @param  array  $callbacks
  /// @return void
  ///
  dynamic fireCallbackArray($object, $callbacks) {
    // foreach ($callbacks as $callback) {
    //     $callback($object, $this);
    // }
  }

  ///
  /// Determine if a given type is shared.
  ///
  /// @param  string  $abstract
  /// @return bool
  ///
  bool isShared(abstract) {
    abstract = this.normalize(abstract);

    if (this.instances[abstract] != null) {
      return true;
    }

    if (!Utils.isset(this.bindings[abstract]['shared'])) {
      return false;
    }

    return this.bindings[abstract]['shared'] == true;
  }

  ///
  /// Determine if the given concrete is buildable.
  ///
  /// @param  mixed   $concrete
  /// @param  string  $abstract
  /// @return bool
  ///
  bool isBuildable(concrete, abstract) {
    return concrete == abstract || concrete is Function;
  }

  ///
  /// Get the alias for an abstract if available.
  ///
  /// @param  string  $abstract
  /// @return string
  ///
  dynamic getAlias(abstract) {
    if (!Utils.isset(this.aliases[abstract])) {
      return abstract;
    }

    return this.getAlias(this.aliases[abstract]);
  }

  ///
  /// Get the container's bindings.
  ///
  /// @return array
  ///
  dynamic getBindings() {
    return this.bindings;
  }

  ///
  /// Drop all of the stale instances and aliases.
  ///
  /// @param  string  $abstract
  /// @return void
  ///
  void dropStaleInstances(abstract) {
    this.instances.remove(abstract);
    this.aliases.remove(abstract);
    // unset(this.instances[abstract], this.aliases[abstract]);
  }

  ///
  /// Remove a resolved instance from the instance cache.
  ///
  /// @param  string  $abstract
  /// @return void
  ///
  dynamic forgetInstance(abstract) {
    //unset(this.instances[this.normalize(abstract)]);

    this.instances.remove(this.normalize(abstract));
  }

  ///
  /// Clear all of the instances from the container.
  ///
  /// @return void
  ///
  dynamic forgetInstances() {
    this.instances = {};
  }

  ///
  /// Flush the container of all bindings and resolved instances.
  ///
  /// @return void
  ///
  dynamic flush() {
    this.aliases = {};
    this.resolvedProp = {};
    this.bindings = {};
    this.instances = {};
  }

  ///
  /// Set the globally available instance of the container.
  ///
  /// @return static
  ///
  dynamic getInstance() {
    return Container.instanceProp;
  }

  ///
  /// Set the shared instance of the container.
  ///
  /// @param  \Illuminate\Contracts\Container\Container  $container
  /// @return void
  ///
  dynamic setInstance(Container container) {
    Container.instanceProp = container;
  }

  ///
  /// Determine if a given offset exists.
  ///
  /// @param  string  $key
  /// @return bool
  ///
  bool offsetExists(String key) {
    return this.bound(key);
  }

  ///
  /// Get the value at a given offset.
  ///
  /// @param  string  $key
  /// @return mixed
  ///
  dynamic offsetGet(String key) {
    return this.make(key);
  }

  ///
  /// Set the value at a given offset.
  ///
  /// @param  string  $key
  /// @param  mixed   $value
  /// @return void
  ///
  void offsetSet(String key, dynamic value) {
    // If the value is not a Closure, we will make it one. This simply gives
    // more "drop-in" replacement functionality for the Pimple which this
    // container's simplest functions are base modeled and built after.
    if (!value is Function) {
      value = () {
        return value;
      };
    }

    this.bind(key, value);
  }

  operator [](String key) => offsetGet(key); // get
  operator []=(String key, dynamic value) => offsetSet(key, value); // set

  ///
  /// Unset the value at a given offset.
  ///
  /// @param  string  $key
  /// @return void
  ///
  void offsetUnset(String key) {
    key = this.normalize(key);
    this.bindings.remove(key);
    this.instances.remove(key);
    this.resolvedProp.remove(key);
    //unset($this->bindings[$key], $this->instances[$key], $this->resolved[$key]);
  }

  /**
     * Dynamically access container services.
     *
     * @param  string  $key
     * @return mixed
     */
  //  dynamic __get($key)
  //   {
  //       return $this[$key];
  //   }

  /**
     * Dynamically set container services.
     *
     * @param  string  $key
     * @param  mixed   $value
     * @return void
     */
  // dynamic __set($key, $value)
  // {
  //     $this[$key] = $value;
  // }
}

// File: C:\MyDartProjects\eloquent\lib\src\container\contextual_binding_builder.dart
import 'container.dart';

class ContextualBindingBuilder {
/**
     * The underlying container instance.
     *
     * @var \Illuminate\Container\Container
     */
  Container container;

  /**
     * The concrete instance.
     *
     * @var string
     */
  String? concrete;

  /**
     * The abstract target.
     *
     * @var string
     */
  String? needsProp;

  /**
     * Create a new contextual binding builder.
     *
     * @param  \Illuminate\Container\Container  $container
     * @param  string  $concrete
     * @return void
     */
  ContextualBindingBuilder(this.container, this.concrete);

  /**
     * Define the abstract target that depends on the context.
     *
     * @param  string  $abstract
     * @return $this
     */
  ContextualBindingBuilder needs(String abstract) {
    this.needsProp = abstract;
    return this;
  }

  /**
     * Define the implementation for the contextual binding.
     *
     * @param  \Closure|string  $implementation
     * @return void
     */
  void give(dynamic implementation) {
    this
        .container
        .addContextualBinding(this.concrete, this.needs, implementation);
  }
}

// File: C:\MyDartProjects\eloquent\lib\src\database_manager.dart
import 'package:eloquent/eloquent.dart';

import 'container/container.dart';

class DatabaseManager implements ConnectionResolverInterface {
  ///
  /// The application instance.
  ///
  /// @var \Illuminate\Foundation\Application
  ///
  Container app;

  ///
  /// The database connection factory instance.
  ///
  /// @var \Illuminate\Database\Connectors\ConnectionFactory
  ///
  ConnectionFactory factory;

  ///
  /// The active connection instances.
  ///
  /// @var array
  ///
  Map<String, dynamic> connectionsProp = {};

  ///
  /// The custom connection resolvers.
  ///
  /// @var array
  ///
  Map<String, dynamic> extensions = {};

  ///
  /// Create a new database manager instance.
  ///
  /// @param  \Illuminate\Foundation\Application  $app
  /// @param  \Illuminate\Database\Connectors\ConnectionFactory  $factory
  /// @return void
  ///
  DatabaseManager(this.app, this.factory);

  ///
  /// Get a database connection instance.
  ///
  /// @param  string  $name
  /// @return \Illuminate\Database\Connection
  ///
  Future<Connection> connection([String? nameP]) async {
    var re = this.parseConnectionName(nameP);


    var name = re[0];
    var type = re[1];
    // If we haven't created this connection, we'll create it based on the config
    // provided in the application. Once we've created the connections we will
    // set the "fetch mode" for PDO which determines the query return types.

    if (!Utils.isset(this.connectionsProp[name])) {
      final connection = await this.makeConnection(name);

      this.setPdoForType(connection, type);

      this.connectionsProp[name] = this.prepare(connection);
    }

    return this.connectionsProp[name];
  }

  ///
  /// Parse the connection into an array of the name and read / write type.
  ///
  /// @param  string  $name
  /// @return array
  ///
  List parseConnectionName(String? name) {
    name = name ?? this.getDefaultConnection();

    return Utils.endsWith(name, ['::read', '::write'])
        ? Utils.explode('::', name, 2)
        : [name, null];
  }

  ///
  /// Disconnect from the given database and remove from local cache.
  ///
  /// [name] Connection name  
  /// @return void
  ///
  Future<void> purge([String? name]) async {
    await this.disconnect(name);
    this.connectionsProp.remove(name);    
  }

  ///
  /// Disconnect from the given database.
  ///
  /// @param  string  $name
  /// @return void
  ///
  Future<void> disconnect([String? name]) async {
    name = name ?? this.getDefaultConnection();
   
    if (Utils.isset(this.connectionsProp[name])) {
      await this.connectionsProp[name].disconnect();
    }
  }

  ///
  /// Reconnect to the given database.
  ///
  /// @param  string  $name
  /// @return \Illuminate\Database\Connection
  ///
  Future<Connection> reconnect([String? name]) {
    name = name ?? this.getDefaultConnection();
    this.disconnect(name);

    if (!Utils.isset(this.connectionsProp[name])) {
      return this.connection(name);
    }

    return this.refreshPdoConnections(name);
  }

  ///
  /// Refresh the PDO connections on a given connection.
  ///
  /// @param  string  $name
  /// @return \Illuminate\Database\Connection
  ///
  Future<Connection> refreshPdoConnections(String name) async {
    var fresh = await this.makeConnection(name);

    return this
        .connectionsProp[name]
        .setPdo(fresh.getPdo())
        .setReadPdo(fresh.getReadPdo());
  }

  ///
  /// Make the database connection instance.
  ///
  /// @param  string  $name
  /// @return \Illuminate\Database\Connection
  ///
  Future<Connection> makeConnection(String name) {
    var config = this.getConfig(name);

    // First we will check by the connection name to see if an extension has been
    // registered specifically for that connection. If it has we will call the
    // Closure and pass it the config allowing it to resolve the connection.
    if (Utils.isset(this.extensions[name])) {
      return this.extensions[name](config, name);
    }

    var driver = config['driver'];

    // Next we will check to see if an extension has been registered for a driver
    // and will call the Closure if so, which allows us to have a more generic
    // resolver for the drivers themselves which applies to all connections.
    if (Utils.isset(this.extensions[driver])) {
      //return call_user_func($this->extensions[$driver], $config, $name);
      return this.extensions[name](config, name);
    }

    return this.factory.make(config, name);
  }

  ///
  /// Prepare the database connection instance.
  ///
  /// @param  \Illuminate\Database\Connection  $connection
  /// @return \Illuminate\Database\Connection
  ///
  Connection prepare(Connection connection) {
    if (this.app.bound('events')) {
      connection.setEventDispatcher(this.app['events']);
    }

    // Here we'll set a reconnector callback. This reconnector can be any callable
    // so we will set a Closure to reconnect from this manager with the name of
    // the connection, which will allow us to reconnect from the connections.
    connection.setReconnector((con) async {
      await this.reconnect(con.getName());
    });

    return connection;
  }

  ///
  /// Prepare the read write mode for database connection instance.
  ///
  /// @param  \Illuminate\Database\Connection  $connection
  /// @param  string  $type
  /// @return \Illuminate\Database\Connection
  ///
  ConnectionInterface setPdoForType(Connection connection, [String? type]) {
    if (type == 'read') {
      connection.setPdo(connection.getReadPdo());
    } else if (type == 'write') {
      connection.setReadPdo(connection.getPdo());
    }

    return connection;
  }

  ///
  /// Get the configuration for a connection.
  ///
  /// @param  string  $name
  /// @return array
  ///
  /// @throws \InvalidArgumentException
  ///
  Map<String, dynamic> getConfig(String? name) {
    name = name ?? this.getDefaultConnection();

    // To get the database connection configuration, we will just pull each of the
    // connection configurations and get the configurations for the given name.
    // If the configuration doesn't exist, we'll throw an exception and bail.
    var connections = this.app['config']['database.connections'];

    var config = Utils.array_get(connections, name);

    if (Utils.is_null(config)) {
      throw InvalidArgumentException("Database [$name] not configured.");
    }

    return config;
  }

  ///
  /// Get the default connection name.
  ///
  /// @return string
  ///
  String getDefaultConnection() {
    return this.app['config']['database.default'];
  }

  ///
  /// Set the default connection name.
  ///
  /// @param  string  $name
  /// @return void
  ///
  void setDefaultConnection(String name) {
    this.app['config']['database.default'] = name;
  }

  ///
  /// Get all of the support drivers.
  ///
  /// @return array
  ///
  List supportedDrivers() {
    return ['mysql', 'pgsql', 'sqlite', 'sqlsrv'];
  }

  ///
  /// Get all of the drivers that are actually available.
  ///
  /// @return array
  ///
  List availableDrivers() {
    //return array_intersect($this->supportedDrivers(), str_replace('dblib', 'sqlsrv', PDO::getAvailableDrivers()));
    return supportedDrivers();
  }

  ///
  /// Register an extension connection resolver.
  ///
  /// @param  string    $name
  /// @param  callable  $resolver
  /// @return void
  ///
  dynamic extend(String name, Function resolver) {
    this.extensions[name] = resolver;
  }

  ///
  /// Return all of the created connections.
  ///
  /// @return array
  ///
  dynamic getConnections() {
    return this.connectionsProp;
  }

  ///
  /// Dynamically pass methods to the default connection.
  ///
  /// @param  string  $method
  /// @param  array   $parameters
  /// @return mixed
  ///
  dynamic call(String method, List parameters) {
    //return call_user_func_array([$this->connection(), $method], $parameters);
  }
}

// File: C:\MyDartProjects\eloquent\lib\src\detects_lost_connections.dart
import '../eloquent.dart';

mixin DetectsLostConnections {
  ///
  /// Determine if the given exception was caused by a lost connection.
  ///
  /// @param  \Exception  $e
  /// @return bool
  ///
  bool causedByLostConnection(dynamic e) {
    final message = '$e';
    //TODO revise isso para outros cenários
    final isR = Utils.string_contains(message, [
      '57P',//for posgresql restart
       "Can't create a connection",
       'Connection is closed',  
       'connection is not open',
    ]);
    
    return isR;
  }
}

// File: C:\MyDartProjects\eloquent\lib\src\exceptions\invalid_argument_exception.dart
import 'package:eloquent/eloquent.dart';

class InvalidArgumentException implements LogicException {
  String cause;
  InvalidArgumentException([this.cause = 'InvalidArgumentException']);
}

// File: C:\MyDartProjects\eloquent\lib\src\exceptions\logic_exception.dart
class LogicException implements Exception {
  String cause;
  LogicException([this.cause = 'LogicException']);
}

// File: C:\MyDartProjects\eloquent\lib\src\exceptions\query_exception.dart
class QueryException implements Exception {
  String sql;
  dynamic bindings;
  dynamic previous;
  QueryException([
    this.sql = 'QueryException',
    this.bindings,
    this.previous,
  ]);
}

// File: C:\MyDartProjects\eloquent\lib\src\grammar.dart
import 'package:eloquent/eloquent.dart';

/// base_query_grammar.dart BaseGrammar
abstract class BaseGrammar {
  ///
  /// The grammar table prefix.
  ///
  /// @var string
  ///
  String tablePrefix = '';

  ///
  /// Wrap an array of values.
  ///
  /// @param  array  $values
  /// @return array
  ///
  List wrapArray(List values) {
    return Utils.array_map(wrap, values);
  }

  ///
  /// Wrap a table in keyword identifiers.
  ///
  /// @param  string|\Illuminate\Database\Query\Expression  $table
  /// @return string
  ///
  String wrapTable(dynamic table) {
    if (isExpression(table)) {
      return getValue(table as QueryExpression);
    }

    return wrap(tablePrefix + table, true);
  }

  ///
  /// Wrap a value in keyword identifiers.
  ///
  /// @param  String |\Illuminate\Database\Query\Expression  $value
  /// @param  bool    $prefixAlias
  /// @return string
  ///
  String wrap(dynamic value, [bool prefixAlias = false]) {
    if (isExpression(value)) {
      return getValue(value);
    }

    // If the value being wrapped has a column alias we will need to separate out
    // the pieces so we can wrap each of the segments of the expression on it
    // own, and then joins them both back together with the "as" connector.
    if (Utils.strpos(Utils.strtolower(value), ' as ') != false) {
      var segments = Utils.explode(' ', value);

      if (prefixAlias) {
        segments[2] = tablePrefix + segments[2];
      }

      return wrap(segments[0]) + ' as ' + wrapValue(segments[2]);
    }

    var wrapped = [];

    var segments = Utils.explode('.', value);

    // If the value is not an aliased table expression, we'll just wrap it like
    // normal, so if there is more than one segment, we will wrap the first
    // segments as if it was a table and the rest as just regular values.
    for (var key = 0; key < segments.length; key++) {
      var segment = segments[key];
      if (key == 0 && Utils.count(segments) > 1) {
        wrapped.add(wrapTable(segment));
      } else {
        wrapped.add(wrapValue(segment));
      }
    }

    return Utils.implode('.', wrapped);
  }

  ///
  /// Wrap a single string in keyword identifiers.
  ///
  /// @param  string  $value
  /// @return string
  ///
  String wrapValue(String value) {
    if (value == '*') {
      return value;
    }

    return '"' + Utils.str_replace('"', '""', value) + '"';
  }

  ///
  /// Convert an array of column names into a delimited string.
  ///
  /// [columns] List<dynamic> | List<String> | List<QueryExpression>
  /// @return string
  ///
  String columnize(List<dynamic> columns) {
    return Utils.implode(', ', Utils.array_map(wrap, columns));
  }

  ///
  /// Create query parameter place-holders for an array.
  ///
  /// @param  array   $values
  /// @return string
  ///
  String parameterize(List values) {
    return Utils.implode(', ', Utils.array_map(parameter, values));
  }

  ///
  /// Get the appropriate query parameter place-holder for a value.
  ///
  /// @param  mixed   $value
  /// @return string
  ///
  String parameter(dynamic value) {
    return isExpression(value) ? getValue(value) : '?';
  }

  ///
  /// Get the value of a raw expression.
  ///
  /// [expression]  \Illuminate\Database\Query\Expression
  ///  Return `String`
  ///
  String getValue(QueryExpression expression) {
    return expression.getValue();
  }

  ///
  /// Determine if the given value is a raw expression.
  ///
  /// @param  mixed  $value
  /// @return bool
  ///
  bool isExpression(dynamic value) {
    return value is QueryExpression;
  }

  ///
  /// Get the format for database stored dates.
  ///
  /// @return string
  ///
  String getDateFormat() {
    // return 'Y-m-d H:i:s';
    return 'yyyy-MM-dd HH:mm:ss';
  }

  ///
  /// Get the grammar's table prefix.
  ///
  /// @return string
  ///
  String getTablePrefix() {
    return tablePrefix;
  }

  ///
  /// Set the grammar's table prefix.
  ///
  /// @param  string  $prefix
  /// @return $this
  ///
  dynamic setTablePrefix(String prefix) {
    tablePrefix = prefix;

    return this;
  }
}

// File: C:\MyDartProjects\eloquent\lib\src\mysql_connection.dart
import 'package:eloquent/eloquent.dart';
import 'package:eloquent/src/query/processors/mysql_processor.dart';

import 'query/grammars/query_mysql_grammar.dart';
import 'schema/grammars/schema_mysql_grammar.dart';

class MySqlConnection extends Connection {
  MySqlConnection(PDOExecutionContext pdoP,
      [String databaseP = '',
      String tablePrefixP = '',
      Map<String, dynamic> configP = const {}])
      : super(pdoP, databaseP, tablePrefixP, configP);

 
  /// Execute a Closure within a transaction.
  ///
  /// @param  Function  callback
  /// @return mixed
  ///
  /// @throws \Throwable
  Future<dynamic> transaction(Future<dynamic> Function(Connection ctx) callback,
      [int? timeoutInSeconds]) async {
    var result = this.pdo.pdoInstance.runInTransaction((pdoCtx) {
      final newConnection = MySqlConnection(pdoCtx, this.getDatabaseName(),
          this.getTablePrefix(), this.getConfigs());
      return callback(newConnection);
    });

    return result;
  }

  ///
  /// Get the default query grammar instance.
  ///
  /// @return \Illuminate\Database\Query\Grammars\QueryMySqlGrammar
  ///
  QueryGrammar getDefaultQueryGrammar() {  
    return withTablePrefix(QueryMySqlGrammar());
  }

  ///
  /// Get the default schema grammar instance.
  ///
  /// @return \Illuminate\Database\Schema\Grammars\SchemaMySqlGrammar
  ///
  SchemaGrammar getDefaultSchemaGrammar() {
    return this.withTablePrefix(SchemaMySqlGrammar());
  }

  ///
  /// Get the default post processor instance.
  ///
  /// @return \Illuminate\Database\Query\Processors\MySqlProcessor
  ///
  MySqlProcessor getDefaultPostProcessor() {
    return MySqlProcessor();
  }

  ///
  /// Get the Doctrine DBAL driver.
  ///
  /// @return \Doctrine\DBAL\Driver\PDOPgSql\Driver
  ///
  // dynamic getDoctrineDriver()
  // {
  //     return new DoctrineDriver;
  // }
}

// File: C:\MyDartProjects\eloquent\lib\src\pdo\core\constants.dart
const PDO_MYSQL_ATTR_SSL_VERIFY_SERVER_CERT = 1014; //false;
const PDO_MYSQL_ATTR_SSL_KEY = 1007; //'/certs/client-key.pem';
const PDO_MYSQL_ATTR_SSL_CERT = 1008; //'/certs/client-cert.pem';
const PDO_MYSQL_ATTR_SSL_CA = 1009; //'/certs/ca.pem';

// File: C:\MyDartProjects\eloquent\lib\src\pdo\core\pdo_config.dart
class PDOConfig {
  final String driver;
  final String host;
  final int port;
  final String database;
  final String? username;
  final String? password;
  final bool? isUnixSocket;
  /// win1252 | utf8 | utf8mb4_general_ci
  final String? charset;

  /// enable pool ?
  final bool? pool;
  final int? poolSize;
  String? applicationName;
  final bool? allowReconnect;

  /// require | disable
  String? sslmode;
  /// UTC | America/Sao_Paulo
  String? timezone;
  String? schema;

  /// If true, decodes the timestamp with timezone (timestamptz) as UTC.
  /// If false, decodes the timestamp with timezone using the timezone defined in the connection.
  bool forceDecodeTimestamptzAsUTC = true;

  /// If true, decodes the timestamp without timezone (timestamp) as UTC.
  /// If false, decodes the timestamp without timezone as local datetime.
  bool forceDecodeTimestampAsUTC = true;

  /// If true, decodes the date as UTC.
  /// If false, decodes the date as local datetime.
  bool forceDecodeDateAsUTC = true;

  PDOConfig({
    required this.driver,
    required this.host,
    this.port = 5432,
    required this.database,
    this.username,
    this.password,
    this.isUnixSocket = false,
    this.pool = false,
    this.poolSize = 1,
    this.applicationName,
    this.charset = 'utf8',
    this.allowReconnect,
    this.sslmode,
    this.timezone,
    this.schema,
    this.forceDecodeTimestamptzAsUTC = true,
    this.forceDecodeTimestampAsUTC = true,
    this.forceDecodeDateAsUTC = true,
  });

  Map<String, dynamic> toMap() {
    return <String, dynamic>{
      'driver': driver,
      'host': host,
      'port': port,
      'database': database,
      'username': username,
      'password': password,
      'isUnixSocket': isUnixSocket,
      'charset': charset,
      'pool': pool,
      'poolsize': poolSize,
      'applicationName': applicationName,
      'allowReconnect': allowReconnect,
      'sslmode': sslmode,
      'timezone': timezone,
      'schema': schema,
      'forceDecodeTimestamptzAsUTC': forceDecodeTimestamptzAsUTC,
      'forceDecodeTimestampAsUTC': forceDecodeTimestampAsUTC,
      'forceDecodeDateAsUTC': forceDecodeDateAsUTC,
    };
  }

  factory PDOConfig.fromMap(Map<String, dynamic> map) {
    final config = PDOConfig(
      driver: map['driver'],
      host: map['host'],
      port: map['port'] is int ? map['port'] : int.parse(map['port']),
      database: map['database'],
      username: map['username'],
      password: map['password'],
      isUnixSocket: map['is_unix_socket'],
      charset: map['charset'],
      pool: map['pool'],
      poolSize: map['poolsize'],
      applicationName: map['application_name'],
      allowReconnect: map['allowreconnect'],
      sslmode: map['sslmode'],
      timezone: map['timezone'],
      schema: map['schema'],
    );
    if (map['forceDecodeTimestamptzAsUTC'] is bool) {
      config.forceDecodeTimestamptzAsUTC = map['forceDecodeTimestamptzAsUTC'];
    }
    if (map['forceDecodeTimestampAsUTC'] is bool) {
      config.forceDecodeTimestampAsUTC = map['forceDecodeTimestampAsUTC'];
    }
    if (map['forceDecodeDateAsUTC'] is bool) {
      config.forceDecodeDateAsUTC = map['forceDecodeDateAsUTC'];
    }

    return config;
  }
}

// File: C:\MyDartProjects\eloquent\lib\src\pdo\core\pdo_execution_context.dart
import 'package:eloquent/src/pdo/core/pdo_interface.dart';
import 'pdo_result.dart';



abstract class PDOExecutionContext {
  late PDOInterface pdoInstance;

  /// Executa uma instrução SQL e retornar o número de linhas afetadas
  Future<int> execute(String statement, [int? timeoutInSeconds]);
  Future<PDOResults> query(String query,
      [dynamic params, int? timeoutInSeconds]);
}

// File: C:\MyDartProjects\eloquent\lib\src\pdo\core\pdo_interface.dart
import 'pdo_execution_context.dart';

/// PDO defines a lightweight, consistent interface for accessing databases
/// provides a data-access abstraction layer
abstract class PDOInterface extends PDOExecutionContext {
  Future<PDOInterface> connect();
  Future<T> runInTransaction<T>(Future<T> operation(PDOExecutionContext ctx),[int? timeoutInSeconds]);
  Future close();
}

// File: C:\MyDartProjects\eloquent\lib\src\pdo\core\pdo_result.dart
import 'dart:collection';

/// this is Result set of Rows from database
class PDOResults extends ListBase<Map<String, dynamic>> {
  final List<Map<String, dynamic>> rows;
  final int rowsAffected;

  PDOResults(this.rows, this.rowsAffected);

  int get length => rows.length;

  @override
  operator [](int index) {
    return rows[index];
  }

  @override
  void add(Map<String, dynamic> element) {
    rows.add(element);
  }

  @override
  void addAll(Iterable<Map<String, dynamic>> iterable) {
    rows.addAll(iterable);
  }

  @override
  void operator []=(int index, value) {
    rows[index] = value;
  }

  @override
  set length(int newLength) {
    UnimplementedError();
  }
}

// File: C:\MyDartProjects\eloquent\lib\src\pdo\dargres\dargres_pdo.dart
import 'package:dargres/dargres.dart' as dargres;
import 'package:eloquent/eloquent.dart';
import 'dargres_pdo_transaction.dart';

class DargresPDO extends PDOInterface {
  /// default query Timeout =  30 seconds
  static const defaultTimeout = const Duration(seconds: 30);

  PDOConfig config;

  /// Creates a PDO instance representing a connection to a database
  /// Example
  ///
  ///
  /// Example:  Map<String, dynamic> config = {'host': 'localhost','port':5432,'database':'teste'};
  /// var pdo = new PDO(PDOConfig.fromMap(config));
  /// await pdo.connect();
  ///
  DargresPDO(this.config) {
    super.pdoInstance = this;
  }

  /// CoreConnection
  dargres.ConnectionInterface? connection;

  //called from postgres_connector.dart
  Future<DargresPDO> connect() async {
    final timeZone = dargres.TimeZoneSettings(config.timezone ?? 'UTC');
    timeZone.forceDecodeTimestamptzAsUTC = config.forceDecodeTimestamptzAsUTC;
    timeZone.forceDecodeTimestampAsUTC = config.forceDecodeTimestampAsUTC;
    timeZone.forceDecodeDateAsUTC = config.forceDecodeDateAsUTC;

    if (config.pool == true) {
      final settings = dargres.ConnectionSettings(
        user: config.username ?? '',
        database: config.database,
        host: config.host,
        port: config.port,
        password: config.password,
        textCharset: config.charset ?? 'utf8',
        applicationName: config.applicationName,
        allowAttemptToReconnect: false,
        timeZone: timeZone,
      );
      connection = dargres.PostgreSqlPool(config.poolSize ?? 1, settings,
          allowAttemptToReconnect: config.allowReconnect ?? false);
    } else {
      connection = dargres.CoreConnection(config.username ?? '',
          database: config.database,
          host: config.host,
          port: config.port,
          password: config.password,
          allowAttemptToReconnect: false,
          // sslContext: sslContext,
          textCharset: config.charset ?? 'utf8',
          timeZone: timeZone);
      await connection!.connect();
    }

    return this;
  }

  Future<T> runInTransaction<T>(Future<T> operation(DargresPDOTransaction ctx),
      [int? timeoutInSeconds]) async {
    return connection!.runInTransaction((transaCtx) async {
      final pdoCtx = DargresPDOTransaction(transaCtx, this);
      return operation(pdoCtx);
    });
  }

  /// Executa uma instrução SQL e retornar o número de linhas afetadas
  Future<int> execute(String statement, [int? timeoutInSeconds]) {
    return connection!.execute(statement);
  }

  /// Prepares and executes an SQL statement
  Future<PDOResults> query(String query,
      [dynamic params, int? timeoutInSeconds]) async {
    final results = await connection!.queryNamed(query, params ?? [],
        placeholderIdentifier: dargres.PlaceholderIdentifier.onlyQuestionMark);
    final pdoResult = PDOResults(results.toMaps(), results.rowsAffected.value);
    return pdoResult;
  }

  @override
  Future close() async {
    await connection!.close();
  }
}

// File: C:\MyDartProjects\eloquent\lib\src\pdo\dargres\dargres_pdo_transaction.dart
import 'package:dargres/dargres.dart';
import 'package:eloquent/eloquent.dart';

class DargresPDOTransaction extends PDOExecutionContext {
  final TransactionContext transactionContext;

  DargresPDOTransaction(this.transactionContext, PDOInterface pdo) {
    super.pdoInstance = pdo;
  }

  Future<int> execute(String statement, [int? timeoutInSeconds]) {
    return transactionContext.execute(statement);
  }

  /// Prepares and executes an SQL statement without placeholders
  Future<PDOResults> query(String query, [dynamic params,int? timeoutInSeconds]) async {
    final results = await transactionContext.queryNamed(query, params ?? [],
        placeholderIdentifier: PlaceholderIdentifier.onlyQuestionMark);
    final pdoResult = PDOResults(results.toMaps(), results.rowsAffected.value);
    return pdoResult;
  }
}

// File: C:\MyDartProjects\eloquent\lib\src\pdo\mysql_client\mysql_client_pdo.dart
import 'package:eloquent/src/pdo/core/pdo_config.dart';
import 'package:eloquent/src/pdo/core/pdo_interface.dart';
import 'package:eloquent/src/pdo/core/pdo_result.dart';

import 'package:mysql_client/mysql_client.dart';
import 'mysql_client_pdo_transaction.dart';

class MySqlClientPDO extends PDOInterface {
  /// default query Timeout =  30 seconds
  static const defaultTimeoutInSeconds = 30;

  PDOConfig config;

  /// Creates a PDO instance representing a connection to a database
  /// Example
  ///
  ///
  /// Example:  Map<String, dynamic> config = {'host': 'localhost','port':5432,'database':'teste'};
  /// var pdo = new PDO(PDOConfig.fromMap(config));
  /// await pdo.connect();
  ///
  MySqlClientPDO(this.config) {
    super.pdoInstance = this;
  }

  /// CoreConnection
  late dynamic connection;

  //called from postgres_connector.dart
  Future<MySqlClientPDO> connect() async {
    if (config.pool == true) {
      connection = MySQLConnectionPool(
        host: config.host,
        port: config.port,
        databaseName: config.database,
        userName: config.username ?? '',
        password: config.password,
        collation: config.charset ?? 'utf8mb4_general_ci',
        maxConnections: config.poolSize ?? 1,
        secure: config.sslmode?.toString() == 'require',
      );
    } else {
      connection = await MySQLConnection.createConnection(
        host: config.host,
        port: config.port,
        databaseName: config.database,
        userName: config.username ?? '',
        password: config.password ?? '',
        collation: config.charset ?? 'utf8mb4_general_ci',
        secure: config.sslmode?.toString() == 'require',
      );
    }
    if (connection is MySQLConnection) {
      await (connection as MySQLConnection).connect();
    }

    return this;
  }

  Future<T> runInTransaction<T>(
      Future<T> operation(MySqlClientPDOTransaction ctx),
      [int? timeoutInSeconds]) async {
    if (timeoutInSeconds == null) {
      timeoutInSeconds = defaultTimeoutInSeconds;
    }

    if (connection is MySQLConnectionPool) {
      final res = await (connection as MySQLConnectionPool)
          .transactional((transaCtx) async {
        final pdoCtx = MySqlClientPDOTransaction(transaCtx, this);
        return operation(pdoCtx);
      });
      return res;
    }

    final res =
        await (connection as MySQLConnection).transactional((transaCtx) async {
      final pdoCtx = MySqlClientPDOTransaction(transaCtx, this);
      return operation(pdoCtx);
    });
    return res;
  }

  /// Executa uma instrução SQL e retornar o número de linhas afetadas
  Future<int> execute(String statement, [int? timeoutInSeconds]) async {
    if (timeoutInSeconds == null) {
      timeoutInSeconds = defaultTimeoutInSeconds;
    }

    if (connection is MySQLConnectionPool) {
      final result =
          await (connection as MySQLConnectionPool).execute(statement);
      return result.affectedRows.toInt();
    }

    final result = await (connection as MySQLConnection).execute(statement);
    return result.affectedRows.toInt();
  }

  /// Prepares and executes an SQL statement
  /// [params] List<dynamic>
  Future<PDOResults> query(String query,
      [dynamic params, int? timeoutInSeconds]) async {
    if (timeoutInSeconds == null) {
      timeoutInSeconds = defaultTimeoutInSeconds;
    }

    if (connection is MySQLConnectionPool) {
      final stmt = await (connection as MySQLConnectionPool).prepare(query);
      //.timeout(timeoutInSeconds);
      final result = await stmt.execute(params ?? []);
      await stmt.deallocate();
      final rows = result.rows.map((row) => row.typedAssoc()).toList();
      final pdoResult = PDOResults(rows, result.affectedRows.toInt());
      return pdoResult;
    }

    final stmt = await (connection as MySQLConnection).prepare(query);
    final result = await stmt.execute(params ?? []);
    await stmt.deallocate();
    final rows = result.rows.map((row) => row.typedAssoc()).toList();
    final pdoResult = PDOResults(rows, result.affectedRows.toInt());
    return pdoResult;
  }

  @override
  Future close() async {
    if (connection is MySQLConnectionPool) {
      await (connection as MySQLConnectionPool).close();
    }
    if (connection is MySQLConnection) {
      await (connection as MySQLConnection).close();
    }
  }
}

// File: C:\MyDartProjects\eloquent\lib\src\pdo\mysql_client\mysql_client_pdo_transaction.dart

import 'package:eloquent/src/pdo/core/pdo_execution_context.dart';
import 'package:eloquent/src/pdo/core/pdo_interface.dart';
import 'package:eloquent/src/pdo/core/pdo_result.dart';
import 'package:mysql_client/mysql_client.dart';
import 'mysql_client_pdo.dart';

class MySqlClientPDOTransaction extends PDOExecutionContext {
  final MySQLConnection transactionContext;

  MySqlClientPDOTransaction(this.transactionContext, PDOInterface pdo) {
    super.pdoInstance = pdo;
  }

  Future<int> execute(String statement, [int? timeoutInSeconds]) async {
    if (timeoutInSeconds == null) {
      timeoutInSeconds = MySqlClientPDO.defaultTimeoutInSeconds;
    }
    final result = await transactionContext.execute(statement);
    return result.affectedRows.toInt();
  }

  /// Prepares and executes an SQL statement without placeholders
  Future<PDOResults> query(String query,
      [dynamic params, int? timeoutInSeconds]) async {
    if (timeoutInSeconds == null) {
      timeoutInSeconds = MySqlClientPDO.defaultTimeoutInSeconds;
    }

    final stmt = await transactionContext.prepare(query);
    final result = await stmt.execute(params ?? []); //.timeout(timeoutInSeconds);
    await stmt.deallocate();
    final rows = result.rows.map((row) => row.typedAssoc()).toList();
    final pdoResult = PDOResults(rows, result.affectedRows.toInt());
    return pdoResult;
  }
}

// File: C:\MyDartProjects\eloquent\lib\src\pdo\postgres\dependencies\executor\executor.dart
library executor;

import 'dart:async';
import 'dart:collection';

import 'package:eloquent/src/pdo/postgres/dependencies/stack_trace/stack_trace.dart';

/// An async task that completes with a Future or a value.
typedef AsyncTask<R> = FutureOr<R>? Function();

/// An async task that completes after the Stream is closed.
typedef StreamTask<R> = Stream<R>? Function();

/// No more than [maximum] tasks can be started over any given [period].
class Rate {
  /// The maximum number of tasks to start in any given [period].
  final int maximum;

  /// The period of the [Rate], in which [maximum] tasks can be started.
  final Duration period;

  /// Creates a rate limit.
  const Rate(this.maximum, this.period);

  /// Creates a rate limit per second.
  factory Rate.perSecond(int maximum) => Rate(maximum, Duration(seconds: 1));

  /// Creates a rate limit per minute.
  factory Rate.perMinute(int maximum) => Rate(maximum, Duration(minutes: 1));

  /// Creates a rate limit per hour.
  factory Rate.perHour(int maximum) => Rate(maximum, Duration(hours: 1));

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Rate &&
          runtimeType == other.runtimeType &&
          maximum == other.maximum &&
          period == other.period;

  @override
  int get hashCode => maximum.hashCode ^ period.hashCode;
}

/// Executes async tasks with a configurable maximum [concurrency] and [rate].
abstract class Executor {
  /// The maximum number of tasks running concurrently.
  int concurrency = 1;

  /// The maximum rate of how frequently tasks can be started.
  Rate? rate;

  /// Async task executor.
  factory Executor({
    int concurrency = 1,
    Rate? rate,
  }) =>
      _Executor(concurrency, rate);

  /// The number of tasks that are currently running.
  int get runningCount;

  /// The number of tasks that are currently waiting to be started.
  int get waitingCount;

  /// The total number of tasks scheduled ([runningCount] + [waitingCount]).
  int get scheduledCount;

  /// Schedules an async task and returns with a future that completes when the
  /// task is finished. Task may not get executed immediately.
  Future<R> scheduleTask<R>(AsyncTask<R> task);

  /// Schedules an async task and returns its stream. The task is considered
  /// running until the stream is closed.
  Stream<R> scheduleStream<R>(StreamTask<R> task);

  /// Returns a [Future] that completes when all currently running tasks
  /// complete.
  ///
  /// If [withWaiting] is set, it will include the waiting tasks too.
  Future<List<Object?>> join({bool withWaiting = false});

  /// Notifies the listeners about a state change in [Executor], for example:
  /// - one or more tasks have started
  /// - one or more tasks have completed
  ///
  /// Clients can use this to monitor [scheduledCount] and queue more tasks to
  /// ensure [Executor] is running on full capacity.
  Stream get onChange;

  /// Closes the executor and reject  tasks.
  Future close();
}

class _Executor implements Executor {
  int _concurrency;
  Rate? _rate;
  final ListQueue<_Item<Object?>> _waiting = ListQueue<_Item<Object?>>();
  final ListQueue<_Item<Object?>> _running = ListQueue<_Item<Object?>>();
  final ListQueue<DateTime> _started = ListQueue<DateTime>();
  final StreamController _onChangeController = StreamController.broadcast();
  bool _closing = false;
  Timer? _triggerTimer;

  _Executor(this._concurrency, this._rate) {
    assert(_concurrency > 0);
  }

  @override
  int get runningCount => _running.length;

  @override
  int get waitingCount => _waiting.length;

  @override
  int get scheduledCount => runningCount + waitingCount;

  bool get isClosing => _closing;

  @override
  int get concurrency => _concurrency;

  @override
  set concurrency(int value) {
    if (_concurrency == value) return;
    assert(value > 0);
    _concurrency = value;
    _trigger();
  }

  @override
  Rate? get rate => _rate;

  @override
  set rate(Rate? value) {
    if (_rate == value) return;
    _rate = value;
    _trigger();
  }

  @override
  Future<R> scheduleTask<R>(AsyncTask<R> task) async {
    if (isClosing) throw Exception('Executor doesn\'t accept  tasks.');
    final item = _Item<R?>();
    _waiting.add(item);
    _trigger();
    await item.trigger.future;
    if (isClosing) {
      item.result.completeError(
          TimeoutException('Executor is closing'), Trace.current(1));
    } else {
      try {
        final r = await task();
        item.result.complete(r);
      } catch (e, st) {
        final chain = Chain([Trace.from(st), Trace.current(1)]);
        item.result.completeError(e, chain);
      }
    }
    _running.remove(item);
    _trigger();
    item.done.complete();
    return await item.result.future
        // Nullable R is used to allow using catchError with null output, so
        // we must convert R? into R for the caller
        .then((v) => v as R);
  }

  @override
  Stream<R> scheduleStream<R>(StreamTask<R> task) {
    final streamController = StreamController<R>();
    StreamSubscription<R>? streamSubscription;
    final resourceCompleter = Completer();
    complete() {
      if (streamSubscription != null) {
        streamSubscription?.cancel();
        streamSubscription = null;
      }
      if (!resourceCompleter.isCompleted) {
        resourceCompleter.complete();
      }
      if (!streamController.isClosed) {
        streamController.close();
      }
    }

    completeWithError(e, st) {
      if (!streamController.isClosed) {
        streamController.addError(e as Object, st as StackTrace);
      }
      complete();
    }

    streamController
      ..onCancel = complete
      ..onPause = (() => streamSubscription?.pause())
      ..onResume = () => streamSubscription?.resume();
    scheduleTask(() {
      if (resourceCompleter.isCompleted) return null;
      try {
        final stream = task();
        if (stream == null) {
          complete();
          return null;
        }
        streamSubscription = stream.listen(streamController.add,
            onError: streamController.addError,
            onDone: complete,
            cancelOnError: true);
      } catch (e, st) {
        completeWithError(e, st);
      }
      return resourceCompleter.future;
    }).catchError(completeWithError);
    return streamController.stream;
  }

  @override
  Future<List<Object?>> join({bool withWaiting = false}) {
    final futures = <Future<Object?>>[];
    for (final item in _running) {
      futures.add(item.result.future.catchError((_) async => null));
    }
    if (withWaiting) {
      for (final item in _waiting) {
        futures.add(item.result.future.catchError((_) async => null));
      }
    }
    if (futures.isEmpty) return Future.value([]);
    return Future.wait(futures);
  }

  @override
  Stream get onChange => _onChangeController.stream;

  @override
  Future close() async {
    _closing = true;
    _trigger();
    await join(withWaiting: true);
    _triggerTimer?.cancel();
    await _onChangeController.close();
  }

  void _trigger() {
    _triggerTimer?.cancel();
    _triggerTimer = null;

    while (_running.length < _concurrency && _waiting.isNotEmpty) {
      final rate = _rate;
      if (rate != null) {
        final now = DateTime.now();
        final limitStart = now.subtract(rate.period);
        while (_started.isNotEmpty && _started.first.isBefore(limitStart)) {
          _started.removeFirst();
        }
        if (_started.isNotEmpty) {
          final gap = rate.period ~/ rate.maximum;
          final last = now.difference(_started.last);
          if (gap > last) {
            final diff = gap - last;
            _triggerTimer ??= Timer(diff, _trigger);
            return;
          }
        }
        _started.add(now);
      }

      final item = _waiting.removeFirst();
      _running.add(item);
      item.done.future.whenComplete(() {
        _trigger();
        if (!_closing &&
            _onChangeController.hasListener &&
            !_onChangeController.isClosed) {
          _onChangeController.add(null);
        }
      });
      item.trigger.complete();
    }
  }
}

class _Item<R> {
  final trigger = Completer();
  // Nullable R is used here so that we can return null during catchError
  final result = Completer<R?>();
  final done = Completer();
}

// File: C:\MyDartProjects\eloquent\lib\src\pdo\postgres\dependencies\path\path.dart


/// A comprehensive, cross-platform path manipulation library.
///
/// The path library was designed to be imported with a prefix, though you don't
/// have to if you don't want to:
///
///     import 'package:path/path.dart' as p;
///
/// The most common way to use the library is through the top-level functions.
/// These manipulate path strings based on your current working directory and
/// the path style (POSIX, Windows, or URLs) of the host platform. For example:
///
///     p.join('directory', 'file.txt');
///
/// This calls the top-level [join] function to join "directory" and "file.txt"
/// using the current platform's directory separator.
///
/// If you want to work with paths for a specific platform regardless of the
/// underlying platform that the program is running on, you can create a
/// [Context] and give it an explicit [Style]:
///
///     var context = p.Context(style: Style.windows);
///     context.join('directory', 'file.txt');
///
/// This will join "directory" and "file.txt" using the Windows path separator,
/// even when the program is run on a POSIX machine.
library;

import 'src/context.dart';
import 'src/style.dart';

export 'src/context.dart' hide createInternal;
export 'src/path_exception.dart';
export 'src/path_map.dart';
export 'src/path_set.dart';
export 'src/style.dart';

/// A default context for manipulating POSIX paths.
final Context posix = Context(style: Style.posix);

/// A default context for manipulating Windows paths.
final Context windows = Context(style: Style.windows);

/// A default context for manipulating URLs.
///
/// URL path equality is undefined for paths that differ only in their
/// percent-encoding or only in the case of their host segment.
final Context url = Context(style: Style.url);

/// The system path context.
///
/// This differs from a context created with [Context.new] in that its
/// [Context.current] is always the current working directory, rather than being
/// set once when the context is created.
final Context context = createInternal();

/// Returns the [Style] of the current context.
///
/// This is the style that all top-level path functions will use.
Style get style => context.style;

/// Gets the path to the current working directory.
///
/// In the browser, this means the current URL, without the last file segment.
String get current {
  // If the current working directory gets deleted out from under the program,
  // accessing it will throw an IO exception. In order to avoid transient
  // errors, if we already have a cached working directory, catch the error and
  // use that.
  Uri uri;
  try {
    uri = Uri.base;
  } on Exception {
    if (_current != null) return _current!;
    rethrow;
  }

  // Converting the base URI to a file path is pretty slow, and the base URI
  // rarely changes in practice, so we cache the result here.
  if (uri == _currentUriBase) return _current!;
  _currentUriBase = uri;

  if (Style.platform == Style.url) {
    _current = uri.resolve('.').toString();
  } else {
    final path = uri.toFilePath();
    // Remove trailing '/' or '\' unless it is the only thing left
    // (for instance the root on Linux).
    final lastIndex = path.length - 1;
    assert(path[lastIndex] == '/' || path[lastIndex] == '\\');
    _current = lastIndex == 0 ? path : path.substring(0, lastIndex);
  }
  return _current!;
}

/// The last value returned by [Uri.base].
///
/// This is used to cache the current working directory.
Uri? _currentUriBase;

/// The last known value of the current working directory.
///
/// This is cached because [current] is called frequently but rarely actually
/// changes.
String? _current;

/// Gets the path separator for the current platform. This is `\` on Windows
/// and `/` on other platforms (including the browser).
String get separator => context.separator;

/// Returns a new path with the given path parts appended to [current].
///
/// Equivalent to [join()] with [current] as the first argument. Example:
///
///     p.absolute('path', 'to/foo'); // -> '/your/current/dir/path/to/foo'
///
/// Does not [normalize] or [canonicalize] paths.
String absolute(String part1,
        [String? part2,
        String? part3,
        String? part4,
        String? part5,
        String? part6,
        String? part7,
        String? part8,
        String? part9,
        String? part10,
        String? part11,
        String? part12,
        String? part13,
        String? part14,
        String? part15]) =>
    context.absolute(part1, part2, part3, part4, part5, part6, part7, part8,
        part9, part10, part11, part12, part13, part14, part15);

/// Gets the part of [path] after the last separator.
///
///     p.basename('path/to/foo.dart'); // -> 'foo.dart'
///     p.basename('path/to');          // -> 'to'
///
/// Trailing separators are ignored.
///
///     p.basename('path/to/'); // -> 'to'
String basename(String path) => context.basename(path);

/// Gets the part of [path] after the last separator, and without any trailing
/// file extension.
///
///     p.basenameWithoutExtension('path/to/foo.dart'); // -> 'foo'
///
/// Trailing separators are ignored.
///
///     p.basenameWithoutExtension('path/to/foo.dart/'); // -> 'foo'
String basenameWithoutExtension(String path) =>
    context.basenameWithoutExtension(path);

/// Gets the part of [path] before the last separator.
///
///     p.dirname('path/to/foo.dart'); // -> 'path/to'
///     p.dirname('path/to');          // -> 'path'
///
/// Trailing separators are ignored.
///
///     p.dirname('path/to/'); // -> 'path'
///
/// If an absolute path contains no directories, only a root, then the root
/// is returned.
///
///     p.dirname('/');  // -> '/' (posix)
///     p.dirname('c:\');  // -> 'c:\' (windows)
///
/// If a relative path has no directories, then '.' is returned.
///
///     p.dirname('foo');  // -> '.'
///     p.dirname('');  // -> '.'
String dirname(String path) => context.dirname(path);

/// Gets the file extension of [path]: the portion of [basename] from the last
/// `.` to the end (including the `.` itself).
///
///     p.extension('path/to/foo.dart');    // -> '.dart'
///     p.extension('path/to/foo');         // -> ''
///     p.extension('path.to/foo');         // -> ''
///     p.extension('path/to/foo.dart.js'); // -> '.js'
///
/// If the file name starts with a `.`, then that is not considered the
/// extension:
///
///     p.extension('~/.bashrc');    // -> ''
///     p.extension('~/.notes.txt'); // -> '.txt'
///
/// Takes an optional parameter `level` which makes possible to return
/// multiple extensions having `level` number of dots. If `level` exceeds the
/// number of dots, the full extension is returned. The value of `level` must
/// be greater than 0, else `RangeError` is thrown.
///
///     p.extension('foo.bar.dart.js', 2);   // -> '.dart.js
///     p.extension('foo.bar.dart.js', 3);   // -> '.bar.dart.js'
///     p.extension('foo.bar.dart.js', 10);  // -> '.bar.dart.js'
///     p.extension('path/to/foo.bar.dart.js', 2);  // -> '.dart.js'
String extension(String path, [int level = 1]) =>
    context.extension(path, level);

/// Returns the root of [path], if it's absolute, or the empty string if it's
/// relative.
///
///     // Unix
///     p.rootPrefix('path/to/foo'); // -> ''
///     p.rootPrefix('/path/to/foo'); // -> '/'
///
///     // Windows
///     p.rootPrefix(r'path\to\foo'); // -> ''
///     p.rootPrefix(r'C:\path\to\foo'); // -> r'C:\'
///     p.rootPrefix(r'\\server\share\a\b'); // -> r'\\server\share'
///
///     // URL
///     p.rootPrefix('path/to/foo'); // -> ''
///     p.rootPrefix('https://dart.dev/path/to/foo');
///       // -> 'https://dart.dev'
String rootPrefix(String path) => context.rootPrefix(path);

/// Returns `true` if [path] is an absolute path and `false` if it is a
/// relative path.
///
/// On POSIX systems, absolute paths start with a `/` (forward slash). On
/// Windows, an absolute path starts with `\\`, or a drive letter followed by
/// `:/` or `:\`. For URLs, absolute paths either start with a protocol and
/// optional hostname (e.g. `https://dart.dev`, `file://`) or with a `/`.
///
/// URLs that start with `/` are known as "root-relative", since they're
/// relative to the root of the current URL. Since root-relative paths are still
/// absolute in every other sense, [isAbsolute] will return true for them. They
/// can be detected using [isRootRelative].
bool isAbsolute(String path) => context.isAbsolute(path);

/// Returns `true` if [path] is a relative path and `false` if it is absolute.
/// On POSIX systems, absolute paths start with a `/` (forward slash). On
/// Windows, an absolute path starts with `\\`, or a drive letter followed by
/// `:/` or `:\`.
bool isRelative(String path) => context.isRelative(path);

/// Returns `true` if [path] is a root-relative path and `false` if it's not.
///
/// URLs that start with `/` are known as "root-relative", since they're
/// relative to the root of the current URL. Since root-relative paths are still
/// absolute in every other sense, [isAbsolute] will return true for them. They
/// can be detected using [isRootRelative].
///
/// No POSIX and Windows paths are root-relative.
bool isRootRelative(String path) => context.isRootRelative(path);

/// Joins the given path parts into a single path using the current platform's
/// [separator]. Example:
///
///     p.join('path', 'to', 'foo'); // -> 'path/to/foo'
///
/// If any part ends in a path separator, then a redundant separator will not
/// be added:
///
///     p.join('path/', 'to', 'foo'); // -> 'path/to/foo'
///
/// If a part is an absolute path, then anything before that will be ignored:
///
///     p.join('path', '/to', 'foo'); // -> '/to/foo'
String join(String part1,
        [String? part2,
        String? part3,
        String? part4,
        String? part5,
        String? part6,
        String? part7,
        String? part8,
        String? part9,
        String? part10,
        String? part11,
        String? part12,
        String? part13,
        String? part14,
        String? part15,
        String? part16]) =>
    context.join(part1, part2, part3, part4, part5, part6, part7, part8, part9,
        part10, part11, part12, part13, part14, part15, part16);

/// Joins the given path parts into a single path using the current platform's
/// [separator]. Example:
///
///     p.joinAll(['path', 'to', 'foo']); // -> 'path/to/foo'
///
/// If any part ends in a path separator, then a redundant separator will not
/// be added:
///
///     p.joinAll(['path/', 'to', 'foo']); // -> 'path/to/foo'
///
/// If a part is an absolute path, then anything before that will be ignored:
///
///     p.joinAll(['path', '/to', 'foo']); // -> '/to/foo'
///
/// For a fixed number of parts, [join] is usually terser.
String joinAll(Iterable<String> parts) => context.joinAll(parts);

/// Splits [path] into its components using the current platform's [separator].
///
///     p.split('path/to/foo'); // -> ['path', 'to', 'foo']
///
/// The path will *not* be normalized before splitting.
///
///     p.split('path/../foo'); // -> ['path', '..', 'foo']
///
/// If [path] is absolute, the root directory will be the first element in the
/// array. Example:
///
///     // Unix
///     p.split('/path/to/foo'); // -> ['/', 'path', 'to', 'foo']
///
///     // Windows
///     p.split(r'C:\path\to\foo'); // -> [r'C:\', 'path', 'to', 'foo']
///     p.split(r'\\server\share\path\to\foo');
///       // -> [r'\\server\share', 'foo', 'bar', 'baz']
///
///     // Browser
///     p.split('https://dart.dev/path/to/foo');
///       // -> ['https://dart.dev', 'path', 'to', 'foo']
List<String> split(String path) => context.split(path);

/// Canonicalizes [path].
///
/// This is guaranteed to return the same path for two different input paths
/// if and only if both input paths point to the same location. Unlike
/// [normalize], it returns absolute paths when possible and canonicalizes
/// ASCII case on Windows.
///
/// Note that this does not resolve symlinks.
///
/// If you want a map that uses path keys, it's probably more efficient to use a
/// Map with [equals] and [hash] specified as the callbacks to use for keys than
/// it is to canonicalize every key.
String canonicalize(String path) => context.canonicalize(path);

/// Normalizes [path], simplifying it by handling `..`, and `.`, and
/// removing redundant path separators whenever possible.
///
/// Note that this is *not* guaranteed to return the same result for two
/// equivalent input paths. For that, see [canonicalize]. Or, if you're using
/// paths as map keys use [equals] and [hash] as the key callbacks.
///
///     p.normalize('path/./to/..//file.text'); // -> 'path/file.txt'
String normalize(String path) => context.normalize(path);

/// Attempts to convert [path] to an equivalent relative path from the current
/// directory.
///
///     // Given current directory is /root/path:
///     p.relative('/root/path/a/b.dart'); // -> 'a/b.dart'
///     p.relative('/root/other.dart'); // -> '../other.dart'
///
/// If the [from] argument is passed, [path] is made relative to that instead.
///
///     p.relative('/root/path/a/b.dart', from: '/root/path'); // -> 'a/b.dart'
///     p.relative('/root/other.dart', from: '/root/path');
///       // -> '../other.dart'
///
/// If [path] and/or [from] are relative paths, they are assumed to be relative
/// to the current directory.
///
/// Since there is no relative path from one drive letter to another on Windows,
/// or from one hostname to another for URLs, this will return an absolute path
/// in those cases.
///
///     // Windows
///     p.relative(r'D:\other', from: r'C:\home'); // -> 'D:\other'
///
///     // URL
///     p.relative('https://dart.dev', from: 'https://pub.dev');
///       // -> 'https://dart.dev'
String relative(String path, {String? from}) =>
    context.relative(path, from: from);

/// Returns `true` if [child] is a path beneath `parent`, and `false` otherwise.
///
///     p.isWithin('/root/path', '/root/path/a'); // -> true
///     p.isWithin('/root/path', '/root/other'); // -> false
///     p.isWithin('/root/path', '/root/path') // -> false
bool isWithin(String parent, String child) => context.isWithin(parent, child);

/// Returns `true` if [path1] points to the same location as [path2], and
/// `false` otherwise.
///
/// The [hash] function returns a hash code that matches these equality
/// semantics.
bool equals(String path1, String path2) => context.equals(path1, path2);

/// Returns a hash code for [path] such that, if [equals] returns `true` for two
/// paths, their hash codes are the same.
///
/// Note that the same path may have different hash codes on different platforms
/// or with different [current] directories.
int hash(String path) => context.hash(path);

/// Removes a trailing extension from the last part of [path].
///
///     p.withoutExtension('path/to/foo.dart'); // -> 'path/to/foo'
String withoutExtension(String path) => context.withoutExtension(path);

/// Returns [path] with the trailing extension set to [extension].
///
/// If [path] doesn't have a trailing extension, this just adds [extension] to
/// the end.
///
///     p.setExtension('path/to/foo.dart', '.js') // -> 'path/to/foo.js'
///     p.setExtension('path/to/foo.dart.js', '.map')
///       // -> 'path/to/foo.dart.map'
///     p.setExtension('path/to/foo', '.js') // -> 'path/to/foo.js'
String setExtension(String path, String extension) =>
    context.setExtension(path, extension);

/// Returns the path represented by [uri], which may be a [String] or a [Uri].
///
/// For POSIX and Windows styles, [uri] must be a `file:` URI. For the URL
/// style, this will just convert [uri] to a string.
///
///     // POSIX
///     p.fromUri('file:///path/to/foo') // -> '/path/to/foo'
///
///     // Windows
///     p.fromUri('file:///C:/path/to/foo') // -> r'C:\path\to\foo'
///
///     // URL
///     p.fromUri('https://dart.dev/path/to/foo')
///       // -> 'https://dart.dev/path/to/foo'
///
/// If [uri] is relative, a relative path will be returned.
///
///     p.fromUri('path/to/foo'); // -> 'path/to/foo'
String fromUri(Object? uri) => context.fromUri(uri!);

/// Returns the URI that represents [path].
///
/// For POSIX and Windows styles, this will return a `file:` URI. For the URL
/// style, this will just convert [path] to a [Uri].
///
///     // POSIX
///     p.toUri('/path/to/foo')
///       // -> Uri.parse('file:///path/to/foo')
///
///     // Windows
///     p.toUri(r'C:\path\to\foo')
///       // -> Uri.parse('file:///C:/path/to/foo')
///
///     // URL
///     p.toUri('https://dart.dev/path/to/foo')
///       // -> Uri.parse('https://dart.dev/path/to/foo')
///
/// If [path] is relative, a relative URI will be returned.
///
///     p.toUri('path/to/foo') // -> Uri.parse('path/to/foo')
Uri toUri(String path) => context.toUri(path);

/// Returns a terse, human-readable representation of [uri].
///
/// [uri] can be a [String] or a [Uri]. If it can be made relative to the
/// current working directory, that's done. Otherwise, it's returned as-is. This
/// gracefully handles non-`file:` URIs for [Style.posix] and [Style.windows].
///
/// The returned value is meant for human consumption, and may be either URI-
/// or path-formatted.
///
///     // POSIX at "/root/path"
///     p.prettyUri('file:///root/path/a/b.dart'); // -> 'a/b.dart'
///     p.prettyUri('https://dart.dev/'); // -> 'https://dart.dev'
///
///     // Windows at "C:\root\path"
///     p.prettyUri('file:///C:/root/path/a/b.dart'); // -> r'a\b.dart'
///     p.prettyUri('https://dart.dev/'); // -> 'https://dart.dev'
///
///     // URL at "https://dart.dev/root/path"
///     p.prettyUri('https://dart.dev/root/path/a/b.dart'); // -> r'a/b.dart'
///     p.prettyUri('file:///root/path'); // -> 'file:///root/path'
String prettyUri(Object? uri) => context.prettyUri(uri!);

// File: C:\MyDartProjects\eloquent\lib\src\pdo\postgres\dependencies\path\src\characters.dart


/// This library contains character-code definitions.
const plus = 0x2b;
const minus = 0x2d;
const period = 0x2e;
const slash = 0x2f;
const zero = 0x30;
const nine = 0x39;
const colon = 0x3a;
const upperA = 0x41;
const upperZ = 0x5a;
const lowerA = 0x61;
const lowerZ = 0x7a;
const backslash = 0x5c;

// File: C:\MyDartProjects\eloquent\lib\src\pdo\postgres\dependencies\path\src\context.dart


import 'dart:math' as math;

import '../path.dart' as p;
import 'characters.dart' as chars;
import 'internal_style.dart';
import 'parsed_path.dart';
import 'path_exception.dart';
import 'style.dart';

Context createInternal() => Context._internal();

/// An instantiable class for manipulating paths. Unlike the top-level
/// functions, this lets you explicitly select what platform the paths will use.
class Context {
  /// Creates a new path context for the given style and current directory.
  ///
  /// If [style] is omitted, it uses the host operating system's path style. If
  /// only [current] is omitted, it defaults ".". If *both* [style] and
  /// [current] are omitted, [current] defaults to the real current working
  /// directory.
  ///
  /// On the browser, [style] defaults to [Style.url] and [current] defaults to
  /// the current URL.
  factory Context({Style? style, String? current}) {
    if (current == null) {
      if (style == null) {
        current = p.current;
      } else {
        current = '.';
      }
    }

    if (style == null) {
      style = Style.platform;
    } else if (style is! InternalStyle) {
      throw ArgumentError('Only styles defined by the path package are '
          'allowed.');
    }

    return Context._(style as InternalStyle, current);
  }

  /// Create a [Context] to be used internally within path.
  Context._internal()
      : style = Style.platform as InternalStyle,
        _current = null;

  Context._(this.style, this._current);

  /// The style of path that this context works with.
  final InternalStyle style;

  /// The current directory given when Context was created. If null, current
  /// directory is evaluated from 'p.current'.
  final String? _current;

  /// The current directory that relative paths are relative to.
  String get current => _current ?? p.current;

  /// Gets the path separator for the context's [style]. On Mac and Linux,
  /// this is `/`. On Windows, it's `\`.
  String get separator => style.separator;

  /// Returns a new path with the given path parts appended to [current].
  ///
  /// Equivalent to [join()] with [current] as the first argument. Example:
  ///
  ///     var context = Context(current: '/root');
  ///     context.absolute('path', 'to', 'foo'); // -> '/root/path/to/foo'
  ///
  /// If [current] isn't absolute, this won't return an absolute path. Does not
  /// [normalize] or [canonicalize] paths.
  String absolute(String part1,
      [String? part2,
      String? part3,
      String? part4,
      String? part5,
      String? part6,
      String? part7,
      String? part8,
      String? part9,
      String? part10,
      String? part11,
      String? part12,
      String? part13,
      String? part14,
      String? part15]) {
    _validateArgList('absolute', [
      part1,
      part2,
      part3,
      part4,
      part5,
      part6,
      part7,
      part8,
      part9,
      part10,
      part11,
      part12,
      part13,
      part14,
      part15
    ]);

    // If there's a single absolute path, just return it. This is a lot faster
    // for the common case of `p.absolute(path)`.
    if (part2 == null && isAbsolute(part1) && !isRootRelative(part1)) {
      return part1;
    }

    return join(current, part1, part2, part3, part4, part5, part6, part7, part8,
        part9, part10, part11, part12, part13, part14, part15);
  }

  /// Gets the part of [path] after the last separator on the context's
  /// platform.
  ///
  ///     context.basename('path/to/foo.dart'); // -> 'foo.dart'
  ///     context.basename('path/to');          // -> 'to'
  ///
  /// Trailing separators are ignored.
  ///
  ///     context.basename('path/to/'); // -> 'to'
  String basename(String path) => _parse(path).basename;

  /// Gets the part of [path] after the last separator on the context's
  /// platform, and without any trailing file extension.
  ///
  ///     context.basenameWithoutExtension('path/to/foo.dart'); // -> 'foo'
  ///
  /// Trailing separators are ignored.
  ///
  ///     context.basenameWithoutExtension('path/to/foo.dart/'); // -> 'foo'
  String basenameWithoutExtension(String path) =>
      _parse(path).basenameWithoutExtension;

  /// Gets the part of [path] before the last separator.
  ///
  ///     context.dirname('path/to/foo.dart'); // -> 'path/to'
  ///     context.dirname('path/to');          // -> 'path'
  ///
  /// Trailing separators are ignored.
  ///
  ///     context.dirname('path/to/'); // -> 'path'
  String dirname(String path) {
    final parsed = _parse(path);
    parsed.removeTrailingSeparators();
    if (parsed.parts.isEmpty) return parsed.root ?? '.';
    if (parsed.parts.length == 1) return parsed.root ?? '.';
    parsed.parts.removeLast();
    parsed.separators.removeLast();
    parsed.removeTrailingSeparators();
    return parsed.toString();
  }

  /// Gets the file extension of [path]: the portion of [basename] from the last
  /// `.` to the end (including the `.` itself).
  ///
  ///     context.extension('path/to/foo.dart'); // -> '.dart'
  ///     context.extension('path/to/foo'); // -> ''
  ///     context.extension('path.to/foo'); // -> ''
  ///     context.extension('path/to/foo.dart.js'); // -> '.js'
  ///
  /// If the file name starts with a `.`, then it is not considered an
  /// extension:
  ///
  ///     context.extension('~/.bashrc');    // -> ''
  ///     context.extension('~/.notes.txt'); // -> '.txt'
  ///
  /// Takes an optional parameter `level` which makes possible to return
  /// multiple extensions having `level` number of dots. If `level` exceeds the
  /// number of dots, the full extension is returned. The value of `level` must
  /// be greater than 0, else `RangeError` is thrown.
  ///
  ///     context.extension('foo.bar.dart.js', 2);   // -> '.dart.js
  ///     context.extension('foo.bar.dart.js', 3);   // -> '.bar.dart.js'
  ///     context.extension('foo.bar.dart.js', 10);  // -> '.bar.dart.js'
  ///     context.extension('path/to/foo.bar.dart.js', 2);  // -> '.dart.js'
  String extension(String path, [int level = 1]) =>
      _parse(path).extension(level);

  /// Returns the root of [path] if it's absolute, or an empty string if it's
  /// relative.
  ///
  ///     // Unix
  ///     context.rootPrefix('path/to/foo'); // -> ''
  ///     context.rootPrefix('/path/to/foo'); // -> '/'
  ///
  ///     // Windows
  ///     context.rootPrefix(r'path\to\foo'); // -> ''
  ///     context.rootPrefix(r'C:\path\to\foo'); // -> r'C:\'
  ///     context.rootPrefix(r'\\server\share\a\b'); // -> r'\\server\share'
  ///
  ///     // URL
  ///     context.rootPrefix('path/to/foo'); // -> ''
  ///     context.rootPrefix('https://dart.dev/path/to/foo');
  ///       // -> 'https://dart.dev'
  String rootPrefix(String path) => path.substring(0, style.rootLength(path));

  /// Returns `true` if [path] is an absolute path and `false` if it is a
  /// relative path.
  ///
  /// On POSIX systems, absolute paths start with a `/` (forward slash). On
  /// Windows, an absolute path starts with `\\`, or a drive letter followed by
  /// `:/` or `:\`. For URLs, absolute paths either start with a protocol and
  /// optional hostname (e.g. `https://dart.dev`, `file://`) or with a `/`.
  ///
  /// URLs that start with `/` are known as "root-relative", since they're
  /// relative to the root of the current URL. Since root-relative paths are
  /// still absolute in every other sense, [isAbsolute] will return true for
  /// them. They can be detected using [isRootRelative].
  bool isAbsolute(String path) => style.rootLength(path) > 0;

  /// Returns `true` if [path] is a relative path and `false` if it is absolute.
  /// On POSIX systems, absolute paths start with a `/` (forward slash). On
  /// Windows, an absolute path starts with `\\`, or a drive letter followed by
  /// `:/` or `:\`.
  bool isRelative(String path) => !isAbsolute(path);

  /// Returns `true` if [path] is a root-relative path and `false` if it's not.
  ///
  /// URLs that start with `/` are known as "root-relative", since they're
  /// relative to the root of the current URL. Since root-relative paths are
  /// still absolute in every other sense, [isAbsolute] will return true for
  /// them. They can be detected using [isRootRelative].
  ///
  /// No POSIX and Windows paths are root-relative.
  bool isRootRelative(String path) => style.isRootRelative(path);

  /// Joins the given path parts into a single path. Example:
  ///
  ///     context.join('path', 'to', 'foo'); // -> 'path/to/foo'
  ///
  /// If any part ends in a path separator, then a redundant separator will not
  /// be added:
  ///
  ///     context.join('path/', 'to', 'foo'); // -> 'path/to/foo'
  ///
  /// If a part is an absolute path, then anything before that will be ignored:
  ///
  ///     context.join('path', '/to', 'foo'); // -> '/to/foo'
  ///
  String join(String part1,
      [String? part2,
      String? part3,
      String? part4,
      String? part5,
      String? part6,
      String? part7,
      String? part8,
      String? part9,
      String? part10,
      String? part11,
      String? part12,
      String? part13,
      String? part14,
      String? part15,
      String? part16]) {
    final parts = <String?>[
      part1,
      part2,
      part3,
      part4,
      part5,
      part6,
      part7,
      part8,
      part9,
      part10,
      part11,
      part12,
      part13,
      part14,
      part15,
      part16,
    ];
    _validateArgList('join', parts);
    return joinAll(parts.whereType<String>());
  }

  /// Joins the given path parts into a single path. Example:
  ///
  ///     context.joinAll(['path', 'to', 'foo']); // -> 'path/to/foo'
  ///
  /// If any part ends in a path separator, then a redundant separator will not
  /// be added:
  ///
  ///     context.joinAll(['path/', 'to', 'foo']); // -> 'path/to/foo'
  ///
  /// If a part is an absolute path, then anything before that will be ignored:
  ///
  ///     context.joinAll(['path', '/to', 'foo']); // -> '/to/foo'
  ///
  /// For a fixed number of parts, [join] is usually terser.
  String joinAll(Iterable<String> parts) {
    final buffer = StringBuffer();
    var needsSeparator = false;
    var isAbsoluteAndNotRootRelative = false;

    for (var part in parts.where((part) => part != '')) {
      if (isRootRelative(part) && isAbsoluteAndNotRootRelative) {
        // If the new part is root-relative, it preserves the previous root but
        // replaces the path after it.
        final parsed = _parse(part);
        final path = buffer.toString();
        parsed.root =
            path.substring(0, style.rootLength(path, withDrive: true));
        if (style.needsSeparator(parsed.root!)) {
          parsed.separators[0] = style.separator;
        }
        buffer.clear();
        buffer.write(parsed.toString());
      } else if (isAbsolute(part)) {
        isAbsoluteAndNotRootRelative = !isRootRelative(part);
        // An absolute path discards everything before it.
        buffer.clear();
        buffer.write(part);
      } else {
        if (part.isNotEmpty && style.containsSeparator(part[0])) {
          // The part starts with a separator, so we don't need to add one.
        } else if (needsSeparator) {
          buffer.write(separator);
        }

        buffer.write(part);
      }

      // Unless this part ends with a separator, we'll need to add one before
      // the next part.
      needsSeparator = style.needsSeparator(part);
    }

    return buffer.toString();
  }

  /// Splits [path] into its components using the current platform's
  /// [separator]. Example:
  ///
  ///     context.split('path/to/foo'); // -> ['path', 'to', 'foo']
  ///
  /// The path will *not* be normalized before splitting.
  ///
  ///     context.split('path/../foo'); // -> ['path', '..', 'foo']
  ///
  /// If [path] is absolute, the root directory will be the first element in the
  /// array. Example:
  ///
  ///     // Unix
  ///     context.split('/path/to/foo'); // -> ['/', 'path', 'to', 'foo']
  ///
  ///     // Windows
  ///     context.split(r'C:\path\to\foo'); // -> [r'C:\', 'path', 'to', 'foo']
  ///     context.split(r'\\server\share\path\to\foo');
  ///       // -> [r'\\server\share', 'path', 'to', 'foo']
  ///
  ///     // Browser
  ///     context.split('https://dart.dev/path/to/foo');
  ///       // -> ['https://dart.dev', 'path', 'to', 'foo']
  List<String> split(String path) {
    final parsed = _parse(path);
    // Filter out empty parts that exist due to multiple separators in a row.
    parsed.parts = parsed.parts.where((part) => part.isNotEmpty).toList();
    if (parsed.root != null) parsed.parts.insert(0, parsed.root!);
    return parsed.parts;
  }

  /// Canonicalizes [path].
  ///
  /// This is guaranteed to return the same path for two different input paths
  /// if and only if both input paths point to the same location. Unlike
  /// [normalize], it returns absolute paths when possible and canonicalizes
  /// ASCII case on Windows.
  ///
  /// Note that this does not resolve symlinks.
  ///
  /// If you want a map that uses path keys, it's probably more efficient to use
  /// a Map with [equals] and [hash] specified as the callbacks to use for keys
  /// than it is to canonicalize every key.
  String canonicalize(String path) {
    path = absolute(path);
    if (style != Style.windows && !_needsNormalization(path)) return path;

    final parsed = _parse(path);
    parsed.normalize(canonicalize: true);
    return parsed.toString();
  }

  /// Normalizes [path], simplifying it by handling `..`, and `.`, and
  /// removing redundant path separators whenever possible.
  ///
  /// Note that this is *not* guaranteed to return the same result for two
  /// equivalent input paths. For that, see [canonicalize]. Or, if you're using
  /// paths as map keys use [equals] and [hash] as the key callbacks.
  ///
  ///     context.normalize('path/./to/..//file.text'); // -> 'path/file.txt'
  String normalize(String path) {
    if (!_needsNormalization(path)) return path;

    final parsed = _parse(path);
    parsed.normalize();
    return parsed.toString();
  }

  /// Returns whether [path] needs to be normalized.
  bool _needsNormalization(String path) {
    var start = 0;
    final codeUnits = path.codeUnits;
    int? previousPrevious;
    int? previous;

    // Skip past the root before we start looking for snippets that need
    // normalization. We want to normalize "//", but not when it's part of
    // "http://".
    final root = style.rootLength(path);
    if (root != 0) {
      start = root;
      previous = chars.slash;

      // On Windows, the root still needs to be normalized if it contains a
      // forward slash.
      if (style == Style.windows) {
        for (var i = 0; i < root; i++) {
          if (codeUnits[i] == chars.slash) return true;
        }
      }
    }

    for (var i = start; i < codeUnits.length; i++) {
      final codeUnit = codeUnits[i];
      if (style.isSeparator(codeUnit)) {
        // Forward slashes in Windows paths are normalized to backslashes.
        if (style == Style.windows && codeUnit == chars.slash) return true;

        // Multiple separators are normalized to single separators.
        if (previous != null && style.isSeparator(previous)) return true;

        // Single dots and double dots are normalized to directory traversals.
        //
        // This can return false positives for ".../", but that's unlikely
        // enough that it's probably not going to cause performance issues.
        if (previous == chars.period &&
            (previousPrevious == null ||
                previousPrevious == chars.period ||
                style.isSeparator(previousPrevious))) {
          return true;
        }
      }

      previousPrevious = previous;
      previous = codeUnit;
    }

    // Empty paths are normalized to ".".
    if (previous == null) return true;

    // Trailing separators are removed.
    if (style.isSeparator(previous)) return true;

    // Single dots and double dots are normalized to directory traversals.
    if (previous == chars.period &&
        (previousPrevious == null ||
            style.isSeparator(previousPrevious) ||
            previousPrevious == chars.period)) {
      return true;
    }

    return false;
  }

  /// Attempts to convert [path] to an equivalent relative path relative to
  /// [current].
  ///
  ///     var context = Context(current: '/root/path');
  ///     context.relative('/root/path/a/b.dart'); // -> 'a/b.dart'
  ///     context.relative('/root/other.dart'); // -> '../other.dart'
  ///
  /// If the [from] argument is passed, [path] is made relative to that instead.
  ///
  ///     context.relative('/root/path/a/b.dart',
  ///         from: '/root/path'); // -> 'a/b.dart'
  ///     context.relative('/root/other.dart',
  ///         from: '/root/path'); // -> '../other.dart'
  ///
  /// If [path] and/or [from] are relative paths, they are assumed to be
  /// relative to [current].
  ///
  /// Since there is no relative path from one drive letter to another on
  /// Windows, this will return an absolute path in that case.
  ///
  ///     context.relative(r'D:\other', from: r'C:\other'); // -> 'D:\other'
  ///
  /// This will also return an absolute path if an absolute [path] is passed to
  /// a context with a relative path for [current].
  ///
  ///     var context = Context(r'some/relative/path');
  ///     context.relative(r'/absolute/path'); // -> '/absolute/path'
  ///
  /// If [current] is relative, it may be impossible to determine a path from
  /// [from] to [path]. For example, if [current] and [path] are "." and [from]
  /// is "/", no path can be determined. In this case, a [PathException] will be
  /// thrown.
  String relative(String path, {String? from}) {
    // Avoid expensive computation if the path is already relative.
    if (from == null && isRelative(path)) return normalize(path);

    from = from == null ? current : absolute(from);

    // We can't determine the path from a relative path to an absolute path.
    if (isRelative(from) && isAbsolute(path)) {
      return normalize(path);
    }

    // If the given path is relative, resolve it relative to the context's
    // current directory.
    if (isRelative(path) || isRootRelative(path)) {
      path = absolute(path);
    }

    // If the path is still relative and `from` is absolute, we're unable to
    // find a path from `from` to `path`.
    if (isRelative(path) && isAbsolute(from)) {
      throw PathException('Unable to find a path to "$path" from "$from".');
    }

    final fromParsed = _parse(from)..normalize();
    final pathParsed = _parse(path)..normalize();

    if (fromParsed.parts.isNotEmpty && fromParsed.parts[0] == '.') {
      return pathParsed.toString();
    }

    // If the root prefixes don't match (for example, different drive letters
    // on Windows), then there is no relative path, so just return the absolute
    // one. In Windows, drive letters are case-insenstive and we allow
    // calculation of relative paths, even if a path has not been normalized.
    if (fromParsed.root != pathParsed.root &&
        ((fromParsed.root == null || pathParsed.root == null) ||
            !style.pathsEqual(fromParsed.root!, pathParsed.root!))) {
      return pathParsed.toString();
    }

    // Strip off their common prefix.
    while (fromParsed.parts.isNotEmpty &&
        pathParsed.parts.isNotEmpty &&
        style.pathsEqual(fromParsed.parts[0], pathParsed.parts[0])) {
      fromParsed.parts.removeAt(0);
      fromParsed.separators.removeAt(1);
      pathParsed.parts.removeAt(0);
      pathParsed.separators.removeAt(1);
    }

    // If there are any directories left in the from path, we need to walk up
    // out of them. If a directory left in the from path is '..', it cannot
    // be cancelled by adding a '..'.
    if (fromParsed.parts.isNotEmpty && fromParsed.parts[0] == '..') {
      throw PathException('Unable to find a path to "$path" from "$from".');
    }
    pathParsed.parts.insertAll(0, List.filled(fromParsed.parts.length, '..'));
    pathParsed.separators[0] = '';
    pathParsed.separators
        .insertAll(1, List.filled(fromParsed.parts.length, style.separator));

    // Corner case: the paths completely collapsed.
    if (pathParsed.parts.isEmpty) return '.';

    // Corner case: path was '.' and some '..' directories were added in front.
    // Don't add a final '/.' in that case.
    if (pathParsed.parts.length > 1 && pathParsed.parts.last == '.') {
      pathParsed.parts.removeLast();
      pathParsed.separators
        ..removeLast()
        ..removeLast()
        ..add('');
    }

    // Make it relative.
    pathParsed.root = '';
    pathParsed.removeTrailingSeparators();

    return pathParsed.toString();
  }

  /// Returns `true` if [child] is a path beneath `parent`, and `false`
  /// otherwise.
  ///
  ///     path.isWithin('/root/path', '/root/path/a'); // -> true
  ///     path.isWithin('/root/path', '/root/other'); // -> false
  ///     path.isWithin('/root/path', '/root/path'); // -> false
  bool isWithin(String parent, String child) =>
      _isWithinOrEquals(parent, child) == _PathRelation.within;

  /// Returns `true` if [path1] points to the same location as [path2], and
  /// `false` otherwise.
  ///
  /// The [hash] function returns a hash code that matches these equality
  /// semantics.
  bool equals(String path1, String path2) =>
      _isWithinOrEquals(path1, path2) == _PathRelation.equal;

  /// Compares two paths and returns an enum value indicating their relationship
  /// to one another.
  ///
  /// This never returns [_PathRelation.inconclusive].
  _PathRelation _isWithinOrEquals(String parent, String child) {
    // Make both paths the same level of relative. We're only able to do the
    // quick comparison if both paths are in the same format, and making a path
    // absolute is faster than making it relative.
    final parentIsAbsolute = isAbsolute(parent);
    final childIsAbsolute = isAbsolute(child);
    if (parentIsAbsolute && !childIsAbsolute) {
      child = absolute(child);
      if (style.isRootRelative(parent)) parent = absolute(parent);
    } else if (childIsAbsolute && !parentIsAbsolute) {
      parent = absolute(parent);
      if (style.isRootRelative(child)) child = absolute(child);
    } else if (childIsAbsolute && parentIsAbsolute) {
      final childIsRootRelative = style.isRootRelative(child);
      final parentIsRootRelative = style.isRootRelative(parent);

      if (childIsRootRelative && !parentIsRootRelative) {
        child = absolute(child);
      } else if (parentIsRootRelative && !childIsRootRelative) {
        parent = absolute(parent);
      }
    }

    final result = _isWithinOrEqualsFast(parent, child);
    if (result != _PathRelation.inconclusive) return result;

    String relative;
    try {
      relative = this.relative(child, from: parent);
    } on PathException catch (_) {
      // If no relative path from [parent] to [child] is found, [child]
      // definitely isn't a child of [parent].
      return _PathRelation.different;
    }

    if (!isRelative(relative)) return _PathRelation.different;
    if (relative == '.') return _PathRelation.equal;
    if (relative == '..') return _PathRelation.different;
    return (relative.length >= 3 &&
            relative.startsWith('..') &&
            style.isSeparator(relative.codeUnitAt(2)))
        ? _PathRelation.different
        : _PathRelation.within;
  }

  /// An optimized implementation of [_isWithinOrEquals] that doesn't handle a
  /// few complex cases.
  _PathRelation _isWithinOrEqualsFast(String parent, String child) {
    // Normally we just bail when we see "." path components, but we can handle
    // a single dot easily enough.
    if (parent == '.') parent = '';

    final parentRootLength = style.rootLength(parent);
    final childRootLength = style.rootLength(child);

    // If the roots aren't the same length, we know both paths are absolute or
    // both are root-relative, and thus that the roots are meaningfully
    // different.
    //
    //     isWithin("C:/bar", "//foo/bar/baz") //=> false
    //     isWithin("http://example.com/", "http://google.com/bar") //=> false
    if (parentRootLength != childRootLength) return _PathRelation.different;

    // Make sure that the roots are textually the same as well.
    //
    //     isWithin("C:/bar", "D:/bar/baz") //=> false
    //     isWithin("http://example.com/", "http://example.org/bar") //=> false
    for (var i = 0; i < parentRootLength; i++) {
      final parentCodeUnit = parent.codeUnitAt(i);
      final childCodeUnit = child.codeUnitAt(i);
      if (!style.codeUnitsEqual(parentCodeUnit, childCodeUnit)) {
        return _PathRelation.different;
      }
    }

    // Start by considering the last code unit as a separator, since
    // semantically we're starting at a new path component even if we're
    // comparing relative paths.
    var lastCodeUnit = chars.slash;

    /// The index of the last separator in [parent].
    int? lastParentSeparator;

    // Iterate through both paths as long as they're semantically identical.
    var parentIndex = parentRootLength;
    var childIndex = childRootLength;
    while (parentIndex < parent.length && childIndex < child.length) {
      var parentCodeUnit = parent.codeUnitAt(parentIndex);
      var childCodeUnit = child.codeUnitAt(childIndex);
      if (style.codeUnitsEqual(parentCodeUnit, childCodeUnit)) {
        if (style.isSeparator(parentCodeUnit)) {
          lastParentSeparator = parentIndex;
        }

        lastCodeUnit = parentCodeUnit;
        parentIndex++;
        childIndex++;
        continue;
      }

      // Ignore multiple separators in a row.
      if (style.isSeparator(parentCodeUnit) &&
          style.isSeparator(lastCodeUnit)) {
        lastParentSeparator = parentIndex;
        parentIndex++;
        continue;
      } else if (style.isSeparator(childCodeUnit) &&
          style.isSeparator(lastCodeUnit)) {
        childIndex++;
        continue;
      }

      // If a dot comes after a separator, it may be a directory traversal
      // operator. To check that, we need to know if it's followed by either
      // "/" or "./". Otherwise, it's just a normal non-matching character.
      //
      //     isWithin("foo/./bar", "foo/bar/baz") //=> true
      //     isWithin("foo/bar/../baz", "foo/bar/.foo") //=> false
      if (parentCodeUnit == chars.period && style.isSeparator(lastCodeUnit)) {
        parentIndex++;

        // We've hit "/." at the end of the parent path, which we can ignore,
        // since the paths were equivalent up to this point.
        if (parentIndex == parent.length) break;
        parentCodeUnit = parent.codeUnitAt(parentIndex);

        // We've hit "/./", which we can ignore.
        if (style.isSeparator(parentCodeUnit)) {
          lastParentSeparator = parentIndex;
          parentIndex++;
          continue;
        }

        // We've hit "/..", which may be a directory traversal operator that
        // we can't handle on the fast track.
        if (parentCodeUnit == chars.period) {
          parentIndex++;
          if (parentIndex == parent.length ||
              style.isSeparator(parent.codeUnitAt(parentIndex))) {
            return _PathRelation.inconclusive;
          }
        }

        // If this isn't a directory traversal, fall through so we hit the
        // normal handling for mismatched paths.
      }

      // This is the same logic as above, but for the child path instead of the
      // parent.
      if (childCodeUnit == chars.period && style.isSeparator(lastCodeUnit)) {
        childIndex++;
        if (childIndex == child.length) break;
        childCodeUnit = child.codeUnitAt(childIndex);

        if (style.isSeparator(childCodeUnit)) {
          childIndex++;
          continue;
        }

        if (childCodeUnit == chars.period) {
          childIndex++;
          if (childIndex == child.length ||
              style.isSeparator(child.codeUnitAt(childIndex))) {
            return _PathRelation.inconclusive;
          }
        }
      }

      // If we're here, we've hit two non-matching, non-significant characters.
      // As long as the remainders of the two paths don't have any unresolved
      // ".." components, we can be confident that [child] is not within
      // [parent].
      final childDirection = _pathDirection(child, childIndex);
      if (childDirection != _PathDirection.belowRoot) {
        return _PathRelation.inconclusive;
      }

      final parentDirection = _pathDirection(parent, parentIndex);
      if (parentDirection != _PathDirection.belowRoot) {
        return _PathRelation.inconclusive;
      }

      return _PathRelation.different;
    }

    // If the child is shorter than the parent, it's probably not within the
    // parent. The only exception is if the parent has some weird ".." stuff
    // going on, in which case we do the slow check.
    //
    //     isWithin("foo/bar/baz", "foo/bar") //=> false
    //     isWithin("foo/bar/baz/../..", "foo/bar") //=> true
    if (childIndex == child.length) {
      if (parentIndex == parent.length ||
          style.isSeparator(parent.codeUnitAt(parentIndex))) {
        lastParentSeparator = parentIndex;
      } else {
        lastParentSeparator ??= math.max(0, parentRootLength - 1);
      }

      final direction = _pathDirection(parent, lastParentSeparator);
      if (direction == _PathDirection.atRoot) return _PathRelation.equal;
      return direction == _PathDirection.aboveRoot
          ? _PathRelation.inconclusive
          : _PathRelation.different;
    }

    // We've reached the end of the parent path, which means it's time to make a
    // decision. Before we do, though, we'll check the rest of the child to see
    // what that tells us.
    final direction = _pathDirection(child, childIndex);

    // If there are no more components in the child, then it's the same as
    // the parent.
    //
    //     isWithin("foo/bar", "foo/bar") //=> false
    //     isWithin("foo/bar", "foo/bar//") //=> false
    //     equals("foo/bar", "foo/bar") //=> true
    //     equals("foo/bar", "foo/bar//") //=> true
    if (direction == _PathDirection.atRoot) return _PathRelation.equal;

    // If there are unresolved ".." components in the child, no decision we make
    // will be valid. We'll abort and do the slow check instead.
    //
    //     isWithin("foo/bar", "foo/bar/..") //=> false
    //     isWithin("foo/bar", "foo/bar/baz/bang/../../..") //=> false
    //     isWithin("foo/bar", "foo/bar/baz/bang/../../../bar/baz") //=> true
    if (direction == _PathDirection.aboveRoot) {
      return _PathRelation.inconclusive;
    }

    // The child is within the parent if and only if we're on a separator
    // boundary.
    //
    //     isWithin("foo/bar", "foo/bar/baz") //=> true
    //     isWithin("foo/bar/", "foo/bar/baz") //=> true
    //     isWithin("foo/bar", "foo/barbaz") //=> false
    return (style.isSeparator(child.codeUnitAt(childIndex)) ||
            style.isSeparator(lastCodeUnit))
        ? _PathRelation.within
        : _PathRelation.different;
  }

  // Returns a [_PathDirection] describing the path represented by [codeUnits]
  // starting at [index].
  //
  // This ignores leading separators.
  //
  //     pathDirection("foo") //=> below root
  //     pathDirection("foo/bar/../baz") //=> below root
  //     pathDirection("//foo/bar/baz") //=> below root
  //     pathDirection("/") //=> at root
  //     pathDirection("foo/..") //=> at root
  //     pathDirection("foo/../baz") //=> reaches root
  //     pathDirection("foo/../..") //=> above root
  //     pathDirection("foo/../../foo/bar/baz") //=> above root
  _PathDirection _pathDirection(String path, int index) {
    var depth = 0;
    var reachedRoot = false;
    var i = index;
    while (i < path.length) {
      // Ignore initial separators or doubled separators.
      while (i < path.length && style.isSeparator(path.codeUnitAt(i))) {
        i++;
      }

      // If we're at the end, stop.
      if (i == path.length) break;

      // Move through the path component to the next separator.
      final start = i;
      while (i < path.length && !style.isSeparator(path.codeUnitAt(i))) {
        i++;
      }

      // See if the path component is ".", "..", or a name.
      if (i - start == 1 && path.codeUnitAt(start) == chars.period) {
        // Don't change the depth.
      } else if (i - start == 2 &&
          path.codeUnitAt(start) == chars.period &&
          path.codeUnitAt(start + 1) == chars.period) {
        // ".." backs out a directory.
        depth--;

        // If we work back beyond the root, stop.
        if (depth < 0) break;

        // Record that we reached the root so we don't return
        // [_PathDirection.belowRoot].
        if (depth == 0) reachedRoot = true;
      } else {
        // Step inside a directory.
        depth++;
      }

      // If we're at the end, stop.
      if (i == path.length) break;

      // Move past the separator.
      i++;
    }

    if (depth < 0) return _PathDirection.aboveRoot;
    if (depth == 0) return _PathDirection.atRoot;
    if (reachedRoot) return _PathDirection.reachesRoot;
    return _PathDirection.belowRoot;
  }

  /// Returns a hash code for [path] that matches the semantics of [equals].
  ///
  /// Note that the same path may have different hash codes in different
  /// [Context]s.
  int hash(String path) {
    // Make [path] absolute to ensure that equivalent relative and absolute
    // paths have the same hash code.
    path = absolute(path);

    final result = _hashFast(path);
    if (result != null) return result;

    final parsed = _parse(path);
    parsed.normalize();
    return _hashFast(parsed.toString())!;
  }

  /// An optimized implementation of [hash] that doesn't handle internal `..`
  /// components.
  ///
  /// This will handle `..` components that appear at the beginning of the path.
  int? _hashFast(String path) {
    var hash = 4603;
    var beginning = true;
    var wasSeparator = true;
    for (var i = 0; i < path.length; i++) {
      final codeUnit = style.canonicalizeCodeUnit(path.codeUnitAt(i));

      // Take advantage of the fact that collisions are allowed to ignore
      // separators entirely. This lets us avoid worrying about cases like
      // multiple trailing slashes.
      if (style.isSeparator(codeUnit)) {
        wasSeparator = true;
        continue;
      }

      if (codeUnit == chars.period && wasSeparator) {
        // If a dot comes after a separator, it may be a directory traversal
        // operator. To check that, we need to know if it's followed by either
        // "/" or "./". Otherwise, it's just a normal character.
        //
        //     hash("foo/./bar") == hash("foo/bar")

        // We've hit "/." at the end of the path, which we can ignore.
        if (i + 1 == path.length) break;

        final next = path.codeUnitAt(i + 1);

        // We can just ignore "/./", since they don't affect the semantics of
        // the path.
        if (style.isSeparator(next)) continue;

        // If the path ends with "/.." or contains "/../", we need to
        // canonicalize it before we can hash it. We make an exception for ".."s
        // at the beginning of the path, since those may appear even in a
        // canonicalized path.
        if (!beginning &&
            next == chars.period &&
            (i + 2 == path.length ||
                style.isSeparator(path.codeUnitAt(i + 2)))) {
          return null;
        }
      }

      // Make sure [hash] stays under 32 bits even after multiplication.
      hash &= 0x3FFFFFF;
      hash *= 33;
      hash ^= codeUnit;
      wasSeparator = false;
      beginning = false;
    }
    return hash;
  }

  /// Removes a trailing extension from the last part of [path].
  ///
  ///     context.withoutExtension('path/to/foo.dart'); // -> 'path/to/foo'
  String withoutExtension(String path) {
    final parsed = _parse(path);

    for (var i = parsed.parts.length - 1; i >= 0; i--) {
      if (parsed.parts[i].isNotEmpty) {
        parsed.parts[i] = parsed.basenameWithoutExtension;
        break;
      }
    }

    return parsed.toString();
  }

  /// Returns [path] with the trailing extension set to [extension].
  ///
  /// If [path] doesn't have a trailing extension, this just adds [extension] to
  /// the end.
  ///
  ///     context.setExtension('path/to/foo.dart', '.js')
  ///       // -> 'path/to/foo.js'
  ///     context.setExtension('path/to/foo.dart.js', '.map')
  ///       // -> 'path/to/foo.dart.map'
  ///     context.setExtension('path/to/foo', '.js')
  ///       // -> 'path/to/foo.js'
  String setExtension(String path, String extension) =>
      withoutExtension(path) + extension;

  /// Returns the path represented by [uri], which may be a [String] or a [Uri].
  ///
  /// For POSIX and Windows styles, [uri] must be a `file:` URI. For the URL
  /// style, this will just convert [uri] to a string.
  ///
  ///     // POSIX
  ///     context.fromUri('file:///path/to/foo')
  ///       // -> '/path/to/foo'
  ///
  ///     // Windows
  ///     context.fromUri('file:///C:/path/to/foo')
  ///       // -> r'C:\path\to\foo'
  ///
  ///     // URL
  ///     context.fromUri('https://dart.dev/path/to/foo')
  ///       // -> 'https://dart.dev/path/to/foo'
  ///
  /// If [uri] is relative, a relative path will be returned.
  ///
  ///     path.fromUri('path/to/foo'); // -> 'path/to/foo'
  String fromUri(Object? uri) => style.pathFromUri(_parseUri(uri!));

  /// Returns the URI that represents [path].
  ///
  /// For POSIX and Windows styles, this will return a `file:` URI. For the URL
  /// style, this will just convert [path] to a [Uri].
  ///
  ///     // POSIX
  ///     context.toUri('/path/to/foo')
  ///       // -> Uri.parse('file:///path/to/foo')
  ///
  ///     // Windows
  ///     context.toUri(r'C:\path\to\foo')
  ///       // -> Uri.parse('file:///C:/path/to/foo')
  ///
  ///     // URL
  ///     context.toUri('https://dart.dev/path/to/foo')
  ///       // -> Uri.parse('https://dart.dev/path/to/foo')
  Uri toUri(String path) {
    if (isRelative(path)) {
      return style.relativePathToUri(path);
    } else {
      return style.absolutePathToUri(join(current, path));
    }
  }

  /// Returns a terse, human-readable representation of [uri].
  ///
  /// [uri] can be a [String] or a [Uri]. If it can be made relative to the
  /// current working directory, that's done. Otherwise, it's returned as-is.
  /// This gracefully handles non-`file:` URIs for [Style.posix] and
  /// [Style.windows].
  ///
  /// The returned value is meant for human consumption, and may be either URI-
  /// or path-formatted.
  ///
  ///     // POSIX
  ///     var context = Context(current: '/root/path');
  ///     context.prettyUri('file:///root/path/a/b.dart'); // -> 'a/b.dart'
  ///     context.prettyUri('https://dart.dev/'); // -> 'https://dart.dev'
  ///
  ///     // Windows
  ///     var context = Context(current: r'C:\root\path');
  ///     context.prettyUri('file:///C:/root/path/a/b.dart'); // -> r'a\b.dart'
  ///     context.prettyUri('https://dart.dev/'); // -> 'https://dart.dev'
  ///
  ///     // URL
  ///     var context = Context(current: 'https://dart.dev/root/path');
  ///     context.prettyUri('https://dart.dev/root/path/a/b.dart');
  ///         // -> r'a/b.dart'
  ///     context.prettyUri('file:///root/path'); // -> 'file:///root/path'
  String prettyUri(Object? uri) {
    final typedUri = _parseUri(uri!);
    if (typedUri.scheme == 'file' && style == Style.url) {
      return typedUri.toString();
    } else if (typedUri.scheme != 'file' &&
        typedUri.scheme != '' &&
        style != Style.url) {
      return typedUri.toString();
    }

    final path = normalize(fromUri(typedUri));
    final rel = relative(path);

    // Only return a relative path if it's actually shorter than the absolute
    // path. This avoids ugly things like long "../" chains to get to the root
    // and then go back down.
    return split(rel).length > split(path).length ? path : rel;
  }

  ParsedPath _parse(String path) => ParsedPath.parse(path, style);
}

/// Parses argument if it's a [String] or returns it intact if it's a [Uri].
///
/// Throws an [ArgumentError] otherwise.
Uri _parseUri(Object uri) {
  if (uri is String) return Uri.parse(uri);
  if (uri is Uri) return uri;
  throw ArgumentError.value(uri, 'uri', 'Value must be a String or a Uri');
}

/// Validates that there are no non-null arguments following a null one and
/// throws an appropriate [ArgumentError] on failure.
void _validateArgList(String method, List<String?> args) {
  for (var i = 1; i < args.length; i++) {
    // Ignore nulls hanging off the end.
    if (args[i] == null || args[i - 1] != null) continue;

    int numArgs;
    for (numArgs = args.length; numArgs >= 1; numArgs--) {
      if (args[numArgs - 1] != null) break;
    }

    // Show the arguments.
    final message = StringBuffer();
    message.write('$method(');
    message.write(args
        .take(numArgs)
        .map((arg) => arg == null ? 'null' : '"$arg"')
        .join(', '));
    message.write('): part ${i - 1} was null, but part $i was not.');
    throw ArgumentError(message.toString());
  }
}

/// An enum of possible return values for [Context._pathDirection].
class _PathDirection {
  /// The path contains enough ".." components that at some point it reaches
  /// above its original root.
  ///
  /// Note that this applies even if the path ends beneath its original root. It
  /// takes precendence over any other return values that may apple.
  static const aboveRoot = _PathDirection('above root');

  /// The path contains enough ".." components that it ends at its original
  /// root.
  static const atRoot = _PathDirection('at root');

  /// The path contains enough ".." components that at some point it reaches its
  /// original root, but it ends beneath that root.
  static const reachesRoot = _PathDirection('reaches root');

  /// The path never reaches to or above its original root.
  static const belowRoot = _PathDirection('below root');

  final String name;

  const _PathDirection(this.name);

  @override
  String toString() => name;
}

/// An enum of possible return values for [Context._isWithinOrEquals].
class _PathRelation {
  /// The first path is a proper parent of the second.
  ///
  /// For example, `foo` is a proper parent of `foo/bar`, but not of `foo`.
  static const within = _PathRelation('within');

  /// The two paths are equivalent.
  ///
  /// For example, `foo//bar` is equivalent to `foo/bar`.
  static const equal = _PathRelation('equal');

  /// The first path is neither a parent of nor equal to the second.
  static const different = _PathRelation('different');

  /// We couldn't quickly determine any information about the paths'
  /// relationship to each other.
  ///
  /// Only returned by [Context._isWithinOrEqualsFast].
  static const inconclusive = _PathRelation('inconclusive');

  final String name;

  const _PathRelation(this.name);

  @override
  String toString() => name;
}

// File: C:\MyDartProjects\eloquent\lib\src\pdo\postgres\dependencies\path\src\internal_style.dart


import 'context.dart';
import 'style.dart';

/// The internal interface for the [Style] type.
///
/// Users should be able to pass around instances of [Style] like an enum, but
/// the members that [Context] uses should be hidden from them. Those members
/// are defined on this class instead.
abstract class InternalStyle extends Style {
  /// The default path separator for this style.
  ///
  /// On POSIX, this is `/`. On Windows, it's `\`.
  @override
  String get separator;

  /// Returns whether [path] contains a separator.
  bool containsSeparator(String path);

  /// Returns whether [codeUnit] is the character code of a separator.
  bool isSeparator(int codeUnit);

  /// Returns whether this path component needs a separator after it.
  ///
  /// Windows and POSIX styles just need separators when the previous component
  /// doesn't already end in a separator, but the URL always needs to place a
  /// separator between the root and the first component, even if the root
  /// already ends in a separator character. For example, to join "file://" and
  /// "usr", an additional "/" is needed (making "file:///usr").
  bool needsSeparator(String path);

  /// Returns the number of characters of the root part.
  ///
  /// Returns 0 if the path is relative and 1 if the path is root-relative.
  ///
  /// If [withDrive] is `true`, this should include the drive letter for `file:`
  /// URLs. Non-URL styles may ignore the parameter.
  int rootLength(String path, {bool withDrive = false});

  /// Gets the root prefix of [path] if path is absolute. If [path] is relative,
  /// returns `null`.
  @override
  String? getRoot(String path) {
    final length = rootLength(path);
    if (length > 0) return path.substring(0, length);
    return isRootRelative(path) ? path[0] : null;
  }

  /// Returns whether [path] is root-relative.
  ///
  /// If [path] is relative or absolute and not root-relative, returns `false`.
  bool isRootRelative(String path);

  /// Returns the path represented by [uri] in this style.
  @override
  String pathFromUri(Uri uri);

  /// Returns the URI that represents a relative path.
  @override
  Uri relativePathToUri(String path) {
    if (path.isEmpty) return Uri();
    final segments = context.split(path);

    // Ensure that a trailing slash in the path produces a trailing slash in the
    // URL.
    if (isSeparator(path.codeUnitAt(path.length - 1))) segments.add('');
    return Uri(pathSegments: segments);
  }

  /// Returns the URI that represents [path], which is assumed to be absolute.
  @override
  Uri absolutePathToUri(String path);

  /// Returns whether [codeUnit1] and [codeUnit2] are considered equivalent for
  /// this style.
  bool codeUnitsEqual(int codeUnit1, int codeUnit2) => codeUnit1 == codeUnit2;

  /// Returns whether [path1] and [path2] are equivalent.
  ///
  /// This only needs to handle character-by-character comparison; it can assume
  /// the paths are normalized and contain no `..` components.
  bool pathsEqual(String path1, String path2) => path1 == path2;

  int canonicalizeCodeUnit(int codeUnit) => codeUnit;

  String canonicalizePart(String part) => part;
}

// File: C:\MyDartProjects\eloquent\lib\src\pdo\postgres\dependencies\path\src\parsed_path.dart


import 'internal_style.dart';
import 'style.dart';

class ParsedPath {
  /// The [InternalStyle] that was used to parse this path.
  InternalStyle style;

  /// The absolute root portion of the path, or `null` if the path is relative.
  /// On POSIX systems, this will be `null` or "/". On Windows, it can be
  /// `null`, "//" for a UNC path, or something like "C:\" for paths with drive
  /// letters.
  String? root;

  /// Whether this path is root-relative.
  ///
  /// See `Context.isRootRelative`.
  bool isRootRelative;

  /// The path-separated parts of the path. All but the last will be
  /// directories.
  List<String> parts;

  /// The path separators preceding each part.
  ///
  /// The first one will be an empty string unless the root requires a separator
  /// between it and the path. The last one will be an empty string unless the
  /// path ends with a trailing separator.
  List<String> separators;

  /// The file extension of the last non-empty part, or "" if it doesn't have
  /// one.
  String extension([int level = 1]) => _splitExtension(level)[1];

  /// `true` if this is an absolute path.
  bool get isAbsolute => root != null;

  factory ParsedPath.parse(String path, InternalStyle style) {
    // Remove the root prefix, if any.
    final root = style.getRoot(path);
    final isRootRelative = style.isRootRelative(path);
    if (root != null) path = path.substring(root.length);

    // Split the parts on path separators.
    final parts = <String>[];
    final separators = <String>[];

    var start = 0;

    if (path.isNotEmpty && style.isSeparator(path.codeUnitAt(0))) {
      separators.add(path[0]);
      start = 1;
    } else {
      separators.add('');
    }

    for (var i = start; i < path.length; i++) {
      if (style.isSeparator(path.codeUnitAt(i))) {
        parts.add(path.substring(start, i));
        separators.add(path[i]);
        start = i + 1;
      }
    }

    // Add the final part, if any.
    if (start < path.length) {
      parts.add(path.substring(start));
      separators.add('');
    }

    return ParsedPath._(style, root, isRootRelative, parts, separators);
  }

  ParsedPath._(
      this.style, this.root, this.isRootRelative, this.parts, this.separators);

  String get basename {
    final copy = clone();
    copy.removeTrailingSeparators();
    if (copy.parts.isEmpty) return root ?? '';
    return copy.parts.last;
  }

  String get basenameWithoutExtension => _splitExtension()[0];

  bool get hasTrailingSeparator =>
      parts.isNotEmpty && (parts.last == '' || separators.last != '');

  void removeTrailingSeparators() {
    while (parts.isNotEmpty && parts.last == '') {
      parts.removeLast();
      separators.removeLast();
    }
    if (separators.isNotEmpty) separators[separators.length - 1] = '';
  }

  void normalize({bool canonicalize = false}) {
    // Handle '.', '..', and empty parts.
    var leadingDoubles = 0;
    final newParts = <String>[];
    for (var part in parts) {
      if (part == '.' || part == '') {
        // Do nothing. Ignore it.
      } else if (part == '..') {
        // Pop the last part off.
        if (newParts.isNotEmpty) {
          newParts.removeLast();
        } else {
          // Backed out past the beginning, so preserve the "..".
          leadingDoubles++;
        }
      } else {
        newParts.add(canonicalize ? style.canonicalizePart(part) : part);
      }
    }

    // A relative path can back out from the start directory.
    if (!isAbsolute) {
      newParts.insertAll(0, List.filled(leadingDoubles, '..'));
    }

    // If we collapsed down to nothing, do ".".
    if (newParts.isEmpty && !isAbsolute) {
      newParts.add('.');
    }

    // Canonicalize separators.
    parts = newParts;
    separators =
        List.filled(newParts.length + 1, style.separator, growable: true);
    if (!isAbsolute || newParts.isEmpty || !style.needsSeparator(root!)) {
      separators[0] = '';
    }

    // Normalize the Windows root if needed.
    if (root != null && style == Style.windows) {
      if (canonicalize) root = root!.toLowerCase();
      root = root!.replaceAll('/', '\\');
    }
    removeTrailingSeparators();
  }

  @override
  String toString() {
    final builder = StringBuffer();
    if (root != null) builder.write(root);
    for (var i = 0; i < parts.length; i++) {
      builder.write(separators[i]);
      builder.write(parts[i]);
    }
    builder.write(separators.last);

    return builder.toString();
  }

  /// Returns k-th last index of the `character` in the `path`.
  ///
  /// If `k` exceeds the count of `character`s in `path`, the left most index
  /// of the `character` is returned.
  int _kthLastIndexOf(String path, String character, int k) {
    var count = 0, leftMostIndexedCharacter = 0;
    for (var index = path.length - 1; index >= 0; --index) {
      if (path[index] == character) {
        leftMostIndexedCharacter = index;
        ++count;
        if (count == k) {
          return index;
        }
      }
    }
    return leftMostIndexedCharacter;
  }

  /// Splits the last non-empty part of the path into a `[basename, extension]`
  /// pair.
  ///
  /// Takes an optional parameter `level` which makes possible to return
  /// multiple extensions having `level` number of dots. If `level` exceeds the
  /// number of dots, the path is split at the first most dot. The value of
  /// `level` must be greater than 0, else `RangeError` is thrown.
  ///
  /// Returns a two-element list. The first is the name of the file without any
  /// extension. The second is the extension or "" if it has none.
  List<String> _splitExtension([int level = 1]) {
    if (level <= 0) {
      throw RangeError.value(
          level, 'level', "level's value must be greater than 0");
    }

    final file =
        parts.cast<String?>().lastWhere((p) => p != '', orElse: () => null);

    if (file == null) return ['', ''];
    if (file == '..') return ['..', ''];

    final lastDot = _kthLastIndexOf(file, '.', level);

    // If there is no dot, or it's the first character, like '.bashrc', it
    // doesn't count.
    if (lastDot <= 0) return [file, ''];

    return [file.substring(0, lastDot), file.substring(lastDot)];
  }

  ParsedPath clone() => ParsedPath._(
      style, root, isRootRelative, List.from(parts), List.from(separators));
}

// File: C:\MyDartProjects\eloquent\lib\src\pdo\postgres\dependencies\path\src\path_exception.dart

/// An exception class that's thrown when a path operation is unable to be
/// computed accurately.
class PathException implements Exception {
  String message;

  PathException(this.message);

  @override
  String toString() => 'PathException: $message';
}

// File: C:\MyDartProjects\eloquent\lib\src\pdo\postgres\dependencies\path\src\path_map.dart


import 'dart:collection';

import '../path.dart' as p;

/// A map whose keys are paths, compared using [p.equals] and [p.hash].
class PathMap<V> extends MapView<String?, V> {
  /// Creates an empty [PathMap] whose keys are compared using `context.equals`
  /// and `context.hash`.
  ///
  /// The [context] defaults to the current path context.
  PathMap({p.Context? context}) : super(_create(context));

  /// Creates a [PathMap] with the same keys and values as [other] whose keys
  /// are compared using `context.equals` and `context.hash`.
  ///
  /// The [context] defaults to the current path context. If multiple keys in
  /// [other] represent the same logical path, the last key's value will be
  /// used.
  PathMap.of(Map<String, V> other, {p.Context? context})
      : super(_create(context)..addAll(other));

  /// Creates a map that uses [context] for equality and hashing.
  static Map<String?, V> _create<V>(p.Context? context) {
    context ??= p.context;
    return LinkedHashMap(
        equals: (path1, path2) {
          if (path1 == null) return path2 == null;
          if (path2 == null) return false;
          return context!.equals(path1, path2);
        },
        hashCode: (path) => path == null ? 0 : context!.hash(path),
        isValidKey: (path) => path is String || path == null);
  }
}

// File: C:\MyDartProjects\eloquent\lib\src\pdo\postgres\dependencies\path\src\path_set.dart


import 'dart:collection';

import '../path.dart' as p;

/// A set containing paths, compared using [p.equals] and [p.hash].
class PathSet extends IterableBase<String?> implements Set<String?> {
  /// The set to which we forward implementation methods.
  final Set<String?> _inner;

  /// Creates an empty [PathSet] whose contents are compared using
  /// `context.equals` and `context.hash`.
  ///
  /// The [context] defaults to the current path context.
  PathSet({p.Context? context}) : _inner = _create(context);

  /// Creates a [PathSet] with the same contents as [other] whose elements are
  /// compared using `context.equals` and `context.hash`.
  ///
  /// The [context] defaults to the current path context. If multiple elements
  /// in [other] represent the same logical path, the first value will be
  /// used.
  PathSet.of(Iterable<String> other, {p.Context? context})
      : _inner = _create(context)..addAll(other);

  /// Creates a set that uses [context] for equality and hashing.
  static Set<String?> _create(p.Context? context) {
    context ??= p.context;
    return LinkedHashSet(
        equals: (path1, path2) {
          if (path1 == null) return path2 == null;
          if (path2 == null) return false;
          return context!.equals(path1, path2);
        },
        hashCode: (path) => path == null ? 0 : context!.hash(path),
        isValidKey: (path) => path is String || path == null);
  }

  // Normally we'd use DelegatingSetView from the collection package to
  // implement these, but we want to avoid adding dependencies from path because
  // it's so widely used that even brief version skew can be very painful.

  @override
  Iterator<String?> get iterator => _inner.iterator;

  @override
  int get length => _inner.length;

  @override
  bool add(String? value) => _inner.add(value);

  @override
  void addAll(Iterable<String?> elements) => _inner.addAll(elements);

  @override
  Set<T> cast<T>() => _inner.cast<T>();

  @override
  void clear() => _inner.clear();

  @override
  bool contains(Object? element) => _inner.contains(element);

  @override
  bool containsAll(Iterable<Object?> other) => _inner.containsAll(other);

  @override
  Set<String?> difference(Set<Object?> other) => _inner.difference(other);

  @override
  Set<String?> intersection(Set<Object?> other) => _inner.intersection(other);

  @override
  String? lookup(Object? element) => _inner.lookup(element);

  @override
  bool remove(Object? value) => _inner.remove(value);

  @override
  void removeAll(Iterable<Object?> elements) => _inner.removeAll(elements);

  @override
  void removeWhere(bool Function(String?) test) => _inner.removeWhere(test);

  @override
  void retainAll(Iterable<Object?> elements) => _inner.retainAll(elements);

  @override
  void retainWhere(bool Function(String?) test) => _inner.retainWhere(test);

  @override
  Set<String?> union(Set<String?> other) => _inner.union(other);

  @override
  Set<String?> toSet() => _inner.toSet();
}

// File: C:\MyDartProjects\eloquent\lib\src\pdo\postgres\dependencies\path\src\style\posix.dart


import '../characters.dart' as chars;
import '../internal_style.dart';
import '../parsed_path.dart';

/// The style for POSIX paths.
class PosixStyle extends InternalStyle {
  @override
  final name = 'posix';
  @override
  final separator = '/';
  final separators = const ['/'];

  // Deprecated properties.

  @override
  final separatorPattern = RegExp(r'/');
  @override
  final needsSeparatorPattern = RegExp(r'[^/]$');
  @override
  final rootPattern = RegExp(r'^/');
  @override
  Pattern? get relativeRootPattern => null;

  @override
  bool containsSeparator(String path) => path.contains('/');

  @override
  bool isSeparator(int codeUnit) => codeUnit == chars.slash;

  @override
  bool needsSeparator(String path) =>
      path.isNotEmpty && !isSeparator(path.codeUnitAt(path.length - 1));

  @override
  int rootLength(String path, {bool withDrive = false}) {
    if (path.isNotEmpty && isSeparator(path.codeUnitAt(0))) return 1;
    return 0;
  }

  @override
  bool isRootRelative(String path) => false;

  @override
  String? getRelativeRoot(String path) => null;

  @override
  String pathFromUri(Uri uri) {
    if (uri.scheme == '' || uri.scheme == 'file') {
      return Uri.decodeComponent(uri.path);
    }
    throw ArgumentError("Uri $uri must have scheme 'file:'.");
  }

  @override
  Uri absolutePathToUri(String path) {
    final parsed = ParsedPath.parse(path, this);
    if (parsed.parts.isEmpty) {
      // If the path is a bare root (e.g. "/"), [components] will
      // currently be empty. We add two empty components so the URL constructor
      // produces "file:///", with a trailing slash.
      parsed.parts.addAll(['', '']);
    } else if (parsed.hasTrailingSeparator) {
      // If the path has a trailing slash, add a single empty component so the
      // URI has a trailing slash as well.
      parsed.parts.add('');
    }

    return Uri(scheme: 'file', pathSegments: parsed.parts);
  }
}

// File: C:\MyDartProjects\eloquent\lib\src\pdo\postgres\dependencies\path\src\style\url.dart


import '../characters.dart' as chars;
import '../internal_style.dart';
import '../utils.dart';

/// The style for URL paths.
class UrlStyle extends InternalStyle {
  @override
  final name = 'url';
  @override
  final separator = '/';
  final separators = const ['/'];

  // Deprecated properties.

  @override
  final separatorPattern = RegExp(r'/');
  @override
  final needsSeparatorPattern = RegExp(r'(^[a-zA-Z][-+.a-zA-Z\d]*://|[^/])$');
  @override
  final rootPattern = RegExp(r'[a-zA-Z][-+.a-zA-Z\d]*://[^/]*');
  @override
  final relativeRootPattern = RegExp(r'^/');

  @override
  bool containsSeparator(String path) => path.contains('/');

  @override
  bool isSeparator(int codeUnit) => codeUnit == chars.slash;

  @override
  bool needsSeparator(String path) {
    if (path.isEmpty) return false;

    // A URL that doesn't end in "/" always needs a separator.
    if (!isSeparator(path.codeUnitAt(path.length - 1))) return true;

    // A URI that's just "scheme://" needs an extra separator, despite ending
    // with "/".
    return path.endsWith('://') && rootLength(path) == path.length;
  }

  @override
  int rootLength(String path, {bool withDrive = false}) {
    if (path.isEmpty) return 0;
    if (isSeparator(path.codeUnitAt(0))) return 1;

    for (var i = 0; i < path.length; i++) {
      final codeUnit = path.codeUnitAt(i);
      if (isSeparator(codeUnit)) return 0;
      if (codeUnit == chars.colon) {
        if (i == 0) return 0;

        // The root part is up until the next '/', or the full path. Skip ':'
        // (and '//' if it exists) and search for '/' after that.
        if (path.startsWith('//', i + 1)) i += 3;
        final index = path.indexOf('/', i);
        if (index <= 0) return path.length;

        // file: URLs sometimes consider Windows drive letters part of the root.
        // See https://url.spec.whatwg.org/#file-slash-state.
        if (!withDrive || path.length < index + 3) return index;
        if (!path.startsWith('file://')) return index;
        return driveLetterEnd(path, index + 1) ?? index;
      }
    }

    return 0;
  }

  @override
  bool isRootRelative(String path) =>
      path.isNotEmpty && isSeparator(path.codeUnitAt(0));

  @override
  String? getRelativeRoot(String path) => isRootRelative(path) ? '/' : null;

  @override
  String pathFromUri(Uri uri) => uri.toString();

  @override
  Uri relativePathToUri(String path) => Uri.parse(path);
  @override
  Uri absolutePathToUri(String path) => Uri.parse(path);
}

// File: C:\MyDartProjects\eloquent\lib\src\pdo\postgres\dependencies\path\src\style\windows.dart


import '../characters.dart' as chars;
import '../internal_style.dart';
import '../parsed_path.dart';
import '../utils.dart';

// `0b100000` can be bitwise-ORed with uppercase ASCII letters to get their
// lowercase equivalents.
const _asciiCaseBit = 0x20;

/// The style for Windows paths.
class WindowsStyle extends InternalStyle {
  @override
  final name = 'windows';
  @override
  final separator = '\\';
  final separators = const ['/', '\\'];

  // Deprecated properties.

  @override
  final separatorPattern = RegExp(r'[/\\]');
  @override
  final needsSeparatorPattern = RegExp(r'[^/\\]$');
  @override
  final rootPattern = RegExp(r'^(\\\\[^\\]+\\[^\\/]+|[a-zA-Z]:[/\\])');
  @override
  final relativeRootPattern = RegExp(r'^[/\\](?![/\\])');

  @override
  bool containsSeparator(String path) => path.contains('/');

  @override
  bool isSeparator(int codeUnit) =>
      codeUnit == chars.slash || codeUnit == chars.backslash;

  @override
  bool needsSeparator(String path) {
    if (path.isEmpty) return false;
    return !isSeparator(path.codeUnitAt(path.length - 1));
  }

  @override
  int rootLength(String path, {bool withDrive = false}) {
    if (path.isEmpty) return 0;
    if (path.codeUnitAt(0) == chars.slash) return 1;
    if (path.codeUnitAt(0) == chars.backslash) {
      if (path.length < 2 || path.codeUnitAt(1) != chars.backslash) return 1;
      // The path is a network share. Search for up to two '\'s, as they are
      // the server and share - and part of the root part.
      var index = path.indexOf('\\', 2);
      if (index > 0) {
        index = path.indexOf('\\', index + 1);
        if (index > 0) return index;
      }
      return path.length;
    }
    // If the path is of the form 'C:/' or 'C:\', with C being any letter, it's
    // a root part.
    if (path.length < 3) return 0;
    // Check for the letter.
    if (!isAlphabetic(path.codeUnitAt(0))) return 0;
    // Check for the ':'.
    if (path.codeUnitAt(1) != chars.colon) return 0;
    // Check for either '/' or '\'.
    if (!isSeparator(path.codeUnitAt(2))) return 0;
    return 3;
  }

  @override
  bool isRootRelative(String path) => rootLength(path) == 1;

  @override
  String? getRelativeRoot(String path) {
    final length = rootLength(path);
    if (length == 1) return path[0];
    return null;
  }

  @override
  String pathFromUri(Uri uri) {
    if (uri.scheme != '' && uri.scheme != 'file') {
      throw ArgumentError("Uri $uri must have scheme 'file:'.");
    }

    var path = uri.path;
    if (uri.host == '') {
      // Drive-letter paths look like "file:///C:/path/to/file". The
      // replaceFirst removes the extra initial slash. Otherwise, leave the
      // slash to match IE's interpretation of "/foo" as a root-relative path.
      if (path.length >= 3 && path.startsWith('/') && isDriveLetter(path, 1)) {
        path = path.replaceFirst('/', '');
      }
    } else {
      // Network paths look like "file://hostname/path/to/file".
      path = '\\\\${uri.host}$path';
    }
    return Uri.decodeComponent(path.replaceAll('/', '\\'));
  }

  @override
  Uri absolutePathToUri(String path) {
    final parsed = ParsedPath.parse(path, this);
    if (parsed.root!.startsWith(r'\\')) {
      // Network paths become "file://server/share/path/to/file".

      // The root is of the form "\\server\share". We want "server" to be the
      // URI host, and "share" to be the first element of the path.
      final rootParts = parsed.root!.split('\\').where((part) => part != '');
      parsed.parts.insert(0, rootParts.last);

      if (parsed.hasTrailingSeparator) {
        // If the path has a trailing slash, add a single empty component so the
        // URI has a trailing slash as well.
        parsed.parts.add('');
      }

      return Uri(
          scheme: 'file', host: rootParts.first, pathSegments: parsed.parts);
    } else {
      // Drive-letter paths become "file:///C:/path/to/file".

      // If the path is a bare root (e.g. "C:\"), [parsed.parts] will currently
      // be empty. We add an empty component so the URL constructor produces
      // "file:///C:/", with a trailing slash. We also add an empty component if
      // the URL otherwise has a trailing slash.
      if (parsed.parts.isEmpty || parsed.hasTrailingSeparator) {
        parsed.parts.add('');
      }

      // Get rid of the trailing "\" in "C:\" because the URI constructor will
      // add a separator on its own.
      parsed.parts
          .insert(0, parsed.root!.replaceAll('/', '').replaceAll('\\', ''));

      return Uri(scheme: 'file', pathSegments: parsed.parts);
    }
  }

  @override
  bool codeUnitsEqual(int codeUnit1, int codeUnit2) {
    if (codeUnit1 == codeUnit2) return true;

    /// Forward slashes and backslashes are equivalent on Windows.
    if (codeUnit1 == chars.slash) return codeUnit2 == chars.backslash;
    if (codeUnit1 == chars.backslash) return codeUnit2 == chars.slash;

    // If this check fails, the code units are definitely different. If it
    // succeeds *and* either codeUnit is an ASCII letter, they're equivalent.
    if (codeUnit1 ^ codeUnit2 != _asciiCaseBit) return false;

    // Now we just need to verify that one of the code units is an ASCII letter.
    final upperCase1 = codeUnit1 | _asciiCaseBit;
    return upperCase1 >= chars.lowerA && upperCase1 <= chars.lowerZ;
  }

  @override
  bool pathsEqual(String path1, String path2) {
    if (identical(path1, path2)) return true;
    if (path1.length != path2.length) return false;
    for (var i = 0; i < path1.length; i++) {
      if (!codeUnitsEqual(path1.codeUnitAt(i), path2.codeUnitAt(i))) {
        return false;
      }
    }
    return true;
  }

  @override
  int canonicalizeCodeUnit(int codeUnit) {
    if (codeUnit == chars.slash) return chars.backslash;
    if (codeUnit < chars.upperA) return codeUnit;
    if (codeUnit > chars.upperZ) return codeUnit;
    return codeUnit | _asciiCaseBit;
  }

  @override
  String canonicalizePart(String part) => part.toLowerCase();
}

// File: C:\MyDartProjects\eloquent\lib\src\pdo\postgres\dependencies\path\src\style.dart


import 'context.dart';
import 'style/posix.dart';
import 'style/url.dart';
import 'style/windows.dart';

/// An enum type describing a "flavor" of path.
abstract class Style {
  /// POSIX-style paths use "/" (forward slash) as separators. Absolute paths
  /// start with "/". Used by UNIX, Linux, Mac OS X, and others.
  static final Style posix = PosixStyle();

  /// Windows paths use `\` (backslash) as separators. Absolute paths start with
  /// a drive letter followed by a colon (example, `C:`) or two backslashes
  /// (`\\`) for UNC paths.
  static final Style windows = WindowsStyle();

  /// URLs aren't filesystem paths, but they're supported to make it easier to
  /// manipulate URL paths in the browser.
  ///
  /// URLs use "/" (forward slash) as separators. Absolute paths either start
  /// with a protocol and optional hostname (e.g. `https://dart.dev`,
  /// `file://`) or with "/".
  static final Style url = UrlStyle();

  /// The style of the host platform.
  ///
  /// When running on the command line, this will be [windows] or [posix] based
  /// on the host operating system. On a browser, this will be [url].
  static final Style platform = _getPlatformStyle();

  /// Gets the type of the host platform.
  static Style _getPlatformStyle() {
    // If we're running a Dart file in the browser from a `file:` URI,
    // [Uri.base] will point to a file. If we're running on the standalone,
    // it will point to a directory. We can use that fact to determine which
    // style to use.
    if (Uri.base.scheme != 'file') return Style.url;
    if (!Uri.base.path.endsWith('/')) return Style.url;
    if (Uri(path: 'a/b').toFilePath() == 'a\\b') return Style.windows;
    return Style.posix;
  }

  /// The name of this path style. Will be "posix" or "windows".
  String get name;

  /// A [Context] that uses this style.
  Context get context => Context(style: this);

  @Deprecated('Most Style members will be removed in path 2.0.')
  String get separator;

  @Deprecated('Most Style members will be removed in path 2.0.')
  Pattern get separatorPattern;

  @Deprecated('Most Style members will be removed in path 2.0.')
  Pattern get needsSeparatorPattern;

  @Deprecated('Most Style members will be removed in path 2.0.')
  Pattern get rootPattern;

  @Deprecated('Most Style members will be removed in path 2.0.')
  Pattern? get relativeRootPattern;

  @Deprecated('Most style members will be removed in path 2.0.')
  String? getRoot(String path);

  @Deprecated('Most style members will be removed in path 2.0.')
  String? getRelativeRoot(String path);

  @Deprecated('Most style members will be removed in path 2.0.')
  String pathFromUri(Uri uri);

  @Deprecated('Most style members will be removed in path 2.0.')
  Uri relativePathToUri(String path);

  @Deprecated('Most style members will be removed in path 2.0.')
  Uri absolutePathToUri(String path);

  @override
  String toString() => name;
}

// File: C:\MyDartProjects\eloquent\lib\src\pdo\postgres\dependencies\path\src\utils.dart


import 'characters.dart' as chars;

/// Returns whether [char] is the code for an ASCII letter (uppercase or
/// lowercase).
bool isAlphabetic(int char) =>
    (char >= chars.upperA && char <= chars.upperZ) ||
    (char >= chars.lowerA && char <= chars.lowerZ);

/// Returns whether [char] is the code for an ASCII digit.
bool isNumeric(int char) => char >= chars.zero && char <= chars.nine;

/// Returns whether [path] has a URL-formatted Windows drive letter beginning at
/// [index].
bool isDriveLetter(String path, int index) =>
    driveLetterEnd(path, index) != null;

/// Returns the index of the first character after the drive letter or a
/// URL-formatted path, or `null` if [index] is not the start of a drive letter.
/// A valid drive letter must be followed by a colon and then either a `/` or
/// the end of string.
///
/// ```
/// d:/abc => 3
/// d:/    => 3
/// d:     => 2
/// d      => null
/// ```
int? driveLetterEnd(String path, int index) {
  if (path.length < index + 2) return null;
  if (!isAlphabetic(path.codeUnitAt(index))) return null;
  if (path.codeUnitAt(index + 1) != chars.colon) {
    // If not a raw colon, check for escaped colon
    if (path.length < index + 4) return null;
    if (path.substring(index + 1, index + 4).toLowerCase() != '%3a') {
      return null;
    }
    // Offset the index to account for the extra 2 characters from the
    // colon encoding.
    index += 2;
  }
  if (path.length == index + 2) return index + 2;
  if (path.codeUnitAt(index + 2) != chars.slash) return null;
  return index + 3;
}

// File: C:\MyDartProjects\eloquent\lib\src\pdo\postgres\dependencies\postgres_pool\postgres_pool.dart
import 'dart:async';
import 'dart:convert';
import 'dart:io';
import 'dart:math';

import '../executor/executor.dart';
import 'package:postgres_fork/postgres.dart';
import '../retry/retry.dart';

/// A session is a continuous use of a single connection (inside or outside of a
/// transaction).
///
/// This callback function will be called once a connection becomes available.
typedef PgSessionFn<R> = Future<R> Function(PostgreSQLExecutionContext c);

/// The PostgreSQL server endpoint and its configuration to use when opening a
/// new connection.
class PgEndpoint {
  final String host;
  final int port;
  final String database;
  final String? username;
  final String? password;
  final bool requireSsl;
  final bool isUnixSocket;

  /// If provided, it will set that name to the Postgres connection for debugging
  /// purposes.
  /// If a different name is desired for different connections opened by the pool,
  /// the name can contain '{{connectionId}}' which would get replaced at run time.
  ///
  /// Active connections and their names can be obtained in Postgres with
  /// `SELECT * FROM pg_stat_activity`
  final String? applicationName;

  PgEndpoint({
    required this.host,
    this.port = 5432,
    required this.database,
    this.username,
    this.password,
    this.requireSsl = false,
    this.isUnixSocket = false,
    this.applicationName,
  });

  /// Parses the most common connection URL formats:
  /// - postgresql://user:password@host:port/dbname
  /// - postgresql://host:port/dbname?username=user&password=pwd
  /// - postgresql://host:port/dbname?application_name=myapp
  ///
  /// Set ?sslmode=require to force secure SSL connection.
  factory PgEndpoint.parse(url) {
    final uri = url is Uri ? url : Uri.parse(url as String);
    final userInfoParts = uri.userInfo.split(':');
    final username = userInfoParts.length == 2 ? userInfoParts[0] : null;
    final password = userInfoParts.length == 2 ? userInfoParts[1] : null;
    final isUnixSocketParam = uri.queryParameters['is-unix-socket'];
    final applicationNameParam = uri.queryParameters['application_name'];

    return PgEndpoint(
      host: uri.host,
      port: uri.port,
      database: uri.path.substring(1),
      username: username ?? uri.queryParameters['username'],
      password: password ?? uri.queryParameters['password'],
      requireSsl: uri.queryParameters['sslmode'] == 'require',
      isUnixSocket: isUnixSocketParam == '1',
      applicationName: applicationNameParam,
    );
  }

  /// Creates a new [PgEndpoint] by replacing the current values with non-null
  /// parameters.
  ///
  /// Parameters with `null` values are ignored (keeping current value).
  PgEndpoint replace({
    String? host,
    int? port,
    String? database,
    String? username,
    String? password,
    bool? requireSsl,
    bool? isUnixSocket,
    String? Function()? applicationName,
  }) {
    return PgEndpoint(
      host: host ?? this.host,
      port: port ?? this.port,
      database: database ?? this.database,
      username: username ?? this.username,
      password: password ?? this.password,
      requireSsl: requireSsl ?? this.requireSsl,
      isUnixSocket: isUnixSocket ?? this.isUnixSocket,
      applicationName:
          applicationName == null ? this.applicationName : applicationName(),
    );
  }

  @override
  String toString() => Uri(
        scheme: 'postgres',
        host: host,
        port: port,
        path: database,
        queryParameters: {
          'username': username,
          'password': password,
          'sslmode': requireSsl ? 'require' : 'allow',
          if (isUnixSocket) 'is-unix-socket': '1',
          if (applicationName != null) 'application_name': applicationName,
        },
      ).toString();

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is PgEndpoint &&
          runtimeType == other.runtimeType &&
          host == other.host &&
          port == other.port &&
          database == other.database &&
          username == other.username &&
          password == other.password &&
          requireSsl == other.requireSsl &&
          isUnixSocket == other.isUnixSocket &&
          applicationName == other.applicationName;

  @override
  int get hashCode =>
      host.hashCode ^
      port.hashCode ^
      database.hashCode ^
      username.hashCode ^
      password.hashCode ^
      requireSsl.hashCode ^
      isUnixSocket.hashCode ^
      applicationName.hashCode;
}

/// The list of [PgPool] actions.
abstract class PgPoolAction {
  static final connecting = 'connecting';
  static final connectingCompleted = 'connecting-completed';
  static final connectingFailed = 'connecting-failed';
  static final closing = 'closing';
  static final closingCompleted = 'closing-completed';
  static final closingFailed = 'closing-failed';
  static final query = 'query';
  static final queryCompleted = 'query-completed';
  static final queryFailed = 'query-failed';
}

/// Describes a pool event (with error - if there were any).
class PgPoolEvent {
  /// The id of the connection
  final int connectionId;

  /// The identifier of the session (e.g. activity type)
  final String? sessionId;

  /// The unique identifier of a request (used for correlating log entries).
  final String? traceId;

  /// One of [PgPoolAction] values.
  final String action;

  /// The SQL query (if there was any).
  final String? query;

  /// The SQL query's substitution values (if there was any).
  final dynamic substitutionValues;

  /// The elapsed time since the operation started (if applicable).
  final Duration? elapsed;

  /// The error object (if there was any).
  final dynamic error;

  /// The stack trace when the error happened (if there was any).
  final StackTrace? stackTrace;

  PgPoolEvent({
    required this.connectionId,
    this.sessionId,
    this.traceId,
    required this.action,
    this.query,
    this.substitutionValues,
    this.elapsed,
    this.error,
    this.stackTrace,
  });

  PgPoolEvent.fromPgPoolEvent(PgPoolEvent other)
      : connectionId = other.connectionId,
        sessionId = other.sessionId,
        traceId = other.traceId,
        action = other.action,
        query = other.query,
        substitutionValues = other.substitutionValues,
        elapsed = other.elapsed,
        error = other.error,
        stackTrace = other.stackTrace;
}

/// A snapshot of the connection's internal state.
class PgConnectionStatus {
  /// The numerical id of the connection.
  final int connectionId;

  /// If the connection is open and not in use.
  final bool isIdle;

  /// The time when the connection was opened.
  final DateTime opened;

  PgConnectionStatus({
    required this.connectionId,
    required this.isIdle,
    required this.opened,
  });
}

/// A snapshot of the [PgPool]'s internal state.
class PgPoolStatus {
  /// The status of the connections.
  final List<PgConnectionStatus> connections;

  /// The number of sessions using an active connection.
  final int activeSessionCount;

  /// The number of sessions waiting for a connection to become available.
  final int pendingSessionCount;

  PgPoolStatus({
    required this.connections,
    required this.activeSessionCount,
    required this.pendingSessionCount,
  });

  PgPoolStatus.fromPgPoolStatus(PgPoolStatus other)
      : connections = other.connections,
        activeSessionCount = other.activeSessionCount,
        pendingSessionCount = other.pendingSessionCount;
}

/// The settings of the [PgPool].
class PgPoolSettings {
  /// The maximum number of concurrent sessions.
  int maxConnectionCount = 1;

  /// The timeout after the connection attempt is assumed to be failing.
  /// Fractional seconds will be omitted.
  /// Value is applied only on new connections.
  Duration connectTimeout = Duration(seconds: 15);

  /// The timeout after a query is assumed to be failing.
  /// Fractional seconds will be omitted.
  /// Value is applied only on new connections.
  Duration queryTimeout = Duration(minutes: 5);

  /// If a connection is idle for longer than this threshold, it will be tested
  /// with a simple SQL query before allocating it to a session.
  Duration idleTestThreshold = Duration(minutes: 1);

  /// The maximum duration a connection is kept open.
  /// New sessions won't be scheduled after this limit is reached.
  Duration maxConnectionAge = Duration(hours: 12);

  /// The maximum duration a connection is used by sessions.
  /// New sessions won't be scheduled after this limit is reached.
  Duration maxSessionUse = Duration(hours: 8);

  /// The maximum number of error events to be collected on a connection.
  /// New sessions won't be scheduled after this limit is reached.
  int maxErrorCount = 128;

  /// The maximum number of queries to be run on a connection.
  /// New sessions won't be scheduled after this limit is reached.
  int maxQueryCount = 1024 * 1024;

  /// Timezone for the connetion
  TimeZoneSettings timeZone = TimeZoneSettings('UTC');

  Encoding encoding = utf8;

  /// This callback function will be called after opening the connection.
  Future<void> Function(PostgreSQLExecutionContext connection)? onOpen;

  /// The default retry options for `run` / `runTx` operations.
  RetryOptions retryOptions = RetryOptions(
    maxAttempts: 1,
    delayFactor: Duration(milliseconds: 5),
    maxDelay: Duration(seconds: 1),
    randomizationFactor: 0.1,
  );

  void applyFrom(PgPoolSettings other) {
    maxConnectionCount = other.maxConnectionCount;
    connectTimeout = other.connectTimeout;
    queryTimeout = other.queryTimeout;
    idleTestThreshold = other.idleTestThreshold;
    maxConnectionAge = other.maxConnectionAge;
    maxSessionUse = other.maxSessionUse;
    maxErrorCount = other.maxErrorCount;
    maxQueryCount = other.maxQueryCount;
    retryOptions = other.retryOptions;
    timeZone = other.timeZone;
  }
}

/// Single-server connection pool for PostgresSQL database access.
class PgPool implements PostgreSQLExecutionContext {
  final PgEndpoint _url;

  final Executor _executor;
  final _random = Random();
  final _connections = <_ConnectionCtx>[];
  final _events = StreamController<PgPoolEvent>.broadcast();
  int _nextConnectionId = 1;

  /// Makes sure only one connection is opening at a time.
  Completer? _openCompleter;
  PgPoolSettings settings;

  PgPool(PgEndpoint url, {PgPoolSettings? settings})
      : settings = settings ?? PgPoolSettings(),
        _executor = Executor(),
        _url = url;

  /// Get the current debug information of the pool's internal state.
  PgPoolStatus status() => PgPoolStatus(
        connections: _connections.map((c) => c.status()).toList(),
        activeSessionCount: _executor.runningCount,
        pendingSessionCount: _executor.waitingCount,
      );

  /// The events that happen while the pool is working.
  Stream<PgPoolEvent> get events => _events.stream;

  /// Runs [fn] outside of a transaction.
  Future<R> run<R>(
    PgSessionFn<R> fn, {
    RetryOptions? retryOptions,
    FutureOr<R> Function()? orElse,
    FutureOr<bool> Function(Exception)? retryIf,
    String? sessionId,
    String? traceId,
  }) async {
    retryOptions ??= settings.retryOptions;
    try {
      return await retryOptions.retry(
        () async {
          return await _withConnection(
            (c) => fn(_PgExecutionContextWrapper(
              c.connectionId,
              c.connection,
              sessionId,
              traceId,
              _events,
            )),
          );
        },
        retryIf: (e) async =>
            e is! PostgreSQLException &&
            e is! IOException &&
            (retryIf == null || await retryIf(e)),
      );
    } catch (e) {
      if (orElse != null) {
        return await orElse();
      }
      rethrow;
    }
  }

  /// Runs [fn] in a transaction.
  Future<R> runTx<R>(
    PgSessionFn<R> fn, {
    RetryOptions? retryOptions,
    FutureOr<R> Function()? orElse,
    FutureOr<bool> Function(Exception)? retryIf,
    String? sessionId,
    String? traceId,
  }) async {
    retryOptions ??= settings.retryOptions;
    try {
      return await retryOptions.retry(
        () async {
          return await _withConnection((c) async {
            return await c.connection.transaction(
              (conn) => fn(_PgExecutionContextWrapper(
                c.connectionId,
                conn,
                sessionId,
                traceId,
                _events,
              )),
            ) as R;
          });
        },
        retryIf: (e) async =>
            e is! PostgreSQLException &&
            e is! IOException &&
            (retryIf == null || await retryIf(e)),
      );
    } catch (e) {
      if (orElse != null) {
        return await orElse();
      }
      rethrow;
    }
  }

  Future close() async {
    await _executor.close();
    while (_connections.isNotEmpty) {
      await Future.wait(List.of(_connections).map(_close));
    }
    await _events.close();
  }

  Future<R> _withConnection<R>(Future<R> Function(_ConnectionCtx c) body) {
    _executor.concurrency = settings.maxConnectionCount;
    return _executor.scheduleTask(() async {
      return await _useOrCreate(body);
    });
  }

  _ConnectionCtx? _lockIdle() {
    final list = _connections.where((c) => c.isIdle).toList();
    if (list.isEmpty) return null;
    final entry =
        list.length == 1 ? list.single : list[_random.nextInt(list.length)];
    entry.isIdle = false;
    return entry;
  }

  Future<_ConnectionCtx?> _tryAcquireAvailable() async {
    for (var ctx = _lockIdle(); ctx != null; ctx = _lockIdle()) {
      if (await _testConnection(ctx)) {
        return ctx;
      } else {
        await _close(ctx);
      }
    }
    return null;
  }

  Future<R> _useOrCreate<R>(Future<R> Function(_ConnectionCtx c) body) async {
    final ctx = await _tryAcquireAvailable() ?? await _open();
    final sw = Stopwatch()..start();
    try {
      final r = await body(ctx);
      ctx.lastReturned = DateTime.now();
      ctx.elapsed += sw.elapsed;
      ctx.queryCount++;
      ctx.isIdle = true;
      return r;
    } on PostgreSQLException catch (_) {
      await _close(ctx);
      rethrow;
    } on IOException catch (_) {
      await _close(ctx);
      rethrow;
    } on TimeoutException catch (_) {
      await _close(ctx);
      rethrow;
    } catch (e) {
      ctx.lastReturned = DateTime.now();
      ctx.elapsed += sw.elapsed;
      ctx.errorCount++;
      ctx.queryCount++;
      ctx.isIdle = true;
      rethrow;
    }
  }

  Future<_ConnectionCtx> _open() async {
    while (_openCompleter != null) {
      await _openCompleter!.future;
    }
    _openCompleter = Completer();
    final connectionId = _nextConnectionId++;
    _events.add(PgPoolEvent(
      connectionId: connectionId,
      action: PgPoolAction.connecting,
    ));
    try {
      for (var i = 3; i > 0; i--) {
        final sw = Stopwatch()..start();
        try {
          final c = PostgreSQLConnection(
            _url.host,
            _url.port,
            _url.database,
            username: _url.username,
            password: _url.password,
            useSSL: _url.requireSsl,
            isUnixSocket: _url.isUnixSocket,
            timeoutInSeconds: settings.connectTimeout.inSeconds,
            queryTimeoutInSeconds: settings.queryTimeout.inSeconds,
            timeZone: settings.timeZone,
            encoding: settings.encoding,
          );
          await c.open();
          if (settings.onOpen != null) {
            await settings.onOpen!(c);
          }
          final ctx = _ConnectionCtx(connectionId, c);
          _connections.add(ctx);

          // Set the application connection name
          final applicationName = _url.applicationName;
          if (applicationName != null) {
            await _setApplicationName(
              c,
              applicationName: applicationName,
              connectionId: connectionId,
            );
          }

          _events.add(PgPoolEvent(
            connectionId: connectionId,
            action: PgPoolAction.connectingCompleted,
            elapsed: sw.elapsed,
          ));

          return ctx;
        } catch (e, st) {
          if (i == 1) {
            _events.add(PgPoolEvent(
              connectionId: connectionId,
              action: PgPoolAction.connectingFailed,
              elapsed: sw.elapsed,
              error: e,
              stackTrace: st,
            ));
            rethrow;
          }
        }
      }
      throw StateError('Should not reach this code.');
    } finally {
      final c = _openCompleter!;
      _openCompleter = null;
      c.complete();
    }
  }

  Future<bool> _testConnection(_ConnectionCtx ctx) async {
    final now = DateTime.now();
    final totalAge = now.difference(ctx.opened).abs();
    final shouldClose = (totalAge >= settings.maxConnectionAge) ||
        (ctx.elapsed >= settings.maxSessionUse) ||
        (ctx.errorCount >= settings.maxErrorCount) ||
        (ctx.queryCount >= settings.maxQueryCount);
    if (shouldClose) {
      return false;
    }
    final idleAge = now.difference(ctx.lastReturned).abs();
    if (idleAge < settings.idleTestThreshold) {
      return true;
    }
    try {
      await ctx.connection.query('SELECT 1;', timeoutInSeconds: 2);
      return true;
    } catch (_) {}
    return false;
  }

  Future _close(_ConnectionCtx ctx) async {
    ctx.isIdle = false;
    if (ctx.closingCompleter != null) {
      await ctx.closingCompleter!.future;
      return;
    }
    ctx.closingCompleter = Completer();

    final sw = Stopwatch()..start();
    try {
      if (!ctx.connection.isClosed) {
        _events.add(PgPoolEvent(
          connectionId: ctx.connectionId,
          action: PgPoolAction.closing,
        ));
        await ctx.connection.close();
        _events.add(PgPoolEvent(
          connectionId: ctx.connectionId,
          action: PgPoolAction.closingCompleted,
          elapsed: sw.elapsed,
        ));
      }
    } catch (e, st) {
      _events.add(PgPoolEvent(
        connectionId: ctx.connectionId,
        action: PgPoolAction.closingFailed,
        elapsed: sw.elapsed,
        error: e,
        stackTrace: st,
      ));
    } finally {
      _connections.remove(ctx);
    }
  }

  @override
  int get queueSize =>
      _connections.fold<int>(0, (a, b) => a + b.connection.queueSize);

  @override
  Future<PostgreSQLResult> query(
    String fmtString, {
    dynamic substitutionValues,
    bool? allowReuse = true,
    int? timeoutInSeconds,
    bool? useSimpleQueryProtocol,
    String? sessionId,
    String? traceId,
    PlaceholderIdentifier placeholderIdentifier = PlaceholderIdentifier.atSign,
  }) {
    return run(
      (c) => c.query(
        fmtString,
        substitutionValues: substitutionValues,
        allowReuse: allowReuse,
        timeoutInSeconds: timeoutInSeconds,
        useSimpleQueryProtocol: useSimpleQueryProtocol,
        placeholderIdentifier: placeholderIdentifier,
      ),
      sessionId: sessionId,
      traceId: traceId,
    );
  }

  @override
  Future<int> execute(
    String fmtString, {
    dynamic substitutionValues,
    int? timeoutInSeconds,
    String? sessionId,
    String? traceId,
    PlaceholderIdentifier placeholderIdentifier = PlaceholderIdentifier.atSign,
  }) {
    return run(
      (c) => c.execute(
        fmtString,
        substitutionValues: substitutionValues,
        timeoutInSeconds: timeoutInSeconds,
        placeholderIdentifier: placeholderIdentifier,
      ),
      sessionId: sessionId,
      traceId: traceId,
    );
  }

  @override
  void cancelTransaction({String? reason}) {
    // no-op
  }

  @override
  Future<List<Map<String, Map<String, dynamic>>>> mappedResultsQuery(
    String fmtString, {
    dynamic substitutionValues,
    bool? allowReuse = true,
    int? timeoutInSeconds,
    String? sessionId,
    String? traceId,
    PlaceholderIdentifier placeholderIdentifier = PlaceholderIdentifier.atSign,
  }) {
    return run(
      (c) => c.mappedResultsQuery(
        fmtString,
        substitutionValues: substitutionValues,
        allowReuse: allowReuse,
        timeoutInSeconds: timeoutInSeconds,
        placeholderIdentifier: placeholderIdentifier,
      ),
      sessionId: sessionId,
      traceId: traceId,
    );
  }

  @override
  Future<List<Map<String, dynamic>>> queryAsMap(
    String fmtString, {
    dynamic substitutionValues,
    bool? allowReuse = true,
    int? timeoutInSeconds,
    String? sessionId,
    String? traceId,
    PlaceholderIdentifier placeholderIdentifier = PlaceholderIdentifier.atSign,
  }) {
    return run(
      (c) => c.queryAsMap(
        fmtString,
        substitutionValues: substitutionValues,
        allowReuse: allowReuse,
        timeoutInSeconds: timeoutInSeconds,
        placeholderIdentifier: placeholderIdentifier,
      ),
      sessionId: sessionId,
      traceId: traceId,
    );
  }

  /// Sets the application_name to the provided postgres connection
  /// Current implementation is done by executing a postgres command.
  /// A future improvement could be to send the application_name
  /// through the postgres messaging protocol
  Future<void> _setApplicationName(
    PostgreSQLConnection pgConn, {
    required String applicationName,
    required int connectionId,
  }) async {
    // The connectionId can be injected into the name at runtime
    final effectiveName =
        applicationName.replaceAll('{{connectionId}}', connectionId.toString());

    await pgConn.execute(
      'SET application_name = @app_name',
      substitutionValues: {
        'app_name': effectiveName,
      },
    );
  }
}

class _ConnectionCtx {
  final int connectionId;
  final PostgreSQLConnection connection;
  final DateTime opened;
  late DateTime lastReturned;
  int queryCount = 0;
  int errorCount = 0;
  Duration elapsed = Duration.zero;
  bool isIdle = false;
  Completer? closingCompleter;

  _ConnectionCtx(this.connectionId, this.connection) : opened = DateTime.now();

  PgConnectionStatus status() {
    return PgConnectionStatus(
      connectionId: connectionId,
      isIdle: isIdle,
      opened: opened,
    );
  }
}

class _PgExecutionContextWrapper implements PostgreSQLExecutionContext {
  final int connectionId;
  final PostgreSQLExecutionContext _delegate;
  final String? sessionId;
  final String? traceId;
  final Sink<PgPoolEvent> _eventSink;

  _PgExecutionContextWrapper(
    this.connectionId,
    this._delegate,
    this.sessionId,
    this.traceId,
    this._eventSink,
  );

  Future<R> _run<R>(
    Future<R> Function() body,
    String query,
    dynamic substitutionValues,
  ) async {
    final sw = Stopwatch()..start();
    try {
      _eventSink.add(PgPoolEvent(
        connectionId: connectionId,
        sessionId: sessionId,
        traceId: traceId,
        action: PgPoolAction.query,
        query: query,
        substitutionValues: substitutionValues,
      ));
      final r = await body();
      _eventSink.add(PgPoolEvent(
        connectionId: connectionId,
        sessionId: sessionId,
        traceId: traceId,
        action: PgPoolAction.queryCompleted,
        query: query,
        substitutionValues: substitutionValues,
        elapsed: sw.elapsed,
      ));
      return r;
    } catch (e, st) {
      _eventSink.add(PgPoolEvent(
        connectionId: connectionId,
        sessionId: sessionId,
        traceId: traceId,
        action: PgPoolAction.queryFailed,
        query: query,
        substitutionValues: substitutionValues,
        elapsed: sw.elapsed,
        error: e,
        stackTrace: st,
      ));
      rethrow;
    } finally {
      sw.stop();
    }
  }

  @override
  void cancelTransaction({String? reason}) {
    _delegate.cancelTransaction(reason: reason);
  }

  @override
  Future<int> execute(
    String fmtString, {
    dynamic substitutionValues,
    int? timeoutInSeconds,
    PlaceholderIdentifier placeholderIdentifier = PlaceholderIdentifier.atSign,
  }) {
    return _run(
      () => _delegate.execute(
        fmtString,
        substitutionValues: substitutionValues,
        timeoutInSeconds: timeoutInSeconds,
        placeholderIdentifier: placeholderIdentifier,
      ),
      fmtString,
      substitutionValues,
    );
  }

  @override
  Future<PostgreSQLResult> query(
    String fmtString, {
    dynamic substitutionValues,
    bool? allowReuse = true,
    int? timeoutInSeconds,
    bool? useSimpleQueryProtocol,
    PlaceholderIdentifier placeholderIdentifier = PlaceholderIdentifier.atSign,
  }) {
    return _run(
      () => _delegate.query(
        fmtString,
        substitutionValues: substitutionValues,
        allowReuse: allowReuse,
        timeoutInSeconds: timeoutInSeconds,
        useSimpleQueryProtocol: useSimpleQueryProtocol,
        placeholderIdentifier: placeholderIdentifier,
      ),
      fmtString,
      substitutionValues,
    );
  }

  @override
  Future<List<Map<String, Map<String, dynamic>>>> mappedResultsQuery(
    String fmtString, {
    dynamic substitutionValues,
    bool? allowReuse = true,
    int? timeoutInSeconds,
    PlaceholderIdentifier placeholderIdentifier = PlaceholderIdentifier.atSign,
  }) {
    return _run(
      () => _delegate.mappedResultsQuery(
        fmtString,
        substitutionValues: substitutionValues,
        allowReuse: allowReuse,
        timeoutInSeconds: timeoutInSeconds,
        placeholderIdentifier: placeholderIdentifier,
      ),
      fmtString,
      substitutionValues,
    );
  }

  @override
  Future<List<Map<String, dynamic>>> queryAsMap(
    String fmtString, {
    dynamic substitutionValues,
    bool? allowReuse = true,
    int? timeoutInSeconds,
    PlaceholderIdentifier placeholderIdentifier = PlaceholderIdentifier.atSign,
  }) {
    return _run(
      () => _delegate.queryAsMap(
        fmtString,
        substitutionValues: substitutionValues,
        allowReuse: allowReuse,
        timeoutInSeconds: timeoutInSeconds,
        placeholderIdentifier: placeholderIdentifier,
      ),
      fmtString,
      substitutionValues,
    );
  }

  @override
  int get queueSize => _delegate.queueSize;
}

// File: C:\MyDartProjects\eloquent\lib\src\pdo\postgres\dependencies\retry\retry.dart
/// Retry asynchronous functions with exponential backoff.
///
/// For a simple solution see [retry], to modify and persist retry options see
/// [RetryOptions]. Note, in many cases the added configurability is
/// unnecessary and using [retry] is perfectly fine.
library retry;

import 'dart:async';
import 'dart:math' as math;

final _rand = math.Random();

/// Object holding options for retrying a function.
///
/// With the default configuration functions will be retried up-to 7 times
/// (8 attempts in total), sleeping 1st, 2nd, 3rd, ..., 7th attempt:
///  1. 400 ms +/- 25%
///  2. 800 ms +/- 25%
///  3. 1600 ms +/- 25%
///  4. 3200 ms +/- 25%
///  5. 6400 ms +/- 25%
///  6. 12800 ms +/- 25%
///  7. 25600 ms +/- 25%
///
/// **Example**
/// ```dart
/// final r = RetryOptions();
/// final response = await r.retry(
///   // Make a GET request
///   () => http.get('https://google.com').timeout(Duration(seconds: 5)),
///   // Retry on SocketException or TimeoutException
///   retryIf: (e) => e is SocketException || e is TimeoutException,
/// );
/// print(response.body);
/// ```
final class RetryOptions {
  /// Delay factor to double after every attempt.
  ///
  /// Defaults to 200 ms, which results in the following delays:
  ///
  ///  1. 400 ms
  ///  2. 800 ms
  ///  3. 1600 ms
  ///  4. 3200 ms
  ///  5. 6400 ms
  ///  6. 12800 ms
  ///  7. 25600 ms
  ///
  /// Before application of [randomizationFactor].
  final Duration delayFactor;

  /// Percentage the delay should be randomized, given as fraction between
  /// 0 and 1.
  ///
  /// If [randomizationFactor] is `0.25` (default) this indicates 25 % of the
  /// delay should be increased or decreased by 25 %.
  final double randomizationFactor;

  /// Maximum delay between retries, defaults to 30 seconds.
  final Duration maxDelay;

  /// Maximum number of attempts before giving up, defaults to 8.
  final int maxAttempts;

  /// Create a set of [RetryOptions].
  ///
  /// Defaults to 8 attempts, sleeping as following after 1st, 2nd, 3rd, ...,
  /// 7th attempt:
  ///  1. 400 ms +/- 25%
  ///  2. 800 ms +/- 25%
  ///  3. 1600 ms +/- 25%
  ///  4. 3200 ms +/- 25%
  ///  5. 6400 ms +/- 25%
  ///  6. 12800 ms +/- 25%
  ///  7. 25600 ms +/- 25%
  const RetryOptions({
    this.delayFactor = const Duration(milliseconds: 200),
    this.randomizationFactor = 0.25,
    this.maxDelay = const Duration(seconds: 30),
    this.maxAttempts = 8,
  });

  /// Delay after [attempt] number of attempts.
  ///
  /// This is computed as `pow(2, attempt) * delayFactor`, then is multiplied by
  /// between `-randomizationFactor` and `randomizationFactor` at random.
  Duration delay(int attempt) {
    assert(attempt >= 0, 'attempt cannot be negative');
    if (attempt <= 0) {
      return Duration.zero;
    }
    final rf = (randomizationFactor * (_rand.nextDouble() * 2 - 1) + 1);
    final exp = math.min(attempt, 31); // prevent overflows.
    final delay = (delayFactor * math.pow(2.0, exp) * rf);
    return delay < maxDelay ? delay : maxDelay;
  }

  /// Call [fn] retrying so long as [retryIf] return `true` for the exception
  /// thrown.
  ///
  /// At every retry the [onRetry] function will be called (if given). The
  /// function [fn] will be invoked at-most [this.attempts] times.
  ///
  /// If no [retryIf] function is given this will retry any for any [Exception]
  /// thrown. To retry on an [Error], the error must be caught and _rethrown_
  /// as an [Exception].
  Future<T> retry<T>(
    FutureOr<T> Function() fn, {
    FutureOr<bool> Function(Exception)? retryIf,
    FutureOr<void> Function(Exception)? onRetry,
  }) async {
    var attempt = 0;
    // ignore: literal_only_boolean_expressions
    while (true) {
      attempt++; // first invocation is the first attempt
      try {
        return await fn();
      } on Exception catch (e) {
        if (attempt >= maxAttempts ||
            (retryIf != null && !(await retryIf(e)))) {
          rethrow;
        }
        if (onRetry != null) {
          await onRetry(e);
        }
      }

      // Sleep for a delay
      await Future.delayed(delay(attempt));
    }
  }
}

/// Call [fn] retrying so long as [retryIf] return `true` for the exception
/// thrown, up-to [maxAttempts] times.
///
/// Defaults to 8 attempts, sleeping as following after 1st, 2nd, 3rd, ...,
/// 7th attempt:
///  1. 400 ms +/- 25%
///  2. 800 ms +/- 25%
///  3. 1600 ms +/- 25%
///  4. 3200 ms +/- 25%
///  5. 6400 ms +/- 25%
///  6. 12800 ms +/- 25%
///  7. 25600 ms +/- 25%
///
/// ```dart
/// final response = await retry(
///   // Make a GET request
///   () => http.get('https://google.com').timeout(Duration(seconds: 5)),
///   // Retry on SocketException or TimeoutException
///   retryIf: (e) => e is SocketException || e is TimeoutException,
/// );
/// print(response.body);
/// ```
///
/// If no [retryIf] function is given this will retry any for any [Exception]
/// thrown. To retry on an [Error], the error must be caught and _rethrown_
/// as an [Exception].
Future<T> retry<T>(
  FutureOr<T> Function() fn, {
  Duration delayFactor = const Duration(milliseconds: 200),
  double randomizationFactor = 0.25,
  Duration maxDelay = const Duration(seconds: 30),
  int maxAttempts = 8,
  FutureOr<bool> Function(Exception)? retryIf,
  FutureOr<void> Function(Exception)? onRetry,
}) =>
    RetryOptions(
      delayFactor: delayFactor,
      randomizationFactor: randomizationFactor,
      maxDelay: maxDelay,
      maxAttempts: maxAttempts,
    ).retry(fn, retryIf: retryIf, onRetry: onRetry);

// File: C:\MyDartProjects\eloquent\lib\src\pdo\postgres\dependencies\stack_trace\src\chain.dart


import 'dart:async';
import 'dart:math' as math;

import 'frame.dart';
import 'lazy_chain.dart';
import 'stack_zone_specification.dart';
import 'trace.dart';
import 'utils.dart';

/// A function that handles errors in the zone wrapped by [Chain.capture].
@Deprecated('Will be removed in stack_trace 2.0.0.')
typedef ChainHandler = void Function(dynamic error, Chain chain);

/// An opaque key used to track the current [StackZoneSpecification].
final _specKey = Object();

/// A chain of stack traces.
///
/// A stack chain is a collection of one or more stack traces that collectively
/// represent the path from `main` through nested function calls to a particular
/// code location, usually where an error was thrown. Multiple stack traces are
/// necessary when using asynchronous functions, since the program's stack is
/// reset before each asynchronous callback is run.
///
/// Stack chains can be automatically tracked using [Chain.capture]. This sets
/// up a new [Zone] in which the current stack chain is tracked and can be
/// accessed using [Chain.current]. Any errors that would be top-leveled in
/// the zone can be handled, along with their associated chains, with the
/// `onError` callback. For example:
///
///     Chain.capture(() {
///       // ...
///     }, onError: (error, stackChain) {
///       print("Caught error $error\n"
///             "$stackChain");
///     });
class Chain implements StackTrace {
  /// The stack traces that make up this chain.
  ///
  /// Like the frames in a stack trace, the traces are ordered from most local
  /// to least local. The first one is the trace where the actual exception was
  /// raised, the second one is where that callback was scheduled, and so on.
  final List<Trace> traces;

  /// The [StackZoneSpecification] for the current zone.
  static StackZoneSpecification? get _currentSpec =>
      Zone.current[_specKey] as StackZoneSpecification?;

  /// If [when] is `true`, runs [callback] in a [Zone] in which the current
  /// stack chain is tracked and automatically associated with (most) errors.
  ///
  /// If [when] is `false`, this does not track stack chains. Instead, it's
  /// identical to [runZoned], except that it wraps any errors in
  /// [Chain.forTrace]—which will only wrap the trace unless there's a different
  /// [Chain.capture] active. This makes it easy for the caller to only capture
  /// stack chains in debug mode or during development.
  ///
  /// If [onError] is passed, any error in the zone that would otherwise go
  /// unhandled is passed to it, along with the [Chain] associated with that
  /// error. Note that if [callback] produces multiple unhandled errors,
  /// [onError] may be called more than once. If [onError] isn't passed, the
  /// parent Zone's `unhandledErrorHandler` will be called with the error and
  /// its chain.
  ///
  /// The zone this creates will be an error zone if either [onError] is
  /// not `null` and [when] is false,
  /// or if both [when] and [errorZone] are `true`.
  ///  If [errorZone] is `false`, [onError] must be `null`.
  ///
  /// If [callback] returns a value, it will be returned by [capture] as well.
  ///
  /// [zoneValues] is added to the [runZoned] calls.
  static T capture<T>(T Function() callback,
      {void Function(Object error, Chain)? onError,
      bool when = true,
      bool errorZone = true,
      Map<Object?, Object?>? zoneValues}) {
    if (!errorZone && onError != null) {
      throw ArgumentError.value(
          onError, 'onError', 'must be null if errorZone is false');
    }

    if (!when) {
      if (onError == null) return runZoned(callback, zoneValues: zoneValues);
      return runZonedGuarded(callback, (error, stackTrace) {
        onError(error, Chain.forTrace(stackTrace));
      }, zoneValues: zoneValues) as T;
    }

    var spec = StackZoneSpecification(onError, errorZone: errorZone);
    return runZoned(() {
      try {
        return callback();
      } on Object catch (error, stackTrace) {
        // Forward synchronous errors through the async error path to match the
        // behavior of `runZonedGuarded`.
        Zone.current.handleUncaughtError(error, stackTrace);

        // If the expected return type of capture() is not nullable, this will
        // throw a cast exception. But the only other alternative is to throw
        // some other exception. Casting null to T at least lets existing uses
        // where T is a nullable type continue to work.
        return null as T;
      }
    }, zoneSpecification: spec.toSpec(), zoneValues: {
      ...?zoneValues,
      _specKey: spec,
      StackZoneSpecification.disableKey: false
    });
  }

  /// If [when] is `true` and this is called within a [Chain.capture] zone, runs
  /// [callback] in a [Zone] in which chain capturing is disabled.
  ///
  /// If [callback] returns a value, it will be returned by [disable] as well.
  static T disable<T>(T Function() callback, {bool when = true}) {
    var zoneValues =
        when ? {_specKey: null, StackZoneSpecification.disableKey: true} : null;

    return runZoned(callback, zoneValues: zoneValues);
  }

  /// Returns [futureOrStream] unmodified.
  ///
  /// Prior to Dart 1.7, this was necessary to ensure that stack traces for
  /// exceptions reported with [Completer.completeError] and
  /// [StreamController.addError] were tracked correctly.
  @Deprecated('Chain.track is not necessary in Dart 1.7+.')
  static dynamic track(Object? futureOrStream) => futureOrStream;

  /// Returns the current stack chain.
  ///
  /// By default, the first frame of the first trace will be the line where
  /// [Chain.current] is called. If [level] is passed, the first trace will
  /// start that many frames up instead.
  ///
  /// If this is called outside of a [capture] zone, it just returns a
  /// single-trace chain.
  factory Chain.current([int level = 0]) {
    if (_currentSpec != null) return _currentSpec!.currentChain(level + 1);

    var chain = Chain.forTrace(StackTrace.current);
    return LazyChain(() {
      // JS includes a frame for the call to StackTrace.current, but the VM
      // doesn't, so we skip an extra frame in a JS context.
      var first = Trace(chain.traces.first.frames.skip(level + (inJS ? 2 : 1)),
          original: chain.traces.first.original.toString());
      return Chain([first, ...chain.traces.skip(1)]);
    });
  }

  /// Returns the stack chain associated with [trace].
  ///
  /// The first stack trace in the returned chain will always be [trace]
  /// (converted to a [Trace] if necessary). If there is no chain associated
  /// with [trace] or if this is called outside of a [capture] zone, this just
  /// returns a single-trace chain containing [trace].
  ///
  /// If [trace] is already a [Chain], it will be returned as-is.
  factory Chain.forTrace(StackTrace trace) {
    if (trace is Chain) return trace;
    if (_currentSpec != null) return _currentSpec!.chainFor(trace);
    if (trace is Trace) return Chain([trace]);
    return LazyChain(() => Chain.parse(trace.toString()));
  }

  /// Parses a string representation of a stack chain.
  ///
  /// If [chain] is the output of a call to [Chain.toString], it will be parsed
  /// as a full stack chain. Otherwise, it will be parsed as in [Trace.parse]
  /// and returned as a single-trace chain.
  factory Chain.parse(String chain) {
    if (chain.isEmpty) return Chain([]);
    if (chain.contains(vmChainGap)) {
      return Chain(chain
          .split(vmChainGap)
          .where((line) => line.isNotEmpty)
          .map(Trace.parseVM));
    }
    if (!chain.contains(chainGap)) return Chain([Trace.parse(chain)]);

    return Chain(chain.split(chainGap).map(Trace.parseFriendly));
  }

  /// Returns a new [Chain] comprised of [traces].
  Chain(Iterable<Trace> traces) : traces = List<Trace>.unmodifiable(traces);

  /// Returns a terser version of this chain.
  ///
  /// This calls [Trace.terse] on every trace in [traces], and discards any
  /// trace that contain only internal frames.
  ///
  /// This won't do anything with a raw JavaScript trace, since there's no way
  /// to determine which frames come from which Dart libraries. However, the
  /// [`source_map_stack_trace`](https://pub.dev/packages/source_map_stack_trace)
  /// package can be used to convert JavaScript traces into Dart-style traces.
  Chain get terse => foldFrames((_) => false, terse: true);

  /// Returns a new [Chain] based on this chain where multiple stack frames
  /// matching [predicate] are folded together.
  ///
  /// This means that whenever there are multiple frames in a row that match
  /// [predicate], only the last one is kept. In addition, traces that are
  /// composed entirely of frames matching [predicate] are omitted.
  ///
  /// This is useful for limiting the amount of library code that appears in a
  /// stack trace by only showing user code and code that's called by user code.
  ///
  /// If [terse] is true, this will also fold together frames from the core
  /// library or from this package, and simplify core library frames as in
  /// [Trace.terse].
  Chain foldFrames(bool Function(Frame) predicate, {bool terse = false}) {
    var foldedTraces =
        traces.map((trace) => trace.foldFrames(predicate, terse: terse));
    var nonEmptyTraces = foldedTraces.where((trace) {
      // Ignore traces that contain only folded frames.
      if (trace.frames.length > 1) return true;
      if (trace.frames.isEmpty) return false;

      // In terse mode, the trace may have removed an outer folded frame,
      // leaving a single non-folded frame. We can detect a folded frame because
      // it has no line information.
      if (!terse) return false;
      return trace.frames.single.line != null;
    });

    // If all the traces contain only internal processing, preserve the last
    // (top-most) one so that the chain isn't empty.
    if (nonEmptyTraces.isEmpty && foldedTraces.isNotEmpty) {
      return Chain([foldedTraces.last]);
    }

    return Chain(nonEmptyTraces);
  }

  /// Converts this chain to a [Trace].
  ///
  /// The trace version of a chain is just the concatenation of all the traces
  /// in the chain.
  Trace toTrace() => Trace(traces.expand((trace) => trace.frames));

  @override
  String toString() {
    // Figure out the longest path so we know how much to pad.
    var longest = traces
        .map((trace) => trace.frames
            .map((frame) => frame.location.length)
            .fold(0, math.max))
        .fold(0, math.max);

    // Don't call out to [Trace.toString] here because that doesn't ensure that
    // padding is consistent across all traces.
    return traces
        .map((trace) => trace.frames
            .map((frame) =>
                '${frame.location.padRight(longest)}  ${frame.member}\n')
            .join())
        .join(chainGap);
  }
}

// File: C:\MyDartProjects\eloquent\lib\src\pdo\postgres\dependencies\stack_trace\src\frame.dart


import '../../path/path.dart' as path;

import 'trace.dart';
import 'unparsed_frame.dart';

// #1      Foo._bar (file:///home/nweiz/code/stuff.dart:42:21)
// #1      Foo._bar (file:///home/nweiz/code/stuff.dart:42)
// #1      Foo._bar (file:///home/nweiz/code/stuff.dart)
final _vmFrame = RegExp(r'^#\d+\s+(\S.*) \((.+?)((?::\d+){0,2})\)$');

//     at Object.stringify (native)
//     at VW.call$0 (https://example.com/stuff.dart.js:560:28)
//     at VW.call$0 (eval as fn
//         (https://example.com/stuff.dart.js:560:28), efn:3:28)
//     at https://example.com/stuff.dart.js:560:28
final _v8Frame =
    RegExp(r'^\s*at (?:(\S.*?)(?: \[as [^\]]+\])? \((.*)\)|(.*))$');

// https://example.com/stuff.dart.js:560:28
// https://example.com/stuff.dart.js:560
final _v8UrlLocation = RegExp(r'^(.*?):(\d+)(?::(\d+))?$|native$');

// eval as function (https://example.com/stuff.dart.js:560:28), efn:3:28
// eval as function (https://example.com/stuff.dart.js:560:28)
// eval as function (eval as otherFunction
//     (https://example.com/stuff.dart.js:560:28))
final _v8EvalLocation =
    RegExp(r'^eval at (?:\S.*?) \((.*)\)(?:, .*?:\d+:\d+)?$');

// anonymous/<@https://example.com/stuff.js line 693 > Function:3:40
// anonymous/<@https://example.com/stuff.js line 693 > eval:3:40
final _firefoxEvalLocation =
    RegExp(r'(\S+)@(\S+) line (\d+) >.* (Function|eval):\d+:\d+');

// .VW.call$0@https://example.com/stuff.dart.js:560
// .VW.call$0("arg")@https://example.com/stuff.dart.js:560
// .VW.call$0/name<@https://example.com/stuff.dart.js:560
// .VW.call$0@https://example.com/stuff.dart.js:560:36
// https://example.com/stuff.dart.js:560
final _firefoxSafariFrame = RegExp(r'^'
    r'(?:' // Member description. Not present in some Safari frames.
    r'([^@(/]*)' // The actual name of the member.
    r'(?:\(.*\))?' // Arguments to the member, sometimes captured by Firefox.
    r'((?:/[^/]*)*)' // Extra characters indicating a nested closure.
    r'(?:\(.*\))?' // Arguments to the closure.
    r'@'
    r')?'
    r'(.*?)' // The frame's URL.
    r':'
    r'(\d*)' // The line number. Empty in Safari if it's unknown.
    r'(?::(\d*))?' // The column number. Not present in older browsers and
    // empty in Safari if it's unknown.
    r'$');

// foo/bar.dart 10:11 Foo._bar
// foo/bar.dart 10:11 (anonymous function).dart.fn
// https://dart.dev/foo/bar.dart Foo._bar
// data:... 10:11 Foo._bar
final _friendlyFrame = RegExp(r'^(\S+)(?: (\d+)(?::(\d+))?)?\s+([^\d].*)$');

/// A regular expression that matches asynchronous member names generated by the
/// VM.
final _asyncBody = RegExp(r'<(<anonymous closure>|[^>]+)_async_body>');

final _initialDot = RegExp(r'^\.');

/// A single stack frame. Each frame points to a precise location in Dart code.
class Frame {
  /// The URI of the file in which the code is located.
  ///
  /// This URI will usually have the scheme `dart`, `file`, `http`, or `https`.
  final Uri uri;

  /// The line number on which the code location is located.
  ///
  /// This can be null, indicating that the line number is unknown or
  /// unimportant.
  final int? line;

  /// The column number of the code location.
  ///
  /// This can be null, indicating that the column number is unknown or
  /// unimportant.
  final int? column;

  /// The name of the member in which the code location occurs.
  ///
  /// Anonymous closures are represented as `<fn>` in this member string.
  final String? member;

  /// Whether this stack frame comes from the Dart core libraries.
  bool get isCore => uri.scheme == 'dart';

  /// Returns a human-friendly description of the library that this stack frame
  /// comes from.
  ///
  /// This will usually be the string form of [uri], but a relative URI will be
  /// used if possible. Data URIs will be truncated.
  String get library {
    if (uri.scheme == 'data') return 'data:...';
    return path.prettyUri(uri);
  }

  /// Returns the name of the package this stack frame comes from, or `null` if
  /// this stack frame doesn't come from a `package:` URL.
  String? get package {
    if (uri.scheme != 'package') return null;
    return uri.path.split('/').first;
  }

  /// A human-friendly description of the code location.
  String get location {
    if (line == null) return library;
    if (column == null) return '$library $line';
    return '$library $line:$column';
  }

  /// Returns a single frame of the current stack.
  ///
  /// By default, this will return the frame above the current method. If
  /// [level] is `0`, it will return the current method's frame; if [level] is
  /// higher than `1`, it will return higher frames.
  factory Frame.caller([int level = 1]) {
    if (level < 0) {
      throw ArgumentError('Argument [level] must be greater than or equal '
          'to 0.');
    }

    return Trace.current(level + 1).frames.first;
  }

  /// Parses a string representation of a Dart VM stack frame.
  factory Frame.parseVM(String frame) => _catchFormatException(frame, () {
        // The VM sometimes folds multiple stack frames together and replaces
        // them with "...".
        if (frame == '...') {
          return Frame(Uri(), null, null, '...');
        }

        var match = _vmFrame.firstMatch(frame);
        if (match == null) return UnparsedFrame(frame);

        // Get the pieces out of the regexp match. Function, URI and line should
        // always be found. The column is optional.
        var member = match[1]!
            .replaceAll(_asyncBody, '<async>')
            .replaceAll('<anonymous closure>', '<fn>');
        var uri = match[2]!.startsWith('<data:')
            ? Uri.dataFromString('')
            : Uri.parse(match[2]!);

        var lineAndColumn = match[3]!.split(':');
        var line =
            lineAndColumn.length > 1 ? int.parse(lineAndColumn[1]) : null;
        var column =
            lineAndColumn.length > 2 ? int.parse(lineAndColumn[2]) : null;
        return Frame(uri, line, column, member);
      });

  /// Parses a string representation of a Chrome/V8 stack frame.
  factory Frame.parseV8(String frame) => _catchFormatException(frame, () {
        var match = _v8Frame.firstMatch(frame);
        if (match == null) return UnparsedFrame(frame);

        // v8 location strings can be arbitrarily-nested, since it adds a layer
        // of nesting for each eval performed on that line.
        Frame parseLocation(String location, String member) {
          var evalMatch = _v8EvalLocation.firstMatch(location);
          while (evalMatch != null) {
            location = evalMatch[1]!;
            evalMatch = _v8EvalLocation.firstMatch(location);
          }

          if (location == 'native') {
            return Frame(Uri.parse('native'), null, null, member);
          }

          var urlMatch = _v8UrlLocation.firstMatch(location);
          if (urlMatch == null) return UnparsedFrame(frame);

          final uri = _uriOrPathToUri(urlMatch[1]!);
          final line = int.parse(urlMatch[2]!);
          final columnMatch = urlMatch[3];
          final column = columnMatch != null ? int.parse(columnMatch) : null;
          return Frame(uri, line, column, member);
        }

        // V8 stack frames can be in two forms.
        if (match[2] != null) {
          // The first form looks like " at FUNCTION (LOCATION)". V8 proper
          // lists anonymous functions within eval as "<anonymous>", while IE10
          // lists them as "Anonymous function".
          return parseLocation(
              match[2]!,
              match[1]!
                  .replaceAll('<anonymous>', '<fn>')
                  .replaceAll('Anonymous function', '<fn>')
                  .replaceAll('(anonymous function)', '<fn>'));
        } else {
          // The second form looks like " at LOCATION", and is used for
          // anonymous functions.
          return parseLocation(match[3]!, '<fn>');
        }
      });

  /// Parses a string representation of a JavaScriptCore stack trace.
  factory Frame.parseJSCore(String frame) => Frame.parseV8(frame);

  /// Parses a string representation of an IE stack frame.
  ///
  /// IE10+ frames look just like V8 frames. Prior to IE10, stack traces can't
  /// be retrieved.
  factory Frame.parseIE(String frame) => Frame.parseV8(frame);

  /// Parses a Firefox 'eval' or 'function' stack frame.
  ///
  /// for example:
  /// anonymous/<@https://example.com/stuff.js line 693 > Function:3:40
  /// anonymous/<@https://example.com/stuff.js line 693 > eval:3:40
  factory Frame._parseFirefoxEval(String frame) =>
      _catchFormatException(frame, () {
        final match = _firefoxEvalLocation.firstMatch(frame);
        if (match == null) return UnparsedFrame(frame);
        var member = match[1]!.replaceAll('/<', '');
        final uri = _uriOrPathToUri(match[2]!);
        final line = int.parse(match[3]!);
        if (member.isEmpty || member == 'anonymous') {
          member = '<fn>';
        }
        return Frame(uri, line, null, member);
      });

  /// Parses a string representation of a Firefox stack frame.
  factory Frame.parseFirefox(String frame) => _catchFormatException(frame, () {
        var match = _firefoxSafariFrame.firstMatch(frame);
        if (match == null) return UnparsedFrame(frame);

        if (match[3]!.contains(' line ')) {
          return Frame._parseFirefoxEval(frame);
        }

        // Normally this is a URI, but in a jsshell trace it can be a path.
        var uri = _uriOrPathToUri(match[3]!);

        var member = match[1];
        if (member != null) {
          member +=
              List.filled('/'.allMatches(match[2]!).length, '.<fn>').join();
          if (member == '') member = '<fn>';

          // Some Firefox members have initial dots. We remove them for
          // consistency with other platforms.
          member = member.replaceFirst(_initialDot, '');
        } else {
          member = '<fn>';
        }

        var line = match[4] == '' ? null : int.parse(match[4]!);
        var column =
            match[5] == null || match[5] == '' ? null : int.parse(match[5]!);
        return Frame(uri, line, column, member);
      });

  /// Parses a string representation of a Safari 6.0 stack frame.
  @Deprecated('Use Frame.parseSafari instead.')
  factory Frame.parseSafari6_0(String frame) => Frame.parseFirefox(frame);

  /// Parses a string representation of a Safari 6.1+ stack frame.
  @Deprecated('Use Frame.parseSafari instead.')
  factory Frame.parseSafari6_1(String frame) => Frame.parseFirefox(frame);

  /// Parses a string representation of a Safari stack frame.
  factory Frame.parseSafari(String frame) => Frame.parseFirefox(frame);

  /// Parses this package's string representation of a stack frame.
  factory Frame.parseFriendly(String frame) => _catchFormatException(frame, () {
        var match = _friendlyFrame.firstMatch(frame);
        if (match == null) {
          throw FormatException(
              "Couldn't parse package:stack_trace stack trace line '$frame'.");
        }
        // Fake truncated data urls generated by the friendly stack trace format
        // cause Uri.parse to throw an exception so we have to special case
        // them.
        var uri = match[1] == 'data:...'
            ? Uri.dataFromString('')
            : Uri.parse(match[1]!);
        // If there's no scheme, this is a relative URI. We should interpret it
        // as relative to the current working directory.
        if (uri.scheme == '') {
          uri = path.toUri(path.absolute(path.fromUri(uri)));
        }

        var line = match[2] == null ? null : int.parse(match[2]!);
        var column = match[3] == null ? null : int.parse(match[3]!);
        return Frame(uri, line, column, match[4]);
      });

  /// A regular expression matching an absolute URI.
  static final _uriRegExp = RegExp(r'^[a-zA-Z][-+.a-zA-Z\d]*://');

  /// A regular expression matching a Windows path.
  static final _windowsRegExp = RegExp(r'^([a-zA-Z]:[\\/]|\\\\)');

  /// Converts [uriOrPath], which can be a URI, a Windows path, or a Posix path,
  /// to a URI (absolute if possible).
  static Uri _uriOrPathToUri(String uriOrPath) {
    if (uriOrPath.contains(_uriRegExp)) {
      return Uri.parse(uriOrPath);
    } else if (uriOrPath.contains(_windowsRegExp)) {
      return Uri.file(uriOrPath, windows: true);
    } else if (uriOrPath.startsWith('/')) {
      return Uri.file(uriOrPath, windows: false);
    }

    // As far as I've seen, Firefox and V8 both always report absolute paths in
    // their stack frames. However, if we do get a relative path, we should
    // handle it gracefully.
    if (uriOrPath.contains('\\')) return path.windows.toUri(uriOrPath);
    return Uri.parse(uriOrPath);
  }

  /// Runs [body] and returns its result.
  ///
  /// If [body] throws a [FormatException], returns an [UnparsedFrame] with
  /// [text] instead.
  static Frame _catchFormatException(String text, Frame Function() body) {
    try {
      return body();
    } on FormatException catch (_) {
      return UnparsedFrame(text);
    }
  }

  Frame(this.uri, this.line, this.column, this.member);

  @override
  String toString() => '$location in $member';
}

// File: C:\MyDartProjects\eloquent\lib\src\pdo\postgres\dependencies\stack_trace\src\lazy_chain.dart


import 'chain.dart';
import 'frame.dart';
import 'lazy_trace.dart';
import 'trace.dart';

/// A thunk for lazily constructing a [Chain].
typedef ChainThunk = Chain Function();

/// A wrapper around a [ChainThunk]. This works around issue 9579 by avoiding
/// the conversion of native [StackTrace]s to strings until it's absolutely
/// necessary.
class LazyChain implements Chain {
  final ChainThunk _thunk;
  late final Chain _chain = _thunk();

  LazyChain(this._thunk);

  @override
  List<Trace> get traces => _chain.traces;
  @override
  Chain get terse => _chain.terse;
  @override
  Chain foldFrames(bool Function(Frame) predicate, {bool terse = false}) =>
      LazyChain(() => _chain.foldFrames(predicate, terse: terse));
  @override
  Trace toTrace() => LazyTrace(_chain.toTrace);
  @override
  String toString() => _chain.toString();
}

// File: C:\MyDartProjects\eloquent\lib\src\pdo\postgres\dependencies\stack_trace\src\lazy_trace.dart


import 'frame.dart';
import 'trace.dart';

/// A thunk for lazily constructing a [Trace].
typedef TraceThunk = Trace Function();

/// A wrapper around a [TraceThunk]. This works around issue 9579 by avoiding
/// the conversion of native [StackTrace]s to strings until it's absolutely
/// necessary.
class LazyTrace implements Trace {
  final TraceThunk _thunk;
  late final Trace _trace = _thunk();

  LazyTrace(this._thunk);

  @override
  List<Frame> get frames => _trace.frames;
  @override
  StackTrace get original => _trace.original;
  @override
  StackTrace get vmTrace => _trace.vmTrace;
  @override
  Trace get terse => LazyTrace(() => _trace.terse);
  @override
  Trace foldFrames(bool Function(Frame) predicate, {bool terse = false}) =>
      LazyTrace(() => _trace.foldFrames(predicate, terse: terse));
  @override
  String toString() => _trace.toString();
}

// File: C:\MyDartProjects\eloquent\lib\src\pdo\postgres\dependencies\stack_trace\src\stack_zone_specification.dart


import 'dart:async';

import 'chain.dart';
import 'lazy_chain.dart';
import 'lazy_trace.dart';
import 'trace.dart';
import 'utils.dart';

/// A class encapsulating the zone specification for a [Chain.capture] zone.
///
/// Until they're materialized and exposed to the user, stack chains are tracked
/// as linked lists of [Trace]s using the [_Node] class. These nodes are stored
/// in three distinct ways:
///
/// * When a callback is registered, a node is created and stored as a captured
///   local variable until the callback is run.
///
/// * When a callback is run, its captured node is set as the [_currentNode] so
///   it can be available to [Chain.current] and to be linked into additional
///   chains when more callbacks are scheduled.
///
/// * When a callback throws an error or a Future or Stream emits an error, the
///   current node is associated with that error's stack trace using the
///   [_chains] expando.
///
/// Since [ZoneSpecification] can't be extended or even implemented, in order to
/// get a real [ZoneSpecification] instance it's necessary to call [toSpec].
class StackZoneSpecification {
  /// An opaque object used as a zone value to disable chain tracking in a given
  /// zone.
  ///
  /// If `Zone.current[disableKey]` is `true`, no stack chains will be tracked.
  static final disableKey = Object();

  /// Whether chain-tracking is disabled in the current zone.
  bool get _disabled => Zone.current[disableKey] == true;

  /// The expando that associates stack chains with [StackTrace]s.
  ///
  /// The chains are associated with stack traces rather than errors themselves
  /// because it's a common practice to throw strings as errors, which can't be
  /// used with expandos.
  ///
  /// The chain associated with a given stack trace doesn't contain a node for
  /// that stack trace.
  final _chains = Expando<_Node>('stack chains');

  /// The error handler for the zone.
  ///
  /// If this is null, that indicates that any unhandled errors should be passed
  /// to the parent zone.
  final void Function(Object error, Chain)? _onError;

  /// The most recent node of the current stack chain.
  _Node? _currentNode;

  /// Whether this is an error zone.
  final bool _errorZone;

  StackZoneSpecification(this._onError, {bool errorZone = true})
      : _errorZone = errorZone;

  /// Converts this specification to a real [ZoneSpecification].
  ZoneSpecification toSpec() => ZoneSpecification(
      handleUncaughtError: _errorZone ? _handleUncaughtError : null,
      registerCallback: _registerCallback,
      registerUnaryCallback: _registerUnaryCallback,
      registerBinaryCallback: _registerBinaryCallback,
      errorCallback: _errorCallback);

  /// Returns the current stack chain.
  ///
  /// By default, the first frame of the first trace will be the line where
  /// [currentChain] is called. If [level] is passed, the first trace will start
  /// that many frames up instead.
  Chain currentChain([int level = 0]) => _createNode(level + 1).toChain();

  /// Returns the stack chain associated with [trace], if one exists.
  ///
  /// The first stack trace in the returned chain will always be [trace]
  /// (converted to a [Trace] if necessary). If there is no chain associated
  /// with [trace], this just returns a single-trace chain containing [trace].
  Chain chainFor(StackTrace? trace) {
    if (trace is Chain) return trace;
    trace ??= StackTrace.current;

    var previous = _chains[trace] ?? _currentNode;
    if (previous == null) {
      // If there's no [_currentNode], we're running synchronously beneath
      // [Chain.capture] and we should fall back to the VM's stack chaining. We
      // can't use [Chain.from] here because it'll just call [chainFor] again.
      if (trace is Trace) return Chain([trace]);
      return LazyChain(() => Chain.parse(trace!.toString()));
    } else {
      if (trace is! Trace) {
        var original = trace;
        trace = LazyTrace(() => Trace.parse(_trimVMChain(original)));
      }

      return _Node(trace, previous).toChain();
    }
  }

  /// Tracks the current stack chain so it can be set to [_currentNode] when
  /// [f] is run.
  ZoneCallback<R> _registerCallback<R>(
      Zone self, ZoneDelegate parent, Zone zone, R Function() f) {
    if (_disabled) return parent.registerCallback(zone, f);
    var node = _createNode(1);
    return parent.registerCallback(zone, () => _run(f, node));
  }

  /// Tracks the current stack chain so it can be set to [_currentNode] when
  /// [f] is run.
  ZoneUnaryCallback<R, T> _registerUnaryCallback<R, T>(
      Zone self,
      ZoneDelegate parent,
      Zone zone,
      @pragma('vm:awaiter-link') R Function(T) f) {
    if (_disabled) return parent.registerUnaryCallback(zone, f);
    var node = _createNode(1);
    return parent.registerUnaryCallback(
        zone, (arg) => _run(() => f(arg), node));
  }

  /// Tracks the current stack chain so it can be set to [_currentNode] when
  /// [f] is run.
  ZoneBinaryCallback<R, T1, T2> _registerBinaryCallback<R, T1, T2>(
      Zone self, ZoneDelegate parent, Zone zone, R Function(T1, T2) f) {
    if (_disabled) return parent.registerBinaryCallback(zone, f);

    var node = _createNode(1);
    return parent.registerBinaryCallback(
        zone, (arg1, arg2) => _run(() => f(arg1, arg2), node));
  }

  /// Looks up the chain associated with [stackTrace] and passes it either to
  /// [_onError] or [parent]'s error handler.
  void _handleUncaughtError(Zone self, ZoneDelegate parent, Zone zone,
      Object error, StackTrace stackTrace) {
    if (_disabled) {
      parent.handleUncaughtError(zone, error, stackTrace);
      return;
    }

    var stackChain = chainFor(stackTrace);
    if (_onError == null) {
      parent.handleUncaughtError(zone, error, stackChain);
      return;
    }

    // TODO(nweiz): Currently this copies a lot of logic from [runZoned]. Just
    // allow [runBinary] to throw instead once issue 18134 is fixed.
    try {
      // TODO(rnystrom): Is the null-assertion correct here? It is nullable in
      // Zone. Should we check for that here?
      self.parent!.runBinary(_onError!, error, stackChain);
    } on Object catch (newError, newStackTrace) {
      if (identical(newError, error)) {
        parent.handleUncaughtError(zone, error, stackChain);
      } else {
        parent.handleUncaughtError(zone, newError, newStackTrace);
      }
    }
  }

  /// Attaches the current stack chain to [stackTrace], replacing it if
  /// necessary.
  AsyncError? _errorCallback(Zone self, ZoneDelegate parent, Zone zone,
      Object error, StackTrace? stackTrace) {
    if (_disabled) return parent.errorCallback(zone, error, stackTrace);

    // Go up two levels to get through [_CustomZone.errorCallback].
    if (stackTrace == null) {
      stackTrace = _createNode(2).toChain();
    } else {
      if (_chains[stackTrace] == null) _chains[stackTrace] = _createNode(2);
    }

    var asyncError = parent.errorCallback(zone, error, stackTrace);
    return asyncError ?? AsyncError(error, stackTrace);
  }

  /// Creates a [_Node] with the current stack trace and linked to
  /// [_currentNode].
  ///
  /// By default, the first frame of the first trace will be the line where
  /// [_createNode] is called. If [level] is passed, the first trace will start
  /// that many frames up instead.
  _Node _createNode([int level = 0]) =>
      _Node(_currentTrace(level + 1), _currentNode);

  // TODO(nweiz): use a more robust way of detecting and tracking errors when
  // issue 15105 is fixed.
  /// Runs [f] with [_currentNode] set to [node].
  ///
  /// If [f] throws an error, this associates [node] with that error's stack
  /// trace.
  T _run<T>(T Function() f, _Node node) {
    var previousNode = _currentNode;
    _currentNode = node;
    try {
      return f();
    } catch (e, stackTrace) {
      // We can see the same stack trace multiple times if it's rethrown through
      // guarded callbacks.  The innermost chain will have the most
      // information so it should take precedence.
      _chains[stackTrace] ??= node;
      rethrow;
    } finally {
      _currentNode = previousNode;
    }
  }

  /// Like [Trace.current], but if the current stack trace has VM chaining
  /// enabled, this only returns the innermost sub-trace.
  Trace _currentTrace([int? level]) {
    var stackTrace = StackTrace.current;
    return LazyTrace(() {
      var text = _trimVMChain(stackTrace);
      var trace = Trace.parse(text);
      // JS includes a frame for the call to StackTrace.current, but the VM
      // doesn't, so we skip an extra frame in a JS context.
      return Trace(trace.frames.skip((level ?? 0) + (inJS ? 2 : 1)),
          original: text);
    });
  }

  /// Removes the VM's stack chains from the native [trace], since we're
  /// generating our own and we don't want duplicate frames.
  String _trimVMChain(StackTrace trace) {
    var text = trace.toString();
    var index = text.indexOf(vmChainGap);
    return index == -1 ? text : text.substring(0, index);
  }
}

/// A linked list node representing a single entry in a stack chain.
class _Node {
  /// The stack trace for this link of the chain.
  final Trace trace;

  /// The previous node in the chain.
  final _Node? previous;

  _Node(StackTrace trace, [this.previous]) : trace = Trace.from(trace);

  /// Converts this to a [Chain].
  Chain toChain() {
    var nodes = <Trace>[];
    _Node? node = this;
    while (node != null) {
      nodes.add(node.trace);
      node = node.previous;
    }
    return Chain(nodes);
  }
}

// File: C:\MyDartProjects\eloquent\lib\src\pdo\postgres\dependencies\stack_trace\src\trace.dart


import 'dart:math' as math;

import 'chain.dart';
import 'frame.dart';
import 'lazy_trace.dart';
import 'unparsed_frame.dart';
import 'utils.dart';
import 'vm_trace.dart';

final _terseRegExp = RegExp(r'(-patch)?([/\\].*)?$');

/// A RegExp to match V8's stack traces.
///
/// V8's traces start with a line that's either just "Error" or else is a
/// description of the exception that occurred. That description can be multiple
/// lines, so we just look for any line other than the first that begins with
/// three or four spaces and "at".
final _v8Trace = RegExp(r'\n    ?at ');

/// A RegExp to match indidual lines of V8's stack traces.
///
/// This is intended to filter out the leading exception details of the trace
/// though it is possible for the message to match this as well.
final _v8TraceLine = RegExp(r'    ?at ');

/// A RegExp to match Firefox's eval and Function stack traces.
///
/// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error/stack
///
/// These stack traces looks like:
///     anonymous/<@https://example.com/stuff.js line 693 > Function:3:40
///     anonymous/<@https://example.com/stuff.js line 693 > eval:3:40
final _firefoxEvalTrace = RegExp(r'@\S+ line \d+ >.* (Function|eval):\d+:\d+');

/// A RegExp to match Firefox and Safari's stack traces.
///
/// Firefox and Safari have very similar stack trace formats, so we use the same
/// logic for parsing them.
///
/// Firefox's trace frames start with the name of the function in which the
/// error occurred, possibly including its parameters inside `()`. For example,
/// `.VW.call$0("arg")@https://example.com/stuff.dart.js:560`.
///
/// Safari traces occasionally don't include the initial method name followed by
/// "@", and they always have both the line and column number (or just a
/// trailing colon if no column number is available). They can also contain
/// empty lines or lines consisting only of `[native code]`.
final _firefoxSafariTrace = RegExp(
    r'^'
    r'(' // Member description. Not present in some Safari frames.
    r'([.0-9A-Za-z_$/<]|\(.*\))*' // Member name and arguments.
    r'@'
    r')?'
    r'[^\s]*' // Frame URL.
    r':\d*' // Line or column number. Some older frames only have a line number.
    r'$',
    multiLine: true);

/// A RegExp to match this package's stack traces.
final _friendlyTrace =
    RegExp(r'^[^\s<][^\s]*( \d+(:\d+)?)?[ \t]+[^\s]+$', multiLine: true);

/// A stack trace, comprised of a list of stack frames.
class Trace implements StackTrace {
  /// The stack frames that comprise this stack trace.
  final List<Frame> frames;

  /// The original stack trace from which this trace was parsed.
  final StackTrace original;

  /// Returns a human-readable representation of [stackTrace]. If [terse] is
  /// set, this folds together multiple stack frames from the Dart core
  /// libraries, so that only the core library method directly called from user
  /// code is visible (see [Trace.terse]).
  static String format(StackTrace stackTrace, {bool terse = true}) {
    var trace = Trace.from(stackTrace);
    if (terse) trace = trace.terse;
    return trace.toString();
  }

  /// Returns the current stack trace.
  ///
  /// By default, the first frame of this trace will be the line where
  /// [Trace.current] is called. If [level] is passed, the trace will start that
  /// many frames up instead.
  factory Trace.current([int level = 0]) {
    if (level < 0) {
      throw ArgumentError('Argument [level] must be greater than or equal '
          'to 0.');
    }

    var trace = Trace.from(StackTrace.current);
    return LazyTrace(
      () =>
          // JS includes a frame for the call to StackTrace.current, but the VM
          // doesn't, so we skip an extra frame in a JS context.
          Trace(trace.frames.skip(level + (inJS ? 2 : 1)),
              original: trace.original.toString()),
    );
  }

  /// Returns a new stack trace containing the same data as [trace].
  ///
  /// If [trace] is a native [StackTrace], its data will be parsed out; if it's
  /// a [Trace], it will be returned as-is.
  factory Trace.from(StackTrace trace) {
    if (trace is Trace) return trace;
    if (trace is Chain) return trace.toTrace();
    return LazyTrace(() => Trace.parse(trace.toString()));
  }

  /// Parses a string representation of a stack trace.
  ///
  /// [trace] should be formatted in the same way as a Dart VM or browser stack
  /// trace. If it's formatted as a stack chain, this will return the equivalent
  /// of [Chain.toTrace].
  factory Trace.parse(String trace) {
    try {
      if (trace.isEmpty) return Trace(<Frame>[]);
      if (trace.contains(_v8Trace)) return Trace.parseV8(trace);
      if (trace.contains('\tat ')) return Trace.parseJSCore(trace);
      if (trace.contains(_firefoxSafariTrace) ||
          trace.contains(_firefoxEvalTrace)) {
        return Trace.parseFirefox(trace);
      }
      if (trace.contains(chainGap)) return Chain.parse(trace).toTrace();
      if (trace.contains(_friendlyTrace)) {
        return Trace.parseFriendly(trace);
      }

      // Default to parsing the stack trace as a VM trace. This is also hit on
      // IE and Safari, where the stack trace is just an empty string (issue
      // 11257).
      return Trace.parseVM(trace);
    } on FormatException catch (error) {
      throw FormatException('${error.message}\nStack trace:\n$trace');
    }
  }

  /// Parses a string representation of a Dart VM stack trace.
  Trace.parseVM(String trace) : this(_parseVM(trace), original: trace);

  static List<Frame> _parseVM(String trace) {
    // Ignore [vmChainGap]. This matches the behavior of
    // `Chain.parse().toTrace()`.
    var lines = trace
        .trim()
        .replaceAll(vmChainGap, '')
        .split('\n')
        .where((line) => line.isNotEmpty);

    if (lines.isEmpty) {
      return [];
    }

    var frames = lines.take(lines.length - 1).map(Frame.parseVM).toList();

    // TODO(nweiz): Remove this when issue 23614 is fixed.
    if (!lines.last.endsWith('.da')) {
      frames.add(Frame.parseVM(lines.last));
    }

    return frames;
  }

  /// Parses a string representation of a Chrome/V8 stack trace.
  Trace.parseV8(String trace)
      : this(
            trace
                .split('\n')
                .skip(1)
                // It's possible that an Exception's description contains a line
                // that looks like a V8 trace line, which will screw this up.
                // Unfortunately, that's impossible to detect.
                .skipWhile((line) => !line.startsWith(_v8TraceLine))
                .map(Frame.parseV8),
            original: trace);

  /// Parses a string representation of a JavaScriptCore stack trace.
  Trace.parseJSCore(String trace)
      : this(
            trace
                .split('\n')
                .where((line) => line != '\tat ')
                .map(Frame.parseV8),
            original: trace);

  /// Parses a string representation of an Internet Explorer stack trace.
  ///
  /// IE10+ traces look just like V8 traces. Prior to IE10, stack traces can't
  /// be retrieved.
  Trace.parseIE(String trace) : this.parseV8(trace);

  /// Parses a string representation of a Firefox stack trace.
  Trace.parseFirefox(String trace)
      : this(
            trace
                .trim()
                .split('\n')
                .where((line) => line.isNotEmpty && line != '[native code]')
                .map(Frame.parseFirefox),
            original: trace);

  /// Parses a string representation of a Safari stack trace.
  Trace.parseSafari(String trace) : this.parseFirefox(trace);

  /// Parses a string representation of a Safari 6.1+ stack trace.
  @Deprecated('Use Trace.parseSafari instead.')
  Trace.parseSafari6_1(String trace) : this.parseSafari(trace);

  /// Parses a string representation of a Safari 6.0 stack trace.
  @Deprecated('Use Trace.parseSafari instead.')
  Trace.parseSafari6_0(String trace)
      : this(
            trace
                .trim()
                .split('\n')
                .where((line) => line != '[native code]')
                .map(Frame.parseFirefox),
            original: trace);

  /// Parses this package's string representation of a stack trace.
  ///
  /// This also parses string representations of [Chain]s. They parse to the
  /// same trace that [Chain.toTrace] would return.
  Trace.parseFriendly(String trace)
      : this(
            trace.isEmpty
                ? []
                : trace
                    .trim()
                    .split('\n')
                    // Filter out asynchronous gaps from [Chain]s.
                    .where((line) => !line.startsWith('====='))
                    .map(Frame.parseFriendly),
            original: trace);

  /// Returns a new [Trace] comprised of [frames].
  Trace(Iterable<Frame> frames, {String? original})
      : frames = List<Frame>.unmodifiable(frames),
        original = StackTrace.fromString(original ?? '');

  /// Returns a VM-style [StackTrace] object.
  ///
  /// The return value's [toString] method will always return a string
  /// representation in the Dart VM's stack trace format, regardless of what
  /// platform is being used.
  StackTrace get vmTrace => VMTrace(frames);

  /// Returns a terser version of this trace.
  ///
  /// This is accomplished by folding together multiple stack frames from the
  /// core library or from this package, as in [foldFrames]. Remaining core
  /// library frames have their libraries, "-patch" suffixes, and line numbers
  /// removed. If the outermost frame of the stack trace is a core library
  /// frame, it's removed entirely.
  ///
  /// This won't do anything with a raw JavaScript trace, since there's no way
  /// to determine which frames come from which Dart libraries. However, the
  /// [`source_map_stack_trace`][https://pub.dev/packages/source_map_stack_trace]
  /// package can be used to convert JavaScript traces into Dart-style traces.
  ///
  /// For custom folding, see [foldFrames].
  Trace get terse => foldFrames((_) => false, terse: true);

  /// Returns a new [Trace] based on `this` where multiple stack frames matching
  /// [predicate] are folded together.
  ///
  /// This means that whenever there are multiple frames in a row that match
  /// [predicate], only the last one is kept. This is useful for limiting the
  /// amount of library code that appears in a stack trace by only showing user
  /// code and code that's called by user code.
  ///
  /// If [terse] is true, this will also fold together frames from the core
  /// library or from this package, simplify core library frames, and
  /// potentially remove the outermost frame as in [Trace.terse].
  Trace foldFrames(bool Function(Frame) predicate, {bool terse = false}) {
    if (terse) {
      var oldPredicate = predicate;
      predicate = (frame) {
        if (oldPredicate(frame)) return true;

        if (frame.isCore) return true;
        if (frame.package == 'stack_trace') return true;

        // Ignore async stack frames without any line or column information.
        // These come from the VM's async/await implementation and represent
        // internal frames. They only ever show up in stack chains and are
        // always surrounded by other traces that are actually useful, so we can
        // just get rid of them.
        // TODO(nweiz): Get rid of this logic some time after issue 22009 is
        // fixed.
        if (!frame.member!.contains('<async>')) return false;
        return frame.line == null;
      };
    }

    var newFrames = <Frame>[];
    for (var frame in frames.reversed) {
      if (frame is UnparsedFrame || !predicate(frame)) {
        newFrames.add(frame);
      } else if (newFrames.isEmpty || !predicate(newFrames.last)) {
        newFrames.add(Frame(frame.uri, frame.line, frame.column, frame.member));
      }
    }

    if (terse) {
      newFrames = newFrames.map((frame) {
        if (frame is UnparsedFrame || !predicate(frame)) return frame;
        var library = frame.library.replaceAll(_terseRegExp, '');
        return Frame(Uri.parse(library), null, null, frame.member);
      }).toList();

      if (newFrames.length > 1 && predicate(newFrames.first)) {
        newFrames.removeAt(0);
      }
    }

    return Trace(newFrames.reversed, original: original.toString());
  }

  @override
  String toString() {
    // Figure out the longest path so we know how much to pad.
    var longest =
        frames.map((frame) => frame.location.length).fold(0, math.max);

    // Print out the stack trace nicely formatted.
    return frames.map((frame) {
      if (frame is UnparsedFrame) return '$frame\n';
      return '${frame.location.padRight(longest)}  ${frame.member}\n';
    }).join();
  }
}

// File: C:\MyDartProjects\eloquent\lib\src\pdo\postgres\dependencies\stack_trace\src\unparsed_frame.dart

import 'frame.dart';

/// A frame that failed to parse.
///
/// The [member] property contains the original frame's contents.
class UnparsedFrame implements Frame {
  @override
  final Uri uri = Uri(path: 'unparsed');
  @override
  final int? line = null;
  @override
  final int? column = null;
  @override
  final bool isCore = false;
  @override
  final String library = 'unparsed';
  @override
  final String? package = null;
  @override
  final String location = 'unparsed';

  @override
  final String member;

  UnparsedFrame(this.member);

  @override
  String toString() => member;
}

// File: C:\MyDartProjects\eloquent\lib\src\pdo\postgres\dependencies\stack_trace\src\utils.dart
/// The line used in the string representation of stack chains to represent
/// the gap between traces.
const chainGap = '===== asynchronous gap ===========================\n';

/// The line used in the string representation of VM stack chains to represent
/// the gap between traces.
final vmChainGap = RegExp(r'^<asynchronous suspension>\n?$', multiLine: true);

// TODO(nweiz): When cross-platform imports work, use them to set this.
/// Whether we're running in a JS context.
const bool inJS = 0.0 is int;

// File: C:\MyDartProjects\eloquent\lib\src\pdo\postgres\dependencies\stack_trace\src\vm_trace.dart
import 'frame.dart';

/// An implementation of [StackTrace] that emulates the behavior of the VM's
/// implementation.
///
/// In particular, when [toString] is called, this returns a string in the VM's
/// stack trace format.
class VMTrace implements StackTrace {
  /// The stack frames that comprise this stack trace.
  final List<Frame> frames;

  VMTrace(this.frames);

  @override
  String toString() {
    var i = 1;
    return frames.map((frame) {
      var number = '#${i++}'.padRight(8);
      var member = frame.member!
          .replaceAllMapped(RegExp(r'[^.]+\.<async>'),
              (match) => '${match[1]}.<${match[1]}_async_body>')
          .replaceAll('<fn>', '<anonymous closure>');
      var line = frame.line ?? 0;
      var column = frame.column ?? 0;
      return '$number$member (${frame.uri}:$line:$column)\n';
    }).join();
  }
}

// File: C:\MyDartProjects\eloquent\lib\src\pdo\postgres\dependencies\stack_trace\stack_trace.dart
export 'src/chain.dart';
export 'src/frame.dart';
export 'src/trace.dart';
export 'src/unparsed_frame.dart';

// File: C:\MyDartProjects\eloquent\lib\src\pdo\postgres\postgres_pdo.dart
import 'dart:convert';

import 'package:eloquent/eloquent.dart';
import 'package:enough_convert/windows.dart';
import 'postgres_pdo_transaction.dart';
import 'package:postgres_fork/postgres.dart';

import 'dependencies/postgres_pool/postgres_pool.dart';

class PostgresPDO extends PDOInterface {
  /// default query Timeout =  30 seconds
  static const defaultTimeoutInSeconds = 30;

  PDOConfig config;

  /// Creates a PDO instance representing a connection to a database
  /// Example
  ///
  ///
  /// Example:  Map<String, dynamic> config = {'host': 'localhost','port':5432,'database':'teste'};
  /// var pdo = new PDO(PDOConfig.fromMap(config));
  /// await pdo.connect();
  ///
  PostgresPDO(this.config) {
    super.pdoInstance = this;
  }

  /// CoreConnection
  late dynamic connection;

  Encoding _getEncoding(String encoding) {
    switch (encoding.toLowerCase()) {
      case 'utf8':
        return Utf8Codec();
      case 'ascii':
        return AsciiCodec();
      case 'latin1':
        return Latin1Codec();
      case 'iso-8859-1':
        return Latin1Codec();
      case 'win1252':
        //WIN1250	Windows CP1250 | cp1252
        return Windows1252Codec(allowInvalid: false);
      default:
        return Utf8Codec(allowMalformed: true);
    }
  }

  //called from postgres_connector.dart
  Future<PostgresPDO> connect() async {
    final timeZone = TimeZoneSettings(config.timezone ?? 'UTC');
    timeZone.forceDecodeTimestamptzAsUTC = config.forceDecodeTimestamptzAsUTC;
    timeZone.forceDecodeTimestampAsUTC = config.forceDecodeTimestampAsUTC;
    timeZone.forceDecodeDateAsUTC = config.forceDecodeDateAsUTC;

    if (config.pool == true) {
      final endpoint = PgEndpoint(
        host: config.host,
        port: config.port,
        database: config.database,
        username: config.username,
        password: config.password,
      );
      final settings = PgPoolSettings();
      settings.encoding = _getEncoding(config.charset ?? 'utf8');
      settings.maxConnectionCount = config.poolSize ?? 1;
      settings.onOpen = (conn) async {
        await _onOpen(conn, config);
      };
      settings.timeZone = timeZone;
      connection = PgPool(endpoint, settings: settings);
      //print('dsnParser.pool ${dsnParser.pool} $connection');
    } else {
      connection = PostgreSQLConnection(
        config.host,
        config.port,
        config.database,
        username: config.username,
        password: config.password,
        timeZone: timeZone,
        encoding: _getEncoding(config.charset ?? 'utf8'),
      );
      final conn = connection as PostgreSQLConnection;
      await conn.open();
      await _onOpen(conn, config);
    }

    return this;
  }

  /// inicializa configurações ao conectar com o banco de dados
  Future<void> _onOpen(PostgreSQLExecutionContext conn, PDOConfig conf) async {
    if (conf.charset != null) {
      await conn.execute("SET client_encoding = '${conf.charset}'");
    }
    if (conf.schema != null) {
      await conn.execute("SET search_path TO ${conf.schema}");
    }
    if (conf.timezone != null) {
      await conn.execute("SET timezone TO '${conf.timezone}'");
    }
    if (conf.applicationName != null) {
      await conn.execute("SET application_name TO '${conf.applicationName}'");
    }
  }

  Future<T> runInTransaction<T>(Future<T> operation(PostgresPDOTransaction ctx),
      [int? timeoutInSeconds]) async {
    if (timeoutInSeconds == null) {
      timeoutInSeconds = defaultTimeoutInSeconds;
    }
    if (connection is PostgreSQLConnection) {
      final res = await (connection as PostgreSQLConnection).transaction(
          (transaCtx) async {
        final pdoCtx = PostgresPDOTransaction(transaCtx, this);
        return operation(pdoCtx);
      }, commitTimeoutInSeconds: timeoutInSeconds);
      return res as T;
    } else {
      final res = await (connection as PgPool).runTx(
        (transaCtx) async {
          final pdoCtx = PostgresPDOTransaction(transaCtx, this);
          return operation(pdoCtx);
        },
      ).timeout(Duration(seconds: timeoutInSeconds));
      return res;
    }
  }

  /// Executa uma instrução SQL e retornar o número de linhas afetadas
  Future<int> execute(String statement, [int? timeoutInSeconds]) async {
    if (timeoutInSeconds == null) {
      timeoutInSeconds = defaultTimeoutInSeconds;
    }
    if (connection is PostgreSQLConnection) {
      final result = await (connection as PostgreSQLConnection).execute(
          statement,
          timeoutInSeconds: timeoutInSeconds,
          placeholderIdentifier: PlaceholderIdentifier.onlyQuestionMark);
      return result;
    } else {
      final result = await (connection as PgPool).execute(statement,
          timeoutInSeconds: timeoutInSeconds,
          placeholderIdentifier: PlaceholderIdentifier.onlyQuestionMark);
      return result;
    }
  }

  /// Prepares and executes an SQL statement
  Future<PDOResults> query(String query,
      [dynamic params, int? timeoutInSeconds]) async {
    if (timeoutInSeconds == null) {
      timeoutInSeconds = defaultTimeoutInSeconds;
    }
    if (connection is PostgreSQLConnection) {
      final rs = await (connection as PostgreSQLConnection).query(
        query,
        substitutionValues: params,
        // allowReuse: allowReuse ?? false,
        timeoutInSeconds: timeoutInSeconds,
        placeholderIdentifier: PlaceholderIdentifier.onlyQuestionMark,
      );
      final rows = rs.map((row) => row.toColumnMap()).toList();
      final pdoResult = PDOResults(rows, rs.affectedRowCount);
      return pdoResult;
    } else {
      final rs = await (connection as PgPool).query(
        query,
        substitutionValues: params,
        // allowReuse: allowReuse ?? false,
        timeoutInSeconds: timeoutInSeconds,
        placeholderIdentifier: PlaceholderIdentifier.onlyQuestionMark,
      );
      final rows = rs.map((row) => row.toColumnMap()).toList();
      final pdoResult = PDOResults(rows, rs.affectedRowCount);
      return pdoResult;
    }
  }

  @override
  Future close() async {
    if (connection is PostgreSQLConnection) {
      await (connection as PostgreSQLConnection).close();
    } else {
      await (connection as PgPool).close();
    }
  }
}

// File: C:\MyDartProjects\eloquent\lib\src\pdo\postgres\postgres_pdo_transaction.dart
import 'package:eloquent/eloquent.dart';
import 'package:postgres_fork/postgres.dart';

import 'postgres_pdo.dart';

class PostgresPDOTransaction extends PDOExecutionContext {
  final PostgreSQLExecutionContext transactionContext;

  PostgresPDOTransaction(this.transactionContext, PDOInterface pdo) {
    super.pdoInstance = pdo;
  }

  Future<int> execute(String statement, [int? timeoutInSeconds]) {
    if (timeoutInSeconds == null) {
      timeoutInSeconds = PostgresPDO.defaultTimeoutInSeconds;
    }
    return transactionContext.execute(
      statement,
      timeoutInSeconds: timeoutInSeconds,
      placeholderIdentifier: PlaceholderIdentifier.onlyQuestionMark,
    );
  }

  /// Prepares and executes an SQL statement without placeholders
  Future<PDOResults> query(String query,
      [dynamic params, int? timeoutInSeconds]) async {
    if (timeoutInSeconds == null) {
      timeoutInSeconds = PostgresPDO.defaultTimeoutInSeconds;
    }
    // final rows = await connection.mappedResultsQuery(
    //   query,
    //   substitutionValues: params,
    //   timeoutInSeconds: timeoutInSeconds,
    //   placeholderIdentifier: PlaceholderIdentifier.onlyQuestionMark,
    // );

    final rs = await transactionContext.query(
      query,
      substitutionValues: params,
      // allowReuse: allowReuse ?? false,
      timeoutInSeconds: timeoutInSeconds,
      placeholderIdentifier: PlaceholderIdentifier.onlyQuestionMark,
    );

    final rows = rs.map((row) => row.toTableColumnMap()).toList();

    final maps = <Map<String, dynamic>>[];
    if (rows.isNotEmpty) {
      for (var item in rows) {
        //Combine/merge multiple maps into 1 map
        maps.add(item.values.reduce((map1, map2) => map1..addAll(map2)));
      }
    }

    final pdoResult = PDOResults(maps, rs.affectedRowCount);
    return pdoResult;
  }
}

// File: C:\MyDartProjects\eloquent\lib\src\pdo\postgres_v3\postgres_v3_pdo.dart
import 'dart:convert';
import 'package:eloquent/src/pdo/core/pdo_config.dart';
import 'package:eloquent/src/pdo/core/pdo_interface.dart';
import 'package:eloquent/src/pdo/core/pdo_result.dart';
import 'package:enough_convert/windows.dart';
import 'package:postgres/postgres.dart';
import 'postgres_v3_pdo_transaction.dart';

class PostgresV3PDO extends PDOInterface {
  /// default query Timeout =  30 seconds
  static const defaultTimeoutInSeconds = 30;

  PDOConfig config;

  /// Creates a PDO instance representing a connection to a database
  /// Example
  ///
  ///
  /// Example:  Map<String, dynamic> config = {'host': 'localhost','port':5432,'database':'teste'};
  /// var pdo = new PDO(PDOConfig.fromMap(config));
  /// await pdo.connect();
  ///
  PostgresV3PDO(this.config) {
    super.pdoInstance = this;
  }

  /// postgres V3 Connection
  late dynamic connection;

  Encoding _getEncoding(String encoding) {
    switch (encoding.toLowerCase()) {
      case 'utf8':
        return Utf8Codec();
      case 'ascii':
        return AsciiCodec();
      case 'latin1':
        return Latin1Codec();
      case 'iso-8859-1':
        return Latin1Codec();
      case 'win1252':
        //WIN1250	Windows CP1250 | cp1252
        return Windows1252Codec(allowInvalid: false);
      default:
        return Utf8Codec(allowMalformed: true);
    }
  }

  //called from postgres_connector.dart
  Future<PostgresV3PDO> connect() async {
    final endpoint = Endpoint(
      host: config.host,
      port: config.port,
      database: config.database,
      username: config.username,
      password: config.password,
    );

    final sslMode = config.sslmode?.toString() == 'require'
        ? SslMode.require
        : SslMode.disable;

    if (config.pool == true) {
      connection = Pool.withEndpoints(
        [endpoint],
        settings: PoolSettings(
          applicationName: config.applicationName,
          timeZone: config.timezone,
          onOpen: (conn) async {
            await _onOpen(conn, config);
          },
          maxConnectionCount: config.poolSize,
          encoding: _getEncoding(config.charset ?? 'utf8'),
          sslMode: sslMode,
        ),
      );
    } else {
      connection = await Connection.open(endpoint,
          settings: ConnectionSettings(
            applicationName: config.applicationName,
            timeZone: config.timezone,
            onOpen: (conn) async {
              await _onOpen(conn, config);
            },
            encoding: _getEncoding(config.charset ?? 'utf8'),
            sslMode: sslMode,
          ));
    }

    return this;
  }

  /// inicializa configurações ao conectar com o banco de dados
  Future<void> _onOpen(Connection conn, PDOConfig dsnParser) async {
    if (dsnParser.charset != null) {
      await conn.execute("SET client_encoding = '${dsnParser.charset}'");
    }
    if (dsnParser.schema != null) {
      await conn.execute("SET search_path TO ${dsnParser.schema}");
    }
    if (dsnParser.timezone != null) {
      await conn.execute("SET timezone TO '${dsnParser.timezone}'");
    }
    if (dsnParser.applicationName != null) {
      await conn
          .execute("SET application_name TO '${dsnParser.applicationName}'");
    }
  }

  Future<T> runInTransaction<T>(
      Future<T> operation(PostgresV3PDOTransaction ctx),
      [int? timeoutInSeconds]) async {
    if (timeoutInSeconds == null) {
      timeoutInSeconds = defaultTimeoutInSeconds;
    }

    final res = await connection.runTx((transaCtx) async {
      final pdoCtx = PostgresV3PDOTransaction(transaCtx, this);
      return operation(pdoCtx);
    });

    return res;
  }

  /// Executa uma instrução SQL e retornar o número de linhas afetadas
  Future<int> execute(String statement, [int? timeoutInSeconds]) async {
    if (timeoutInSeconds == null) {
      timeoutInSeconds = PostgresV3PDO.defaultTimeoutInSeconds;
    }
    final res = await connection.execute(
      statement,
      timeout: Duration(seconds: timeoutInSeconds),
    );
    return res.affectedRows;
  }

  /// Prepares and executes an SQL statement with placeholders
  Future<PDOResults> query(String query,
      [dynamic params, int? timeoutInSeconds]) async {
    if (timeoutInSeconds == null) {
      timeoutInSeconds = PostgresV3PDO.defaultTimeoutInSeconds;
    }

    // final conn = connection is Pool ? connection as Pool : connection as Connection;

    final rs = await connection.execute(
      Sql.indexed(query, substitution: '?'),
      parameters: params,
      timeout: Duration(seconds: timeoutInSeconds),
    );

    final rows = rs.map((row) => row.toColumnMap()).toList();
    final maps = <Map<String, dynamic>>[];
    if (rows.isNotEmpty) {
      for (final row in rows) {
        final map = <String, dynamic>{};
        for (final col in row.entries) {
          final key = col.key;
          final value =
              col.value is UndecodedBytes ? col.value.asString : col.value;
          map.addAll({key: value});
        }
        maps.add(map);
      }
    }

    final pdoResult = PDOResults(maps, rs.affectedRows);
    return pdoResult;
  }

  @override
  Future close() async {
    // print('postgres_v3_pdo@close isOpen ${(connection).isOpen} ');
    if (connection is Connection) {
      await (connection as Connection).close();
    } else if (connection is Pool) {
      await (connection as Pool).close();
    }
    //print('postgres_v3_pdo@close isOpen ${(connection).isOpen} ');
  }
}

// File: C:\MyDartProjects\eloquent\lib\src\pdo\postgres_v3\postgres_v3_pdo_transaction.dart
import 'package:eloquent/src/pdo/core/pdo_execution_context.dart';
import 'package:eloquent/src/pdo/core/pdo_interface.dart';
import 'package:eloquent/src/pdo/core/pdo_result.dart';
import 'package:postgres/postgres.dart';
import 'postgres_v3_pdo.dart';

class PostgresV3PDOTransaction extends PDOExecutionContext {
  final TxSession transactionContext;

  PostgresV3PDOTransaction(this.transactionContext, PDOInterface pdo) {
    super.pdoInstance = pdo;
  }

  Future<int> execute(String statement, [int? timeoutInSeconds]) async {
    if (timeoutInSeconds == null) {
      timeoutInSeconds = PostgresV3PDO.defaultTimeoutInSeconds;
    }
    final res = await transactionContext.execute(
      statement,
      timeout: Duration(seconds: timeoutInSeconds),
    );
    return res.affectedRows;
  }

  /// Prepares and executes an SQL statement with placeholders
  Future<PDOResults> query(String query,
      [dynamic params, int? timeoutInSeconds]) async {
    if (timeoutInSeconds == null) {
      timeoutInSeconds = PostgresV3PDO.defaultTimeoutInSeconds;
    }

    final rs = await transactionContext.execute(
      Sql.indexed(query, substitution: '?'),
      parameters: params,
      timeout: Duration(seconds: timeoutInSeconds),
    );

    final rows = rs.map((row) => row.toColumnMap()).toList();
    final maps = <Map<String, dynamic>>[];
    if (rows.isNotEmpty) {
      for (final row in rows) {
        final map = <String, dynamic>{};
        for (final col in row.entries) {
          final key = col.key;
          final value =
              col.value is UndecodedBytes ? col.value.asString : col.value;
          map.addAll({key: value});
        }
        maps.add(map);
      }
    }

    final pdoResult = PDOResults(maps, rs.affectedRows);
    return pdoResult;
  }
}

// File: C:\MyDartProjects\eloquent\lib\src\postgres_connection.dart
import 'package:eloquent/eloquent.dart';
import 'package:eloquent/src/query/processors/postgres_processor.dart';

class PostgresConnection extends Connection {
  PostgresConnection(PDOExecutionContext pdoP,
      [String databaseP = '',
      String tablePrefixP = '',
      Map<String, dynamic> configP = const {}])
      : super(pdoP, databaseP, tablePrefixP, configP);

  ///
  /// Execute a Closure within a transaction.
  ///
  /// @param  Function  callback
  /// @return mixed
  ///
  /// @throws \Throwable
  Future<dynamic> transaction(Future<dynamic> Function(Connection ctx) callback,
      [int? timeoutInSeconds]) async {
    var result = this.pdo.pdoInstance.runInTransaction((pdoCtx) {
      final newConnection = PostgresConnection(pdoCtx, this.getDatabaseName(),
          this.getTablePrefix(), this.getConfigs());
      return callback(newConnection);
    });

    return result;
  }

  ///
  /// Get the default query grammar instance.
  ///
  /// @return \Illuminate\Database\Query\Grammars\PostgresGrammar
  ///
  QueryGrammar getDefaultQueryGrammar() {
    //QueryGrammar()
    return withTablePrefix(QueryPostgresGrammar());
  }

  ///
  /// Get the default schema grammar instance.
  ///
  /// @return \Illuminate\Database\Schema\Grammars\PostgresGrammar
  ///
  SchemaGrammar getDefaultSchemaGrammar() {   
    return this.withTablePrefix(SchemaPostgresGrammar());
  }

  ///
  /// Get the default post processor instance.
  ///
  /// @return \Illuminate\Database\Query\Processors\PostgresProcessor
  ///
  PostgresProcessor getDefaultPostProcessor() {
    return PostgresProcessor();
  }

  ///
  /// Get the Doctrine DBAL driver.
  ///
  /// @return \Doctrine\DBAL\Driver\PDOPgSql\Driver
  ///
  // dynamic getDoctrineDriver()
  // {
  //     return new DoctrineDriver;
  // }
}

// File: C:\MyDartProjects\eloquent\lib\src\query\expression.dart
/// class Expression
class QueryExpression {
  ///
  ///  The value of the expression.
  ///
  ///  @var mixed
  ///
  dynamic value;

  ///
  ///  Create a new raw query expression.
  ///
  ///  @param  mixed  $value
  ///  @return void
  ///
  QueryExpression(this.value);

  ///
  ///  Get the value of the expression.
  ///
  ///  @return mixed
  ///
  dynamic getValue() {
    return value;
  }

  ///
  ///  Get the value of the expression.
  ///
  ///  @return string
  ///
  @override
  String toString() {
    return getValue().toString();
  }
}

// File: C:\MyDartProjects\eloquent\lib\src\query\grammars\query_grammar.dart
import 'package:eloquent/eloquent.dart';

class QueryGrammar extends BaseGrammar {
  /// chama um determinado metodo com base no nome
  /// este metodo é para evitar reflexão dart:mirror
  dynamic callMethod(
    String methodName,
    List<dynamic> positionalArguments, [
    Map<Symbol, dynamic> namedArguments = const <Symbol, dynamic>{},
  ]) {
    switch (methodName.toLowerCase()) {
      case 'compilecolumns':
        return compileColumns(positionalArguments[0], positionalArguments[1]);
      case 'compilefrom':
        return compileFrom(positionalArguments[0], positionalArguments[1]);
      case 'compilewheres':
        return compileWheres(positionalArguments[0]);
      case 'compilelimit':
        return compileLimit(positionalArguments[0], positionalArguments[1]);
      case 'compileoffset':
        return compileOffset(positionalArguments[0], positionalArguments[1]);
      //
      case 'compilegroups':
        return compileGroups(positionalArguments[0], positionalArguments[1]);
      case 'compilehaving':
        return compileHaving(positionalArguments[0]);
      case 'compileorders':
        return compileOrders(positionalArguments[0], positionalArguments[1]);
      case 'compileaggregate':
        return compileAggregate(positionalArguments[0], positionalArguments[1]);
      case 'compilejoins':
        return compileJoins(positionalArguments[0], positionalArguments[1]);

      //wheres
      case 'wherenested':
        return whereNested(positionalArguments[0], positionalArguments[1]);
      case 'wheresub':
        return whereSub(positionalArguments[0], positionalArguments[1]);

      case 'wherebasic':
        return whereBasic(positionalArguments[0], positionalArguments[1]);
      case 'wherebetween':
        return whereBetween(positionalArguments[0], positionalArguments[1]);
      case 'whereexists':
        return whereExists(positionalArguments[0], positionalArguments[1]);
      case 'wherenotexists':
        return whereNotExists(positionalArguments[0], positionalArguments[1]);
      case 'wherein':
        return whereIn(positionalArguments[0], positionalArguments[1]);
      case 'wherenotin':
        return whereNotIn(positionalArguments[0], positionalArguments[1]);
      case 'whereinsub':
        return whereInSub(positionalArguments[0], positionalArguments[1]);
      case 'wherenotinsub':
        return whereNotInSub(positionalArguments[0], positionalArguments[1]);
      case 'wherenull':
        return whereNull(positionalArguments[0], positionalArguments[1]);
      case 'wherenotnull':
        return whereNotNull(positionalArguments[0], positionalArguments[1]);
      case 'wheredate':
        return whereDate(positionalArguments[0], positionalArguments[1]);
      case 'whereday':
        return whereDay(positionalArguments[0], positionalArguments[1]);
      case 'wheremonth':
        return whereMonth(positionalArguments[0], positionalArguments[1]);
      case 'whereyear':
        return whereYear(positionalArguments[0], positionalArguments[1]);
      case 'whereraw':
        return whereRaw(positionalArguments[0], positionalArguments[1]);

      default:
        throw Exception("method '$methodName' not exist in QueryGrammar class");
    }
  }

  ///
  ///  The components that make up a select clause.
  ///
  ///  @var array
  ///
  List<String> selectComponents = [
    'aggregate',
    'columns',
    'from',
    'joins',
    'wheres',
    'groups',
    'havings',
    'orders',
    'limit',
    'offset',
    'unions',
    'lock',
  ];

  ///
  ///  Compile a select query into SQL.
  ///
  ///  @param  QueryBuilder  $query
  ///  @return String
  ///
  String compileSelect(QueryBuilder query) {
    var queryColumns = query.getColumns();
    var original = queryColumns != null ? [...queryColumns] : null;

    if (Utils.is_null(query.columnsProp)) {
      query.columnsProp = ['*'];
    }
    var compiledComps = compileComponents(query);

    var sql = Utils.trim(concatenate(compiledComps));

    query.setColumns(original);

    return sql;
  }

  ///
  ///  Compile the components necessary for a select clause.
  ///
  ///  @param  \Illuminate\Database\Query\Builder  $query
  ///  @return array Map
  ///
  Map<String, dynamic> compileComponents(QueryBuilder query) {
    var sql = <String, dynamic>{};

    for (var component in this.selectComponents) {
      // To compile the query, we'll spin through each component of the query and
      // see if that component exists. If it does we'll just call the compiler
      // function for the component which is responsible for making the SQL.
      if (!Utils.is_null_or_empty(query.getProperty(component))) {
        final methodName = 'compile' + Utils.ucfirst(component);

        //print('QueryGrammar@compileComponents this: ${this}');
        //print('QueryGrammar@compileComponents property: ${component}');
        var extraParam = query.getProperty(component);
        //print('QueryGrammar@compileComponents extraParam $extraParam');

        //sql[component] = Utils.call_method(this, methodName, [query, extraParam]);
        sql[component] = callMethod(methodName, [query, extraParam]);
        // print('QueryGrammar@compileComponents methodName: $methodName');
        // print('QueryGrammar@compileComponents sql: $sql');
      }
    }

    return sql;
  }

  ///
  ///  Compile an aggregated select clause.
  ///
  ///  @param  \Illuminate\Database\Query\Builder  query
  ///  @param  array Map aggregate
  ///  @return String
  ///
  String compileAggregate(QueryBuilder query, Map<String, dynamic> aggregate) {
    var column = columnize(aggregate['columns']);
    // print('compileAggregate aggregate: $aggregate');
    // print('compileAggregate column: $column');

    // If the query has a "distinct" constraint and we're not asking for all columns
    // we need to prepend "distinct" onto the column name so that the query takes
    // it into account when it performs the aggregating operations on the data.
    if (query.distinctProp && column != '*') {
      column = 'distinct ' + column;
    }

    return 'select ' + aggregate['function'] + '(' + column + ') as aggregate';
  }

  ///
  ///  Compile the "select *" portion of the query.
  ///
  ///  [query] QueryBuilder \Illuminate\Database\Query\Builder
  ///  [columns] List<String> | List<dynamic> | List<QueryExpression>
  ///  @return String|null
  ///
  String? compileColumns(QueryBuilder query, columns) {
    // If the query is actually performing an aggregating select, we will let that
    // compiler handle the building of the select clauses, as it will need some
    // more syntax that is best handled by that function to keep things neat.
    if (query.aggregateProp != null) {
      return null;
    }

    var select = query.distinctProp ? 'select distinct ' : 'select ';

    final result = select + this.columnize(columns);

    return result;
  }

  ///
  ///  Compile the "from" portion of the query.
  ///
  ///  [query]  QueryBuilder
  ///  [table] String|QueryExpression
  ///  `Return` String
  ///
  String compileFrom(QueryBuilder query, dynamic table) {
    return 'from ' + this.wrapTable(table);
  }

  ///
  ///  Compile the "join" portions of the query.
  ///
  ///  @param  \Illuminate\Database\Query\Builder  $query
  ///  @param  array  $joins
  ///  @return String
  ///
  String compileJoins(QueryBuilder query, List<JoinClause> joins) {
    //print('compileJoins joins: $joins');
    var sql = [];

    for (var join in joins) {
      var table = this.wrapTable(join.table);

      // First we need to build all of the "on" clauses for the join. There may be many
      // of these clauses so we will need to iterate through each one and build them
      // separately, then we'll join them up into a single string when we're done.
      var clauses = [];

      for (var clause in join.clauses) {
        clauses.add(this.compileJoinConstraint(clause));
      }

      // Once we have constructed the clauses, we'll need to take the boolean connector
      // off of the first clause as it obviously will not be required on that clause
      // because it leads the rest of the clauses, thus not requiring any boolean.
      clauses[0] = this.removeLeadingBoolean(clauses[0]);

      final clausesString = Utils.implode(' ', clauses);

      var type = join.type;

      // Once we have everything ready to go, we will just concatenate all the parts to
      // build the final join statement SQL for the query and we can then return the
      // final clause back to the callers as a single, stringified join statement.
      sql.add("$type join $table on $clausesString");
    }

    return Utils.implode(' ', sql);
  }

  ///
  ///  Create a join clause constraint segment.
  ///
  ///  @param  array  $clause
  ///  @return String
  ///
  String compileJoinConstraint(Map<String, dynamic> clause) {
    if (clause['nested']) {
      return this.compileNestedJoinConstraint(clause);
    }

    var first = this.wrap(clause['first']);
    var second;
    if (clause['where']) {
      if (clause['operator'] == 'in' || clause['operator'] == 'not in') {
        second = '(' +
            Utils.implode(', ', Utils.array_fill(0, clause['second'], '?')) +
            ')';
      } else {
        second = '?';
      }
    } else {
      second = this.wrap(clause['second']);
    }

    return "${clause['boolean']} $first ${clause['operator']} $second";
  }

  ///
  ///  Create a nested join clause constraint segment.
  ///
  ///  @param  array  $clause
  ///  @return String
  ///
  String compileNestedJoinConstraint(Map clause) {
    final clauses = [];
    for (var nestedClause in clause['join'].clauses) {
      clauses.add(this.compileJoinConstraint(nestedClause));
    }
    clauses[0] = this.removeLeadingBoolean(clauses[0]);
    final clausesStr = Utils.implode(' ', clauses);
    return "${clause['boolean']} ($clausesStr)";
  }

  ///
  ///  Compile the "where" portions of the query.
  ///
  ///  @param  \Illuminate\Database\Query\Builder  $query
  ///  @return String
  ///
  String compileWheres(QueryBuilder query) {
    //print('QueryGrammar@compileWheres');
    var sql = <String>[];

    if (Utils.array_is_empty(query.wheresProp)) {
      return '';
    }

    // Each type of where clauses has its own compiler function which is responsible
    // for actually creating the where clauses SQL. This helps keep the code nice
    // and maintainable since each clause has a very small method that it uses.
    for (var where in query.wheresProp) {
      final methodName = "where${where['type']}";
      //print('QueryGrammar@compileWheres methodName: $methodName');
      //call whereBasic
      //sql.add(where['boolean'] +  ' ' +  Utils.call_method(this, methodName, [query, where]));

      sql.add(where['boolean'] + ' ' + callMethod(methodName, [query, where]));
    }

    // If we actually have some where clauses, we will strip off the first boolean
    // operator, which is added by the query builders for convenience so we can
    // avoid checking for the first clauses in each of the compilers methods.
    if (Utils.count(sql) > 0) {
      var sqlRe = Utils.implode(' ', sql);

      return 'where ' + removeLeadingBoolean(sqlRe);
    }

    return '';
  }

  ///
  ///  Compile a nested where clause.
  ///
  ///  @param  \Illuminate\Database\Query\Builder  $query
  ///  @param  array  $where
  ///  @return String
  ///
  String whereNested(QueryBuilder query, Map<String, dynamic> where) {
    var nested = where['query'];
    return '(' + Utils.substr(this.compileWheres(nested), 6) + ')';
  }

  ///
  ///  Compile a where condition with a sub-select.
  ///
  ///  @param  \Illuminate\Database\Query\Builder $query
  ///  @param  array   $where
  ///  @return String
  ///
  String whereSub(QueryBuilder query, Map<String, dynamic> where) {
    var select = this.compileSelect(where['query']);
    return this.wrap(where['column']) + ' ' + where['operator'] + " ($select)";
  }

  ///
  ///  Compile a basic where clause.
  ///
  ///  @param  \Illuminate\Database\Query\Builder  $query
  ///  @param  array  $where
  ///  @return String
  ///
  String whereBasic(QueryBuilder query, Map<String, dynamic> where) {
    var value = this.parameter(where['value']);
    return this.wrap(where['column']) + ' ' + where['operator'] + ' ' + value;
  }

  ///
  ///  Compile a "between" where clause.
  ///
  ///  @param  \Illuminate\Database\Query\Builder  $query
  ///  @param  array  $where
  ///  @return String
  ///
  String whereBetween(QueryBuilder query, Map<String, dynamic> where) {
    var between = where['not'] ? 'not between' : 'between';
    return this.wrap(where['column']) + ' ' + between + ' ? and ?';
  }

  ///
  ///  Compile a where exists clause.
  ///
  ///  @param  \Illuminate\Database\Query\Builder  $query
  ///  @param  array  $where
  ///  @return String
  ///
  String whereExists(QueryBuilder query, Map<String, dynamic> where) {
    return 'exists (' + compileSelect(where['query']) + ')';
  }

  ///
  ///  Compile a where exists clause.
  ///
  ///  @param  \Illuminate\Database\Query\Builder  $query
  ///  @param  array  $where
  ///  @return String
  ///
  String whereNotExists(QueryBuilder query, Map<String, dynamic> where) {
    return 'not exists (' + compileSelect(where['query']) + ')';
  }

  ///
  ///  Compile a "where in" clause.
  ///
  ///  @param  \Illuminate\Database\Query\Builder  $query
  ///  @param  array  $where
  ///  @return String
  ///
  String whereIn(QueryBuilder query, Map<String, dynamic> where) {
    //TODO checar isso  if (empty($where['values'])) {
    if (Utils.empty(where['values'])) {
      return '0 = 1';
    }
    //print('whereIn ${where['values'].runtimeType}' );
    List<dynamic> values = where['values'];

    var valuesString = this.parameterize(values);

    return this.wrap(where['column']) + ' in (' + valuesString + ')';
  }

  ///
  ///  Compile a "where not in" clause.
  ///
  ///  @param  \Illuminate\Database\Query\Builder  $query
  ///  @param  array  $where
  ///  @return String
  ///
  String whereNotIn(QueryBuilder query, Map<String, dynamic> where) {
    if (Utils.empty(where['values'])) {
      return '1 = 1';
    }

    var values = this.parameterize(where['values']);

    return this.wrap(where['column']) + ' not in (' + values + ')';
  }

  ///
  ///  Compile a where in sub-select clause.
  ///
  ///  @param  \Illuminate\Database\Query\Builder  $query
  ///  @param  array  $where
  ///  @return String
  ///
  String whereInSub(QueryBuilder query, Map<String, dynamic> where) {
    var select = this.compileSelect(where['query']);

    return this.wrap(where['column']) + ' in (' + select + ')';
  }

  ///
  ///  Compile a where not in sub-select clause.
  ///
  ///  @param  \Illuminate\Database\Query\Builder  $query
  ///  @param  array  $where
  ///  @return String
  ///
  String whereNotInSub(QueryBuilder query, Map<String, dynamic> where) {
    var select = this.compileSelect(where['query']);

    return this.wrap(where['column']) + ' not in (' + select + ')';
  }

  ///
  ///  Compile a "where null" clause.
  ///
  ///  @param  \Illuminate\Database\Query\Builder  $query
  ///  @param  array  $where
  ///  @return String
  ///
  String whereNull(QueryBuilder query, Map<String, dynamic> where) {
    return this.wrap(where['column']) + ' is null';
  }

  ///
  ///  Compile a "where not null" clause.
  ///
  ///  @param  \Illuminate\Database\Query\Builder  $query
  ///  @param  array  $where
  ///  @return String
  ///
  String whereNotNull(QueryBuilder query, Map<String, dynamic> where) {
    return this.wrap(where['column']) + ' is not null';
  }

  ///
  ///  Compile a "where date" clause.
  ///
  ///  @param  \Illuminate\Database\Query\Builder  $query
  ///  @param  array  $where
  ///  @return String
  ///
  String whereDate(QueryBuilder query, dynamic where) {
    return this.dateBasedWhere('date', query, where);
  }

  ///
  ///  Compile a "where day" clause.
  ///
  ///  @param  \Illuminate\Database\Query\Builder  $query
  ///  @param  array  $where
  ///  @return String
  ///
  String whereDay(QueryBuilder query, where) {
    return this.dateBasedWhere('day', query, where);
  }

  ///
  ///  Compile a "where month" clause.
  ///
  ///  @param  \Illuminate\Database\Query\Builder  $query
  ///  @param  array  $where
  ///  @return String
  ///
  String whereMonth(QueryBuilder query, where) {
    return this.dateBasedWhere('month', query, where);
  }

  ///
  ///  Compile a "where year" clause.
  ///
  ///  @param  \Illuminate\Database\Query\Builder  $query
  ///  @param  array  $where
  ///  @return String
  ///
  String whereYear(QueryBuilder query, where) {
    return this.dateBasedWhere('year', query, where);
  }

  ///
  ///  Compile a date based where clause.
  ///
  ///  @param  String  $type
  ///  @param  \Illuminate\Database\Query\Builder  $query
  ///  @param  array  $where
  ///  @return String
  ///
  String dateBasedWhere(String type, QueryBuilder query, where) {
    var value = this.parameter(where['value']);

    return type +
        '(' +
        this.wrap(where['column']) +
        ') ' +
        where['operator'] +
        ' ' +
        value;
  }

  ///
  ///  Compile a raw where clause.
  ///
  ///  @param  \Illuminate\Database\Query\Builder  $query
  ///  @param  array  $where
  ///  @return String
  ///
  String whereRaw(QueryBuilder query, where) {
    return where['sql'];
  }

  ///
  ///  Compile the "group by" portions of the query.
  ///
  ///  @param  \Illuminate\Database\Query\Builder  $query
  ///  @param  array  $groups
  ///  @return String
  ///
  String compileGroups(QueryBuilder query, groups) {
    return 'group by ' + this.columnize(groups);
  }

  ///
  ///  Compile the "having" portions of the query.
  ///
  ///  @param  \Illuminate\Database\Query\Builder  $query
  ///  @param  array  $havings
  ///  @return String
  ///
  String compileHavings(
      QueryBuilder query, List<Map<String, dynamic>> havings) {
    //TODO implementar havings
    // var sql = implode(' ', array_map([$this, 'compileHaving'], $havings));
    // return 'having '+this.removeLeadingBoolean(sql);
    throw UnimplementedError();
  }

  ///
  ///  Compile a single having clause.
  ///
  ///  @param  array   $having
  ///  @return String
  ///
  String compileHaving(Map<String, dynamic> having) {
    // If the having clause is "raw", we can just return the clause straight away
    // without doing any more processing on it. Otherwise, we will compile the
    // clause into SQL based on the components that make it up from builder.
    if (having['type'] == 'raw') {
      return having['boolean'] + ' ' + having['sql'];
    }
    return this.compileBasicHaving(having);
  }

  ///
  ///  Compile a basic having clause.
  ///
  ///  @param  array   $having
  ///  @return String
  ///
  String compileBasicHaving(Map<String, dynamic> having) {
    var column = this.wrap(having['column']);

    var parameter = this.parameter(having['value']);

    return having['boolean'] +
        ' ' +
        column +
        ' ' +
        having['operator'] +
        ' ' +
        parameter;
  }

  ///
  ///  Compile the "order by" portions of the query.
  ///
  ///  @param  \Illuminate\Database\Query\Builder  $query
  ///  @param  array  $orders
  ///  @return String
  ///
  String compileOrders(QueryBuilder query, List<Map<String, dynamic>> orders) {
    return 'order by ' +
        Utils.implode(
            ', ',
            orders.map((order) {
              if (order['sql'] != null) {
                return order['sql'];
              }
              return this.wrap(order['column']) + ' ' + order['direction'];
            }).toList());
  }

  ///
  ///  Compile the "limit" portions of the query.
  ///
  ///  @param  \Illuminate\Database\Query\Builder  $query
  ///  @param  int  $limit
  ///  @return String
  ///
  String compileLimit(QueryBuilder query, int limit) {
    return 'limit $limit';
  }

  ///
  ///  Compile the "offset" portions of the query.
  ///
  ///  @param  \Illuminate\Database\Query\Builder  $query
  ///  @param  int  $offset
  ///  @return String
  ///
  String compileOffset(QueryBuilder query, int offset) {
    return 'offset $offset';
  }

  ///
  ///  Compile the "union" queries attached to the main query.
  ///
  ///  @param  \Illuminate\Database\Query\Builder  $query
  ///  @return String
  ///
  String compileUnions(QueryBuilder query) {
    // var sql = '';

    // for(var union in query.unionsProp ) {
    //     sql += compileUnion(union);
    // }

    // if (isset($query->unionOrders)) {
    //     $sql .= ' '.this.compileOrders($query, $query->unionOrders);
    // }

    // if (isset($query->unionLimit)) {
    //     $sql .= ' '.this.compileLimit($query, $query->unionLimit);
    // }

    // if (isset($query->unionOffset)) {
    //     $sql .= ' '.this.compileOffset($query, $query->unionOffset);
    // }

    // return ltrim($sql);

    throw UnimplementedError();
  }

  ///
  ///  Compile a single union statement.
  ///
  ///  @param  array  $union
  ///  @return String
  ///
  String compileUnion(Map<String, dynamic> union) {
    var joiner = union['all'] ? ' union all ' : ' union ';

    return joiner + union['query'].toSql();
  }

  ///
  ///  Compile an exists statement into SQL.
  ///
  ///  @param \Illuminate\Database\Query\Builder $query
  ///  @return String
  ///
  String compileExists(QueryBuilder query) {
    var select = compileSelect(query);

    return "select exists($select) as {this.wrap('exists')}";
  }

  ///
  ///  Compile an insert statement into SQL.
  ///
  ///  [query]  QueryBuilder
  ///  [values] Map<String,dynamic>
  ///  `Return` String
  ///
  String compileInsert(QueryBuilder query, Map<String, dynamic> values) {
    // Essentially we will force every insert to be treated as a batch insert which
    // simply makes creating the SQL easier for us since we can utilize the same
    // basic routine regardless of an amount of records given to us to insert.
    var table = this.wrapTable(query.fromProp);

    // if (!Utils.is_array(values)) {
    //   values = [values];
    // }
    var columns = this.columnize(values.keys.toList());
    // We need to build a list of parameter place-holders of values that are bound
    // to the query. Each insert should have the exact same amount of parameter
    // bindings so we will loop through the record and parameterize them all.
    var parameters = this.parameterize(values.values.toList());
    return "insert into $table ($columns) values ($parameters)";
  }

  ///
  ///  Compile an insert and get ID statement into SQL.
  ///
  ///  @param  \Illuminate\Database\Query\Builder  $query
  ///  @param  array   $values
  ///  @param  String  $sequence
  ///  @return String
  ///
  String compileInsertGetId(
      QueryBuilder query, Map<String, dynamic> values, String? sequence) {
    return this.compileInsert(query, values);
  }

  ///
  ///  Compile an update statement into SQL.
  ///
  ///  @param  \Illuminate\Database\Query\Builder  $query
  ///  @param  array  $values
  ///  @return String
  ///
  String compileUpdate(QueryBuilder query, Map<String, dynamic> values) {
    var table = this.wrapTable(query.fromProp);

    // Each one of the columns in the update statements needs to be wrapped in the
    // keyword identifiers, also a place-holder needs to be created for each of
    // the values in the list of bindings so we can make the sets statements.
    dynamic columns = [];
    for (var entry in values.entries) {
      columns.add(this.wrap(entry.key) + ' = ' + this.parameter(entry.value));
    }
    columns = Utils.implode(', ', columns);
    // // If the query has any "join" clauses, we will setup the joins on the builder
    // // and compile them so we can attach them to this update, as update queries
    // // can get join statements to attach to other tables when they're needed.
    var joins = '';
    if (query.joinsProp.isNotEmpty) {
      joins = ' ' + this.compileJoins(query, query.joinsProp);
    }

    // // Of course, update queries may also be constrained by where clauses so we'll
    // // need to compile the where clauses and attach it to the query so only the
    // // intended records are updated by the SQL statements we generate to run.
    var where = this.compileWheres(query);
    return Utils.trim("update $table$joins set $columns $where");
  }

  ///
  /// Prepare the bindings for an update statement.
  ///
  /// @param  array  $bindings
  /// @param  array  $values
  /// @return array
  ///
  prepareBindingsForUpdate( $bindings,  $values) {
    return $bindings;
  }

  ///
  ///  Compile a delete statement into SQL.
  ///
  ///  @param  \Illuminate\Database\Query\Builder  $query
  ///  @return String
  ///
  String compileDelete(QueryBuilder query) {
    var table = this.wrapTable(query.fromProp);
    var where =
        Utils.is_array(query.wheresProp) ? this.compileWheres(query) : '';
    return Utils.trim("delete from $table " + where);
  }

  ///
  ///  Compile a truncate table statement into SQL.
  ///
  ///  @param  \Illuminate\Database\Query\Builder  $query
  ///  @return array
  ///
  Map<String, dynamic> compileTruncate(QueryBuilder query) {
    return {'truncate ' + this.wrapTable(query.from): []};
  }

  ///
  ///  Compile the lock into SQL.
  ///
  ///  @param  \Illuminate\Database\Query\Builder  $query
  ///  @param  bool|string  $value
  ///  @return String
  ///
  String compileLock(QueryBuilder query, dynamic value) {
    return Utils.is_string(value) ? value : '';
  }

  ///
  ///  Determine if the grammar supports savepoints.
  ///
  ///  @return bool
  ///
  bool supportsSavepoints() {
    return true;
  }

  ///
  ///  Compile the SQL statement to define a savepoint.
  ///
  ///  @param  String  $name
  ///  @return String
  ///
  String compileSavepoint(String name) {
    return 'SAVEPOINT ' + name;
  }

  ///
  ///  Compile the SQL statement to execute a savepoint rollback.
  ///
  ///  @param  String  $name
  ///  @return String
  ///
  String compileSavepointRollBack(String name) {
    return 'ROLLBACK TO SAVEPOINT ' + name;
  }

  ///
  ///  Concatenate an array of segments, removing empties and nulls
  ///
  ///  @param  array   $segments
  ///  @return String
  ///
  String concatenate(Map<String, dynamic> segments) {
    // return Utils.implode(' ', Utils.array_filter(segments,  (value) {
    //     return value != '';
    // }));

    return segments.values
        .where((value) => value != '' && value != null)
        .join(' ');
  }

  ///
  ///  Remove the leading boolean from a statement.
  ///
  ///  @param  String  $value
  ///  @return String
  ///
  String removeLeadingBoolean(String value) {
    //return preg_replace('/and |or /i', '', $value, 1);
    return value.replaceFirst(RegExp(r"and |or ", caseSensitive: true), '');
  }
}

// File: C:\MyDartProjects\eloquent\lib\src\query\grammars\query_mysql_grammar.dart
import 'package:eloquent/eloquent.dart';

import '../json_expression.dart';

class QueryMySqlGrammar extends QueryGrammar {
  //List<String> operators = ['sounds like'];

  List<String> selectComponents = [
    'aggregate',
    'columns',
    'from',
    'joins',
    'wheres',
    'groups',
    'havings',
    'orders',
    'limit',
    'offset',
    'lock',
  ];

  ///
  /// Compile a select query into SQL.
  ///
  /// @param  QueryBuilder  query
  /// @return string
  ///
  String compileSelect(QueryBuilder query) {
    var sql = super.compileSelect(query);
    if (query.unionsProp.isNotEmpty) {
      sql = '(' + sql + ') ' + this.compileUnions(query);
    }
    return sql;
  }

  ///
  /// Compile a "JSON contains" statement into SQL.
  ///
  /// @param  string  $column
  /// @param  string  $value
  /// @return string
  ///
  String compileJsonContains(column, value) {
    return 'json_contains(' + this.wrap(column) + ', ' + value + ')';
  }

  ///
  /// Compile a single union statement.
  ///
  /// @param  array  $union
  /// @return string
  ///
  String compileUnion(Map union) {
    var conjunction = union['all'] ? ' union all ' : ' union ';
    return conjunction + '(' + union['query'].toSql() + ')';
  }

  ///
  /// Compile the random statement into SQL.
  ///
  /// @param  string  $seed
  /// @return string
  ///
  String compileRandom(seed) {
    return 'RAND(' + seed + ')';
  }

  ///
  /// Compile the lock into SQL.
  ///
  /// @param QueryBuilder  $query
  /// @param  bool|string  $value
  /// @return string
  ///
  String compileLock(QueryBuilder query, value) {
    if (value is! String) {
      return value ? 'for update' : 'lock in share mode';
    }
    return value;
  }

  ///
  /// Compile an insert and get ID statement into SQL.
  ///
  ///  [query]  QueryBuilder
  ///  [values] Map<String,dynamic>
  /// @param  String  $sequence
  ///  `Return` String
  ///
  @override
  String compileInsertGetId(
      QueryBuilder query, Map<String, dynamic> values, String? sequence) {
    if (sequence == null) {
      sequence = 'id';
    }

    // return this.compileInsert(query, values) +
    //     ' returning ' +
    //     this.wrap(sequence);

    return this.compileInsert(query, values);
  }

  ///
  /// Compile an update statement into SQL.
  ///
  /// @param  QueryBuilder  $query
  /// @param  array  $values
  /// @return string
  ///
  String compileUpdate(QueryBuilder query, Map<String, dynamic> values) {
    final table = this.wrapTable(query.fromProp);

    final columns = <String>[];

    // Each one of the columns in the update statements needs to be wrapped in the
    // keyword identifiers, also a place-holder needs to be created for each of
    // the values in the list of bindings so we can make the sets statements.
    for (var entry in values.entries) {
      var key = entry.key;
      var value = entry.value;

      if (this.isJsonSelector(key)) {
        columns.add(this.compileJsonUpdateColumn(key, JsonExpression(value)));
      } else {
        columns.add(this.wrap(key) + ' = ' + this.parameter(value));
      }
    }

    final columnsStr = columns.join(', ');

    // If the query has any "join" clauses, we will setup the joins on the builder
    // and compile them so we can attach them to this update, as update queries
    // can get join statements to attach to other tables when they're needed.
    var joins = '';
    if (query.joinsProp.isNotEmpty) {
      joins = ' ' + this.compileJoins(query, query.joinsProp);
    }

    // Of course, update queries may also be constrained by where clauses so we'll
    // need to compile the where clauses and attach it to the query so only the
    // intended records are updated by the SQL statements we generate to run.
    final where = this.compileWheres(query);

    var sql = ("update $table$joins set $columnsStr $where").trimRight();

    if (query.ordersProp.isNotEmpty) {
      sql += ' ' + this.compileOrders(query, query.ordersProp);
    }

    if (query.limitProp != null) {
      sql += ' ' + this.compileLimit(query, query.limitProp!);
    }

    return (sql).trimRight();
  }

  ///
  /// Prepares a JSON column being updated using the JSON_SET function.
  ///
  /// @param  string  $key
  /// @param  \Illuminate\Database\JsonExpression  $value
  /// @return string
  ///
  String compileJsonUpdateColumn(key, JsonExpression value) {
    //var path = explode('->', key);
    List<String> path = key.split('->');

    //var field = this.wrapValue(array_shift(path));
    var field = this.wrapValue(path.removeAt(0));

    var accessor = '"\$.' + path.join('.') + '"';

    //return "{$field} = json_set({$field}, {$accessor}, {$value->getValue()})";
    return '$field = json_set($field, $accessor, ${value.getValue()})';
  }

  ///
  /// Prepare the bindings for an update statement.
  ///
  /// @param  array  $bindings
  /// @param  array  $values
  /// @return array
  ///
  prepareBindingsForUpdate($bindings, $values) {
    throw UnimplementedError();
    // var index = 0;

    // for ($values as $column => $value) {
    //     if ($this->isJsonSelector($column) && is_bool($value)) {
    //         unset($bindings[$index]);
    //     }

    //     $index++;
    // }

    // return $bindings;
  }

  ///
  /// Compile a delete statement into SQL.
  ///
  /// @param  QueryBuilder $query
  /// @return string
  ///
  String compileDelete(QueryBuilder query) {
    final table = this.wrapTable(query.fromProp);

    final where = query.wheresProp.isNotEmpty ? this.compileWheres(query) : '';

    if (query.joinsProp.isNotEmpty) {
      final joins = ' ' + this.compileJoins(query, query.joinsProp);
      return "delete $table from $table$joins $where".trim();
    } else {
      var sql = "delete from $table $where".trim();

      if (query.ordersProp.isNotEmpty) {
        sql += ' ' + this.compileOrders(query, query.ordersProp);
      }

      if (query.limitProp != null) {
        sql += ' ' + this.compileLimit(query, query.limitProp!);
      }
      return sql;
    }
  }

  ///
  /// Wrap a single string in keyword identifiers.
  ///
  /// @param  string  $value
  /// @return string
  ///
  String wrapValue(value) {
    if (value == '*') {
      return value;
    }

    if (this.isJsonSelector(value)) {
      return this.wrapJsonSelector(value);
    }

    // return '`'.str_replace('`', '``', $value).'`';
    return '`' + value.replaceAll('`', '``') + '`';
  }

  ///
  /// Wrap the given JSON selector.
  ///
  /// @param  string  $value
  /// @return string
  ///
  String wrapJsonSelector(String value) {
    final path = value.split('->');
    final field = this.wrapValue(path.removeAt(0));
    return field + '->' + '"\$.' + path.join('.') + '"';
  }

  ///
  /// Determine if the given string is a JSON selector.
  ///
  /// @param  string  $value
  /// @return bool
  ///
  bool isJsonSelector(String value) {
    return value.contains('->');
    //Str::contains($value, '->');
  }
}

// File: C:\MyDartProjects\eloquent\lib\src\query\grammars\query_postgres_grammar.dart
import 'package:eloquent/eloquent.dart';

class QueryPostgresGrammar extends QueryGrammar {
  ///
  ///All of the available clause operators.
  ///
  ///protected @var array
  ///
  List<String> operators = [
    '=',
    '<',
    '>',
    '<=',
    '>=',
    '<>',
    '!=',
    'like',
    'not like',
    'between',
    'ilike',
    'not ilike',
    '~',
    '&',
    '|',
    '#',
    '<<',
    '>>',
    '<<=',
    '>>=',
    '&&',
    '@>',
    '<@',
    '?',
    '?|',
    '?&',
    '||',
    '-',
    '-',
    '#-',
    'is distinct from',
    'is not distinct from',
  ];

  ///
  /// Compile a "where date" clause.
  ///
  /// [query] QueryBuilder
  /// [where] dynamic/map/array
  /// @return string
  ///
  String whereDate(QueryBuilder query, dynamic where) {
    var value = this.parameter(where['value']);
    return this.wrap(where['column']) +
        '::date ' +
        where['operator'] +
        ' ' +
        value;
  }

  ///
  /// Compile a "where time" clause.
  ///
  /// [query] QueryBuilder
  /// [where] dynamic/map/array
  /// @return string
  ///
  String whereTime(QueryBuilder query, dynamic where) {
    var value = this.parameter(where['value']);

    return this.wrap(where['column']) +
        '::time ' +
        where['operator'] +
        ' ' +
        value;
  }

  ///
  /// Compile a date based where clause.
  ///
  /// @param  string  $type
  /// @param  \Illuminate\Database\Query\Builder  $query
  /// @param  array  $where
  /// @return string
  ///
  String dateBasedWhere(type, QueryBuilder query, dynamic where) {
    var value = this.parameter(where['value']);
    return 'extract(' +
        type +
        ' from ' +
        this.wrap(where['column']) +
        ') ' +
        where['operator'] +
        ' ' +
        value;
  }

  ///
  /// Compile a "JSON contains" statement into SQL.
  ///
  /// @param  string  $column
  /// @param  string  $value
  /// @return string
  ///
  String compileJsonContains(dynamic column, dynamic value) {
    //column = str_replace('->>', '->', this.wrap(column));
    final newCol = this.wrap(column).replaceAll('->>', '->');
    return '(' + newCol + ')::jsonb @> ' + value;
  }

  ///
  /// Compile the lock into SQL.
  ///
  /// [query] QueryBuilder
  /// [value]  bool|String
  /// @return String
  ///
  String compileLock(QueryBuilder query, dynamic value) {
    if (value is! String) {
      return value ? 'for update' : 'for share';
    }
    return value;
  }

  ///
  ///  Compile an insert statement into SQL.
  ///
  ///  [query]  QueryBuilder
  ///  [values] Map<String,dynamic>
  ///  `Return` String
  ///
  String compileInsert(QueryBuilder query, Map<String, dynamic> values) {
    final table = this.wrapTable(query.fromProp);
    return values.isEmpty
        ? "insert into $table} DEFAULT VALUES"
        : super.compileInsert(query, values);
  }

  ///
  /// Compile an insert and get ID statement into SQL.
  ///
  ///  [query]  QueryBuilder
  ///  [values] Map<String,dynamic>
  /// @param  String  $sequence
  ///  `Return` String
  ///
  @override
  String compileInsertGetId(
      QueryBuilder query, Map<String, dynamic> values, String? sequence) {
    if (sequence == null) {
      sequence = 'id';
    }

    return this.compileInsert(query, values) +
        ' returning ' +
        this.wrap(sequence);
  }

  ///
  ///Compile an update statement into SQL.
  ///
  ///@param  \Illuminate\Database\Query\Builder  $query
  ///@param  array  $values
  ///@return String
  ///
  String compileUpdate(QueryBuilder query, dynamic values) {
    var table = this.wrapTable(query.fromProp);

    // Each one of the columns in the update statements needs to be wrapped in the
    // keyword identifiers, also a place-holder needs to be created for each of
    // the values in the list of bindings so we can make the sets statements.
    var columns = this.compileUpdateColumns(values);
    var from = this.compileUpdateFrom(query);
    var where = this.compileUpdateWheres(query);
    return 'update $table set $columns$from $where'.trim();
  }

  ///
  /// Compile the columns for the update statement.
  ///
  /// @param  array   $values
  /// @return String
  ///
  String compileUpdateColumns(Map<String, dynamic> values) {
    final columns = <String>[];

    // When gathering the columns for an update statement, we'll wrap each of the
    // columns and convert it to a parameter value. Then we will concatenate a
    // list of the columns that can be added into this update query clauses.
    for (var items in values.entries) {
      final key = items.key;
      final value = items.value;
      columns.add(this.wrap(key) + ' = ' + this.parameter(value));
    }
    return columns.join(', ');
  }

  ///
  ///Compile the "from" clause for an update with a join.
  ///
  ///@param  \Illuminate\Database\Query\Builder  $query
  ///@return String|null
  ///
  String? compileUpdateFrom(QueryBuilder query) {
    if (!Utils.isset(query.joinsProp)) {
      return '';
    }

    var froms = <String>[];

    // When using Postgres, updates with joins list the joined tables in the from
    // clause, which is different than other systems like MySQL. Here, we will
    // compile out the tables that are joined and add them to a from clause.
    for (var join in query.joinsProp) {
      froms.add(wrapTable(join.table));
    }

    if (froms.length > 0) {
      return ' from ' + froms.join(', ');
    }

    return null;
  }

  ///
  ///Compile the additional where clauses for updates with joins.
  ///
  ///@param  QueryBuilder  $query
  ///@return String
  ///
  String compileUpdateWheres(QueryBuilder query) {
    var baseWhere = this.compileWheres(query);

    if (!Utils.isset(query.joinsProp)) {
      return baseWhere;
    }

    // Once we compile the join constraints, we will either use them as the where
    // clause or append them to the existing base where clauses. If we need to
    // strip the leading boolean we will do so when using as the only where.
    var joinWhere = this.compileUpdateJoinWheres(query);

    if (Utils.trim(baseWhere) == '') {
      return 'where ' + this.removeLeadingBoolean(joinWhere);
    }

    return baseWhere + ' ' + joinWhere;
  }

  ///
  ///Compile the "join" clauses for an update.
  ///
  ///@param  QueryBuilder  $query
  ///@return String
  ///
  String compileUpdateJoinWheres(QueryBuilder query) {
    var joinWheres = <String>[];

    // Here we will just loop through all of the join constraints and compile them
    // all out then implode them. This should give us "where" like syntax after
    // everything has been built and then we will join it to the real wheres.
    for (var join in query.joinsProp) {
      for (var clause in join.clauses) {
        joinWheres.add(this.compileJoinConstraint(clause));
      }
    }

    return Utils.implode(' ', joinWheres);
  }

  ///
  /// Compile a truncate table statement into SQL.
  ///
  /// @param  \Illuminate\Database\Query\Builder  $query
  /// @return array
  ///
  Map<String, dynamic> compileTruncate(QueryBuilder query) {
    return {
      'truncate ' + this.wrapTable(query.fromProp) + ' restart identity': []
    };
  }
}

// File: C:\MyDartProjects\eloquent\lib\src\query\join_clause.dart
import 'package:eloquent/eloquent.dart';

/// TODO implement extends QueryBuilder
class JoinClause {
  ///
  /// The type of join being performed.
  ///
  /// @var string
  ///
  String type;

  ///
  /// The table the join clause is joining to.
  ///
  /// @var string|QueryExpression
  ///
  dynamic table;

  ///
  /// The "on" clauses for the join.
  ///
  /// @var array
  ///
  List<Map<String, dynamic>> clauses = [];

  ///
  /// The "on" bindings for the join.
  ///
  /// @var array
  ///
  List bindingsLocal = [];

  ///
  /// Create a new join clause instance.
  ///
  /// @param  String  $type
  /// @param  String  $table
  ///
  JoinClause(this.type, this.table, [QueryBuilder? parentQuery]) {
    //: super(parentQuery.getConnection(), parentQuery.getGrammar(),  parentQuery.getProcessor())
    //public function __construct(Builder $parentQuery, $type, $table)
    /// TODO implement extends QueryBuilder
    /// $this->parentQuery = $parentQuery;
    //  super(
    //         $parentQuery->getConnection(), $parentQuery->getGrammar(), $parentQuery->getProcessor()
    //     );
  }

  // /**
  //  * Get a new instance of the join clause builder.
  //  *
  //  * @return \Illuminate\Database\Query\JoinClause
  //  */
  // public function newQuery()
  // {
  //     return new static($this->parentQuery, $this->type, $this->table);
  // }

  // /**
  //  * Create a new query instance for sub-query.
  //  *
  //  * @return \Illuminate\Database\Query\Builder
  //  */
  // protected function forSubQuery()
  // {
  //     return $this->parentQuery->newQuery();
  // }

  ///
  /// Add an "on" clause to the join.
  ///
  /// On clauses can be chained, e.g.
  ///
  ///  $join->on('contacts.user_id', '=', 'users.id')
  ///       ->on('contacts.info_id', '=', 'info.id')
  ///
  /// will produce the following SQL:
  ///
  /// on `contacts`.`user_id` = `users`.`id`  and `contacts`.`info_id` = `info`.`id`
  ///
  /// @param  String|\Closure  $first
  /// @param  String|null  $operator
  /// @param  String|null  $second
  /// @param  String  $boolean
  /// @param  bool  $where
  /// @return $this
  ///
  /// @throws \InvalidArgumentException
  ///
  //  dynamic on(first, [operator , second = null, boolean = 'and'])
  //   {
  //       if (first is Function) {
  //           return this.whereNested(first, boolean);
  //       }

  //       return whereColumn(first, operator, second, boolean);
  //   }
  JoinClause on(dynamic first,
      [String? operator,
      dynamic second,
      String boolean = 'and',
      bool where = false]) {
    if (first is Function) {
      return this.nest(first, boolean);
    }

    if (where) {
      this.bindingsLocal.add(second);
    }

    if (where &&
        (operator == 'in' || operator == 'not in') &&
        Utils.is_array(second)) {
      second = Utils.count(second);
    }

    var nested = false;

    this.clauses.add({
      'first': first,
      'operator': operator,
      'second': second,
      'boolean': boolean,
      'where': where,
      'nested': nested
    });

    return this;
  }

  ///
  /// Add an "or on" clause to the join.
  ///
  /// @param  String|\Closure  $first
  /// @param  String|null  $operator
  /// @param  String|null  $second
  /// @return \Illuminate\Database\Query\JoinClause
  ///
  JoinClause orOn(dynamic first, [String? operator, dynamic second]) {
    return this.on(first, operator, second, 'or');
  }

  ///
  /// Add an "on where" clause to the join.
  ///
  /// @param  String|\Closure  $first
  /// @param  String|null  $operator
  /// @param  String|null  $second
  /// @param  String  $boolean
  /// @return \Illuminate\Database\Query\JoinClause
  ///
  JoinClause where(dynamic first,
      [String? operator, dynamic second, String boolean = 'and']) {
    return this.on(first, operator, second, boolean, true);
  }

  ///
  /// Add an "or on where" clause to the join.
  ///
  /// @param  String|\Closure  $first
  /// @param  String|null  $operator
  /// @param  String|null  $second
  /// @return \Illuminate\Database\Query\JoinClause
  ///
  JoinClause orWhere(dynamic first, [String? operator, dynamic second]) {
    return this.on(first, operator, second, 'or', true);
  }

  ///
  /// Add an "on where is null" clause to the join.
  ///
  /// @param  String  $column
  /// @param  String  $boolean
  /// @return \Illuminate\Database\Query\JoinClause
  ///
  JoinClause whereNull(String column, [String boolean = 'and']) {
    return this.on(column, 'is', QueryExpression('null'), boolean, false);
  }

  ///
  /// Add an "or on where is null" clause to the join.
  ///
  /// @param  String  $column
  /// @return \Illuminate\Database\Query\JoinClause
  ///
  JoinClause orWhereNull(String column) {
    return this.whereNull(column, 'or');
  }

  ///
  /// Add an "on where is not null" clause to the join.
  ///
  /// @param  String  $column
  /// @param  String  $boolean
  /// @return \Illuminate\Database\Query\JoinClause
  ///
  JoinClause whereNotNull(String column, [String boolean = 'and']) {
    return this.on(column, 'is', QueryExpression('not null'), boolean, false);
  }

  ///
  /// Add an "or on where is not null" clause to the join.
  ///
  /// @param  String  $column
  /// @return \Illuminate\Database\Query\JoinClause
  ///
  JoinClause orWhereNotNull(String column) {
    return this.whereNotNull(column, 'or');
  }

  ///
  /// Add an "on where in (...)" clause to the join.
  ///
  /// @param  String  $column
  /// @param  array  $values
  /// @return \Illuminate\Database\Query\JoinClause
  ///
  JoinClause whereIn(String column, List values) {
    return this.on(column, 'in', values, 'and', true);
  }

  ///
  /// Add an "on where not in (...)" clause to the join.
  ///
  /// @param  String  $column
  /// @param  array  $values
  /// @return \Illuminate\Database\Query\JoinClause
  ///
  JoinClause whereNotIn(String column, List values) {
    return this.on(column, 'not in', values, 'and', true);
  }

  ///
  /// Add an "or on where in (...)" clause to the join.
  ///
  /// @param  String  $column
  /// @param  array  $values
  /// @return \Illuminate\Database\Query\JoinClause
  ///
  JoinClause orWhereIn(String column, List values) {
    return this.on(column, 'in', values, 'or', true);
  }

  ///
  /// Add an "or on where not in (...)" clause to the join.
  ///
  /// @param  String  $column
  /// @param  array  $values
  /// @return \Illuminate\Database\Query\JoinClause
  ///
  JoinClause orWhereNotIn(String column, List values) {
    return this.on(column, 'not in', values, 'or', true);
  }

  ///
  /// Add a nested where statement to the query.
  ///
  /// @param  \Closure  $callback
  /// @param  String   $boolean
  /// @return \Illuminate\Database\Query\JoinClause
  ///
  JoinClause nest(Function callback, [String boolean = 'and']) {
    var join = JoinClause(this.type, this.table);

    callback(join);

    if (Utils.count(join.clauses) != 0) {
      var nested = true;

      this.clauses.add({'nested': nested, 'join': join, 'boolean': boolean});
      this.bindingsLocal =
          Utils.array_merge(this.bindingsLocal, join.bindingsLocal);
    }

    return this;
  }
}

// File: C:\MyDartProjects\eloquent\lib\src\query\json_expression.dart
import 'expression.dart';

class JsonExpression extends QueryExpression {
  ///
  /// Create a new raw query expression.
  ///
  /// @param  mixed  $value
  /// @return void
  ///
  JsonExpression(dynamic value) : super(getJsonBindingParameter(value));

  ///
  /// Translate the given value into the appropriate JSON binding parameter.
  ///
  /// @param  mixed  $value
  /// @return string
  ///
  static getJsonBindingParameter(dynamic value) {
    if (value is bool) {
      return value ? 'true' : 'false';
    } else if (value is int) {
      return value;
    } else if (value is double) {
      return value;
    } else if (value is String) {
      return '?';
    } else if (value is Object) {
      return '?';
    } else if (value is List) {
      return '?';
    }

    throw Exception('JSON value is of illegal type: $value');
  }
}

// File: C:\MyDartProjects\eloquent\lib\src\query\processors\mysql_processor.dart
import 'package:eloquent/eloquent.dart';

class MySqlProcessor extends Processor {
  ///
  /// Process the results of a column listing query.
  ///
  /// @param  array  $results
  /// @return array
  ///
  // processColumnListing(results) {
  //   var mapping = ($r) {
  //     return $r.column_name;
  //   };

  //   return array_map(mapping, results);
  // }

  ///
  /// Process an  "insert get ID" query.
  ///
  /// @param  \Illuminate\Database\Query\Builder  $query
  /// @param  string  $sql
  /// @param  array   $values
  /// @param  string  $sequence
  /// @return int
  ///
  Future<dynamic> processInsertGetId(
      QueryBuilder query, String sql, List values,
      [String sequence = 'id']) async {
    await query.getConnection().insert(sql, values);
    final resp =
        await query.getConnection().select('SELECT LAST_INSERT_ID() as id;');
    final id = resp.isNotEmpty ? resp.first['id'] : null;
    return id;
    //var id = query.getConnection().getPdo().lastInsertId(sequence);
    //return is_numeric($id) ? (int) $id : $id;
    //return -1;
  }
}

// File: C:\MyDartProjects\eloquent\lib\src\query\processors\postgres_processor.dart
import 'package:eloquent/eloquent.dart';

class PostgresProcessor extends Processor {
  ///
  /// Process an "insert get ID" query.
  ///
  /// @param  \Illuminate\Database\Query\Builder  $query
  /// @param  string  $sql
  /// @param  array   $values
  /// [sequence] is name of column
  /// @return int
  ///
  Future<dynamic> processInsertGetId(
      QueryBuilder query, String sql, List values,
      [String sequence = 'id']) async {
    //var newSql = '$sql returning "$sequence"';
    final resp = await query.getConnection().insert(sql, values);
    // var results = query.getConnection().selectFromWriteConnection(sql, values);
    final id = resp.isNotEmpty ? resp.first[sequence] : null;
    return id;
  }

  ///
  /// Process the results of a column listing query.
  ///
  /// @param  array  $results
  /// @return array
  ///
  List processColumnListing(List results) {
    var mapping = (item) {
      var r = item;
      return r.column_name;
    };

    return Utils.array_map(mapping, results);
  }
}

// File: C:\MyDartProjects\eloquent\lib\src\query\processors\processor.dart
import 'package:eloquent/eloquent.dart';

class Processor {
  ///
  /// Process the results of a "select" query.
  ///
  /// @param  \Illuminate\Database\Query\Builder  $query
  /// @param  array  $results
  /// @return array
  ///
  List<Map<String, dynamic>> processSelect(
      QueryBuilder query, List<Map<String, dynamic>> results) {
    return results;
  }

  ///
  /// Process an  "insert get ID" query.
  ///
  /// @param  \Illuminate\Database\Query\Builder  $query
  /// @param  string  $sql
  /// @param  array   $values
  /// @param  string  $sequence
  /// @return int
  ///
  Future<dynamic> processInsertGetId(
      QueryBuilder query, String sql, List values,
      [String sequence = 'id']) async {
    final resp = await query.getConnection().insert(sql, values);
    final id = resp.isNotEmpty ? resp.first[sequence] : null;   
    return id;
    //var id = query.getConnection().getPdo().lastInsertId(sequence);
    //return is_numeric($id) ? (int) $id : $id;
    //return -1;
  }

  ///
  /// Process the results of a column listing query.
  ///
  /// @param  array  $results
  /// @return array
  ///
  List processColumnListing(List results) {
    return results;
  }
}

// File: C:\MyDartProjects\eloquent\lib\src\query\query_builder.dart
import 'package:eloquent/src/connection.dart';
import 'package:eloquent/src/connection_interface.dart';
import 'package:eloquent/src/query/expression.dart';
import 'package:eloquent/src/query/grammars/query_grammar.dart';
import 'package:eloquent/src/query/join_clause.dart';
import 'package:eloquent/src/query/processors/processor.dart';
import 'package:eloquent/src/utils/utils.dart';

import '../exceptions/invalid_argument_exception.dart';

class QueryBuilder {
  /// Isaque
  /// Eu adicionei este metodo para mapear uma String para uma propriedade/atributo da Class QueryBuilder
  /// isso permite ler a propriedade/atributo da Class QueryBuilder com base no nome da propriedade
  dynamic getProperty(String propertyName) {
    switch (propertyName) {
      case 'columns':
        return this.columnsProp;
      case 'from':
        return this.fromProp;
      case 'limit':
        return this.limitProp;
      case 'offset':
        return this.offsetProp;
      case 'aggregate':
        return this.aggregateProp;
      case 'distinct':
        return this.distinctProp;
      case 'joins':
        return this.joinsProp;
      case 'wheres':
        return this.wheresProp;
      case 'groups':
        return this.groupsProp;
      case 'havings':
        return this.havingsProp;
      case 'orders':
        return this.ordersProp;
      case 'unions':
        return this.unionsProp;
      case 'bindings':
        return this.bindings;
      case 'unionLimit':
        return this.unionLimit;
      case 'unionOffset':
        return this.unionOffset;
      case 'unionOrders':
        return this.unionOrdersProp;
      case 'lock':
        return this.lockProp;
      case 'backups':
        return this.backups;

      case 'bindingBackups':
        return this.bindingBackups;
      case 'operators':
        return this._operators;
      default:
        print('QueryBuilder@getProperty propertyName');
        return propertyName;
    }
    // return propertyName;
  }

  ///
  /// The database connection instance.
  ///
  /// @var \Illuminate\Database\Connection
  ///
  late ConnectionInterface connection;

  ///
  /// The database query grammar instance.
  ///
  /// @var \Illuminate\Database\Query\Grammars\Grammar
  ///
  late QueryGrammar grammar;

  ///
  /// The database query post processor instance.
  ///
  /// @var \Illuminate\Database\Query\Processors\Processor
  ///
  late Processor processor;

  ///
  /// The current query value bindings.
  ///
  /// @var array
  ///
  Map<String, dynamic> bindings = {
    'select': [],
    'from': [],
    'join': [],
    'where': [],
    'having': [],
    'order': [],
    'union': [],
  };

  ///
  /// An aggregate function and column to be run.
  ///
  /// @var array
  ///
  Map<String, dynamic>? aggregateProp;

  ///
  /// The columns that should be returned.
  /// Propriedade da class QueryBuilder que armazena as colunas da tabela a serem retornadas
  /// @var array
  ///
  List<dynamic>? columnsProp;

  List<dynamic>? getColumns() {
    return columnsProp;
  }

  void setColumns(List<dynamic>? cols) {
    columnsProp = cols;
  }

  ///
  /// Indicates if the query returns distinct results.
  ///
  /// @var bool
  ///
  bool distinctProp = false;

  ///
  /// The table which the query is targeting.
  ///
  /// @var string | QueryExpression
  ///
  late dynamic fromProp;

  ///
  /// The table joins for the query.
  ///
  /// @var array
  ///
  List<JoinClause> joinsProp = [];

  ///
  /// The where constraints for the query.
  ///
  /// @var array
  ///
  List<Map<String, dynamic>> wheresProp = [];

  ///
  /// The groupings for the query.
  ///
  /// @var array
  ///
  List groupsProp = [];

  ///
  /// The having constraints for the query.
  ///
  /// @var array
  ///
  List<Map<String, dynamic>> havingsProp = [];

  ///
  /// The orderings for the query.
  ///
  /// @var array
  ///
  List<Map<String, dynamic>> ordersProp = [];

  ///
  /// The maximum number of records to return.
  ///
  /// @var int
  ///
  int? limitProp;

  ///
  /// The number of records to skip.
  ///
  /// @var int
  ///
  int? offsetProp;

  ///
  /// The query union statements.
  ///
  /// @var array
  ///
  List<Map<String, dynamic>> unionsProp = [];

  ///
  /// The maximum number of union records to return.
  ///
  /// @var int
  ///
  int? unionLimit;

  ///
  /// The number of union records to skip.
  ///
  /// @var int
  ///
  int? unionOffset;

  ///
  /// The orderings for the union query.
  ///
  /// @var array
  ///
  List<Map<String, dynamic>> unionOrdersProp = [];

  ///
  /// Indicates whether row locking is being used.
  ///
  /// @var string|bool
  ///
  dynamic lockProp;

  ///
  /// The field backups currently in use.
  ///
  /// @var array
  ///
  List backups = [];

  ///
  /// The binding backups currently in use.
  ///
  /// @var array
  ///
  List bindingBackups = [];

  ///
  /// All of the available clause operators.
  ///
  /// @var array
  ///
  List _operators = [
    '=',
    '<',
    '>',
    '<=',
    '>=',
    '<>',
    '!=',
    'like',
    'like binary',
    'not like',
    'between',
    'ilike',
    '&',
    '|',
    '^',
    '<<',
    '>>',
    'rlike',
    'regexp',
    'not regexp',
    '~',
    '~///',
    '!~',
    '!~///',
    'similar to',
    'not similar to'
  ];

  ///
  /// Whether use write pdo for select.
  ///
  /// @var bool
  ///
  bool useWritePdoProp = false;

  ///
  /// Create a new query builder instance.
  ///
  /// @param  \Illuminate\Database\ConnectionInterface  $connection
  /// @param  \Illuminate\Database\Query\Grammars\Grammar  $grammar
  /// @param  \Illuminate\Database\Query\Processors\Processor  $processor
  ///
  QueryBuilder(this.connection, this.grammar, this.processor) {
    // this._grammar = grammarP;
    // this._processor = processorP;
    // this._connection = connectionP;
  }

  ///
  /// Set the columns to be selected.
  ///
  /// @param  array|mixed  $columns
  /// @return $this
  ///
  QueryBuilder select([List<String> columnsP = const ['*']]) {
    //this.columns = is_array($columns) ? $columns : func_get_args();
    this.columnsProp = columnsP;
    return this;
  }

  ///
  /// Add a subselect expression to the query.
  ///
  /// @param  Funcion|QueryBuilder|string $query
  /// @param  String  $as
  /// @return QueryBuilder
  ///
  QueryBuilder selectSub(dynamic query, String alias) {
    // var bindings;
    // if (query is Function) {
    //   var callback = query;
    //   callback(query = this.newQuery());
    // }

    // if (query is QueryBuilder) {
    //   bindings = query.getBindings();
    //   query = query.toSql();
    // } else if (Utils.is_string(query)) {
    //   bindings = [];
    // } else {
    //   throw InvalidArgumentException();
    // }

    final res = this.createSub(query);
    final newQuery = res[0];
    final bindings = res[1];

    return this.selectRaw(
        '(' + newQuery + ') as ' + this.grammar.wrap(alias), bindings);
  }

  ///
  /// Add a new "raw" select expression to the query.
  ///
  /// @param  String  $expression
  /// @param  array   $bindings
  /// @return \Illuminate\Database\Query\Builder|static
  ///
  QueryBuilder selectRaw(String expression, [List? bindingsP = const []]) {
    this.addSelect(QueryExpression(expression));

    if (bindingsP != null) {
      this.addBinding(bindingsP, 'select');
    }

    return this;
  }

  ///
  /// Add a raw from clause to the query.
  ///
  /// @param  string  $expression
  /// @param  mixed   $bindings
  /// @return \Illuminate\Database\Query\Builder|static
  ///
  /// Example:
  ///
  ///  var map = await db
  ///     .table('clientes')
  ///     .selectRaw('clientes.*')
  ///     .fromRaw('(SELECT * FROM public.clientes) AS clientes')
  ///     .limit(1)
  ///     .first();
  ///
  ///
  QueryBuilder fromRaw(String expression, [List? $bindings = const []]) {
    this.fromProp = QueryExpression(expression);

    this.addBinding($bindings, 'from');

    return this;
  }

  ///
  /// Creates a subquery and parse it.
  ///
  /// [query]  Function|QueryBuilder|String
  /// `Return` List [String query ,List Bindings]
  ///
  List createSub(dynamic query) {
    // If the given query is a Closure, we will execute it while passing in a new
    // query instance to the Closure. This will give the developer a chance to
    // format and work with the query before we cast it to a raw SQL string.
    if (query is Function) {
      var callback = query;
      callback(query = this.forSubQuery());
    }

    return this.parseSub(query);
  }

  ///
  /// Parse the subquery into SQL and bindings.
  ///
  /// [query] dynamic
  /// `Return` List [String query ,List Bindings]
  ///
  List parseSub(dynamic query) {
    //if (query is self || query is EloquentBuilder) {
    if (query is QueryBuilder) {
      return [query.toSql(), query.getBindings()];
      // return [$query->toSql(), $query->getBindings()];
    } else if (query is String) {
      return [query, []];
    } else {
      throw InvalidArgumentException();
    }
  }

  ///
  /// Add a new select column to the query.
  ///
  /// [columnP]  QueryExpression List | dynamic
  /// @return $this
  ///
  QueryBuilder addSelect(dynamic columnP) {
    //var column = is_array(column) ? column : func_get_args();
    var col = columnP is List ? columnP : [columnP];
    this.columnsProp = Utils.array_merge(columnsProp, col);
    return this;
  }

  ///
  /// Force the query to only return distinct results.
  ///
  /// @return $this
  ///
  QueryBuilder distinct() {
    this.distinctProp = true;

    return this;
  }

  ///
  /// Set the table which the query is targeting.
  ///
  /// @param  String  $table
  /// @return $this
  ///
  QueryBuilder from(String tableP) {
    this.fromProp = tableP;
    return this;
  }

  ///
  /// Add a join clause to the query.
  ///
  /// [table] String|QueryExpression name of table
  /// [one]  String | Function(JoinClause)
  /// [operator] String  Example: '=', 'in', 'not in'
  /// [two]  string|null
  /// [type]  String  Example: 'inner', 'left'
  /// [where]  bool
  /// `Return` this QueryBuilder
  ///
  QueryBuilder join(dynamic table, dynamic one,
      [String? operator,
      dynamic two = null,
      String type = 'inner',
      bool where = false]) {
    // If the first "column" of the join is really a Closure instance the developer
    // is trying to build a join with a complex "on" clause containing more than
    // one condition, so we'll add the join and call a Closure with the query.
    if (one is Function) {
      var join = JoinClause(type, table, this);
      one(join);
      this.joinsProp.add(join);
      this.addBinding(join.bindingsLocal, 'join');
    }
// If the column is simply a string, we can assume the join simply has a basic
// "on" clause with a single condition. So we will just build the join with
// this simple join clauses attached to it. There is not a join callback.
    else {
      var join = new JoinClause(type, table, this);
      this.joinsProp.add(join.on(one, operator, two, 'and', where));
      this.addBinding(join.bindingsLocal, 'join');
    }

    return this;
  }

  ///
  /// Add a "join where" clause to the query.
  ///
  /// @param  String  $table
  /// @param  String  $one
  /// @param  String  $operator
  /// @param  String  $two
  /// @param  String  $type
  /// @return \Illuminate\Database\Query\Builder|static
  ///
  QueryBuilder joinWhere(String table, one, operator, two, [type = 'inner']) {
    return this.join(table, one, operator, two, type, true);
  }

  ///
  /// Add a subquery join clause to the query.
  ///
  /// [query]  QueryBuilder|String
  /// [alias]  string
  /// [first]  string
  /// [operator]  string|null
  /// [second] string|null
  /// [type]  string  inner|left|right|outer
  /// [where]  bool
  /// `Return` QueryBuilder|static
  ///
  /// @throws \InvalidArgumentException
  /// Example:
  /// ```dart
  ///
  /// var subQuery = db.table('public.clientes')
  ///  .selectRaw('clientes_grupos.numero_cliente as numero_cliente, json_agg(row_to_json(grupos.*)) as grupos')
  ///  .join('public.clientes_grupos','clientes_grupos.numero_cliente','=','clientes.numero')
  ///  .join('public.grupos','grupos.numero','=','clientes_grupos.numero_grupo')
  ///  .groupBy('numero_cliente');
  ///
  ///  var map = await db
  ///    .table('clientes')
  ///    .selectRaw('clientes.*')
  ///    .fromRaw('(SELECT * FROM public.clientes) AS clientes')
  ///    .joinSub(subQuery, 'grupos',  (JoinClause join) {
  ///        join.on('grupos.numero_cliente', '=', 'clientes.numero');
  ///    })
  ///    .limit(1)
  ///    .first();
  ///
  /// ```
  ///
  QueryBuilder joinSub(dynamic query, alias, dynamic first,
      [String? operator, dynamic second, type = 'inner', where = false]) {
    final res = this.createSub(query);

    final newQuery = res[0];
    final bindings = res[1];

    final expression = '(' + newQuery + ') as ' + this.grammar.wrap(alias);

    this.addBinding(bindings, 'join');

    return this.join(
        QueryExpression(expression), first, operator, second, type, where);
  }

  ///
  /// Add a left join to the query.
  ///
  /// @param  String  $table
  /// @param  String  $first
  /// @param  String  $operator
  /// @param  String  $second
  /// @return \Illuminate\Database\Query\Builder|static
  ///
  QueryBuilder leftJoin(String table, first,
      [String? operator, dynamic second]) {
    return this.join(table, first, operator, second, 'left');
  }

  ///
  /// Add a "join where" clause to the query.
  ///
  /// @param  String  $table
  /// @param  String  $one
  /// @param  String  $operator
  /// @param  String  $two
  /// @return \Illuminate\Database\Query\Builder|static
  ///
  QueryBuilder leftJoinWhere(
      String table, dynamic one, String operator, dynamic two) {
    return this.joinWhere(table, one, operator, two, 'left');
  }

  ///
  /// Add a right join to the query.
  ///
  /// @param  String  $table
  /// @param  String  $first
  /// @param  String  $operator
  /// @param  String  $second
  /// @return \Illuminate\Database\Query\Builder|static
  ///
  QueryBuilder rightJoin(String table, dynamic first, String operator,
      [dynamic second]) {
    return this.join(table, first, operator, second, 'right');
  }

  ///
  /// Add a "right join where" clause to the query.
  ///
  /// @param  String  $table
  /// @param  String  $one
  /// @param  String  $operator
  /// @param  String  $two
  /// @return \Illuminate\Database\Query\Builder|static
  ///
  QueryBuilder rightJoinWhere(
      String table, dynamic one, String operator, dynamic two) {
    return this.joinWhere(table, one, operator, two, 'right');
  }

  ///
  /// Add a basic where clause to the query.
  ///
  /// [column] String | Map | Function(QueryBuilder)
  /// [operator]  String Examples: '=', '<', '>', '<>'
  /// @param  mixed   $value
  /// @param  String  $boolean
  /// @return $this
  ///
  /// throws \InvalidArgumentException
  ///
  /// Example:
  /// ```dart
  ///  query.where((QueryBuilder qw1) {
  ///         for (var i = 0; i < processos.length; i++) {
  ///           var proc = processos[i];
  ///           if (i == 0) {
  ///             qw1.where((QueryBuilder q) {
  ///               q.where('sw_processo.cod_processo', '=', proc.keys.first);
  ///               q.where('sw_processo.ano_exercicio', '=', proc.values.first);
  ///             });
  ///           } else {
  ///             qw1.orWhere((QueryBuilder q) {
  ///               q.where('sw_processo.cod_processo', '=', proc.keys.first);
  ///               q.where('sw_processo.ano_exercicio', '=', proc.values.first);
  ///             });
  ///           }
  ///         }
  /// ```
  QueryBuilder where(dynamic column,
      [String? operator, dynamic value, String boolean = 'and']) {
    // If the column is an array, we will assume it is an array of key-value pairs
    // and can add them each as a where clause. We will maintain the boolean we
    // received when the method was called and pass it into the nested where.
    if (column is Map) {
      return this.whereNested((query) {
        for (var entry in column.entries) {
          query.where(entry.key, '=', entry.value);
        }
      }, boolean);
    }

    // Here we will make some assumptions about the operator. If only 2 values are
    // passed to the method, we will assume that the operator is an equals sign
    // and keep going. Otherwise, we'll require the operator to be passed in.
    //  if (func_num_args() == 2) {
    //      list($value, $operator) = [$operator, '='];
    //  } else if (this.invalidOperatorAndValue($operator, $value)) {
    //      throw new InvalidArgumentException('Illegal operator and value combination.');
    //  }

    // If the columns is actually a Closure instance, we will assume the developer
    // wants to begin a nested where statement which is wrapped in parenthesis.
    // We'll add that Closure to the query then return back out immediately.
    if (column is Function) {
      return this.whereNested(column, boolean);
    }

    // If the given operator is not found in the list of valid operators we will
    // assume that the developer is just short-cutting the '=' operators and
    // we will set the operators to '=' and set the values appropriately.
    // if (! in_array(strtolower(operator), this._operators, true)) {
    //     list($value, $operator) = [$operator, '='];
    // }

    // If the value is a Closure, it means the developer is performing an entire
    // sub-select within the query and we will need to compile the sub-select
    // within the where clause to get the appropriate query record results.
    if (value is Function) {
      return this.whereSub(column, operator, value, boolean);
    }

    // If the value is "null", we will just assume the developer wants to add a
    // where null clause to the query. So, we will allow a short-cut here to
    // that method for convenience so the developer doesn't have to check.
    if (Utils.is_null(value)) {
      return this.whereNull(column, boolean, operator != '=');
    }

    // Now that we are working with just a simple query we can put the elements
    // in our array and add the query binding to our array of bindings that
    // will be bound to each SQL statements when it is finally executed.
    var type = 'Basic';

    this.wheresProp.add({
      'type': type,
      'column': column,
      'operator': operator,
      'value': value,
      'boolean': boolean
    });

    if (!(value is QueryExpression)) {
      this.addBinding(value, 'where');
    }

    return this;
  }

  ///
  /// Add an "or where" clause to the query.
  /// [column] String|Map|Function
  /// @param  String  $operator
  /// @param  mixed   $value
  /// @return \Illuminate\Database\Query\Builder|static
  ///
  QueryBuilder orWhere(dynamic column, [String? operator, dynamic value]) {
    return this.where(column, operator, value, 'or');
  }

  /**
     * Add a "where" clause comparing two columns to the query.
     *
     * @param  string|array  $first
     * @param  string|null  $operator
     * @param  string|null  $second
     * @param  string|null  $boolean
     * @return \Illuminate\Database\Query\Builder|static
     */
  // TODO implementar isso
  //  whereColumn(first, [operator = null, second = null, boolean = 'and'])
  // {
  //     // If the column is an array, we will assume it is an array of key-value pairs
  //     // and can add them each as a where clause. We will maintain the boolean we
  //     // received when the method was called and pass it into the nested where.
  //     if (first is List) {
  //         return this.addArrayOfWheres($first, $boolean, 'whereColumn');
  //     }

  //     // If the given operator is not found in the list of valid operators we will
  //     // assume that the developer is just short-cutting the '=' operators and
  //     // we will set the operators to '=' and set the values appropriately.
  //     if ($this->invalidOperator($operator)) {
  //         list($second, $operator) = [$operator, '='];
  //     }

  //     // Finally, we will add this where clause into this array of clauses that we
  //     // are building for the query. All of them will be compiled via a grammar
  //     // once the query is about to be executed and run against the database.
  //     $type = 'Column';

  //     $this->wheres[] = compact(
  //         'type', 'first', 'operator', 'second', 'boolean'
  //     );

  //     return $this;
  // }

  ///
  /// Determine if the given operator and value combination is legal.
  ///
  /// @param  String  $operator
  /// @param  mixed  $value
  /// @return bool
  ///
  bool invalidOperatorAndValue(String operator, dynamic value) {
    var isOperator = Utils.in_array(operator, this._operators);

    return isOperator && operator != '=' && Utils.is_null(value);
  }

  ///
  /// Add a raw where clause to the query.
  ///
  /// @param  String  $sql
  /// @param  array   $bindings
  /// @param  String  $boolean
  /// @return $this
  ///
  QueryBuilder whereRaw(String sql,
      [List bindings = const [], boolean = 'and']) {
    var type = 'raw';
    this.wheresProp.add({'type': type, 'sql': sql, 'boolean': boolean});
    this.addBinding(bindings, 'where');
    return this;
  }

  ///
  /// Add a raw or where clause to the query.
  ///
  /// @param  String  $sql
  /// @param  array   $bindings
  /// @return \Illuminate\Database\Query\Builder|static
  ///
  QueryBuilder orWhereRaw(String sql, [List bindings = const []]) {
    return this.whereRaw(sql, bindings, 'or');
  }

  ///
  /// Add a where between statement to the query.
  ///
  /// @param  String  $column
  /// @param  array   $values
  /// @param  String  $boolean
  /// @param  bool  $not
  /// @return $this
  ///
  QueryBuilder whereBetween(String column,
      [List? values, String boolean = 'and', bool not = false]) {
    var type = 'between';

    this
        .wheresProp
        .add({'column': column, 'type': type, 'boolean': boolean, 'not': not});

    this.addBinding(values, 'where');

    return this;
  }

  ///
  /// Add an or where between statement to the query.
  ///
  /// @param  String  $column
  /// @param  array   $values
  /// @return \Illuminate\Database\Query\Builder|static
  ///
  QueryBuilder orWhereBetween(String column, List values) {
    return this.whereBetween(column, values, 'or');
  }

  ///
  /// Add a where not between statement to the query.
  ///
  /// @param  String  $column
  /// @param  array   $values
  /// @param  String  $boolean
  /// @return \Illuminate\Database\Query\Builder|static
  ///
  QueryBuilder whereNotBetween(column, List values, [boolean = 'and']) {
    return this.whereBetween(column, values, boolean, true);
  }

  ///
  /// Add an or where not between statement to the query.
  ///
  /// @param  String  $column
  /// @param  array   $values
  /// @return \Illuminate\Database\Query\Builder|static
  ///
  QueryBuilder orWhereNotBetween(String column, List values) {
    return this.whereNotBetween(column, values, 'or');
  }

  ///
  /// Add a nested where statement to the query.
  ///
  /// @param  \Closure $callback
  /// @param  String   $boolean
  /// @return \Illuminate\Database\Query\Builder|static
  ///
  QueryBuilder whereNested(Function callback, [String boolean = 'and']) {
    var query = this.forNestedWhere();

    callback(query);

    return this.addNestedWhereQuery(query, boolean);
  }

  ///
  /// Create a new query instance for nested where condition.
  ///
  /// @return \Illuminate\Database\Query\Builder
  ///
  QueryBuilder forNestedWhere() {
    var query = this.newQuery();

    return query.from(this.fromProp);
  }

  ///
  /// Add another query builder as a nested where to the query builder.
  ///
  /// @param  \Illuminate\Database\Query\Builder|static $query
  /// @param  String  $boolean
  /// @return $this
  ///
  QueryBuilder addNestedWhereQuery(QueryBuilder query, [boolean = 'and']) {
    if (Utils.count(query.wheresProp) != 0) {
      var type = 'Nested';

      this.wheresProp.add({'type': type, 'query': query, 'boolean': boolean});

      this.addBinding(query.getBindings(), 'where');
    }

    return this;
  }

  ///
  /// Add a full sub-select to the query.
  ///
  /// @param  String   $column
  /// @param  String   $operator
  /// @param  \Closure $callback
  /// @param  String   $boolean
  /// @return $this
  ///
  QueryBuilder whereSub(
      String column, String? operator, Function callback, String boolean) {
    var type = 'Sub';

    var query = this.newQuery();

    // Once we have the query instance we can simply execute it so it can add all
    // of the sub-select's conditions to itself, and then we can cache it off
    // in the array of where clauses for the "main" parent query instance.
    callback(query);

    this.wheresProp.add({
      'type': type,
      'column': column,
      'operator': operator,
      'query': query,
      'boolean': boolean
    });

    this.addBinding(query.getBindings(), 'where');

    return this;
  }

  ///
  /// Add an exists clause to the query.
  ///
  /// @param  \Closure $callback
  /// @param  String   $boolean
  /// @param  bool     $not
  /// @return $this
  ///
  QueryBuilder whereExists(Function callback,
      [String boolean = 'and', not = false]) {
    var type = not ? 'NotExists' : 'Exists';

    var query = this.newQuery();

    // Similar to the sub-select clause, we will create a new query instance so
    // the developer may cleanly specify the entire exists query and we will
    // compile the whole thing in the grammar and insert it into the SQL.
    callback(query);

    this.wheresProp.add(
        {'type': type, 'operator': null, 'query': query, 'boolean': boolean});

    this.addBinding(query.getBindings(), 'where');

    return this;
  }

  ///
  /// Add an or exists clause to the query.
  ///
  /// @param  \Closure $callback
  /// @param  bool     $not
  /// @return \Illuminate\Database\Query\Builder|static
  ///
  QueryBuilder orWhereExists(Function callback, [bool not = false]) {
    return this.whereExists(callback, 'or', not);
  }

  ///
  /// Add a where not exists clause to the query.
  ///
  /// @param  \Closure $callback
  /// @param  String   $boolean
  /// @return \Illuminate\Database\Query\Builder|static
  ///
  QueryBuilder whereNotExists(Function callback, [String boolean = 'and']) {
    return this.whereExists(callback, boolean, true);
  }

  ///
  /// Add a where not exists clause to the query.
  ///
  /// @param  \Closure  $callback
  /// @return \Illuminate\Database\Query\Builder|static
  ///
  QueryBuilder orWhereNotExists(Function callback) {
    return this.orWhereExists(callback, true);
  }

  ///
  /// Add a "where in" clause to the query.
  ///
  /// @param  String  $column
  /// [values] List<dynamic> | QueryBuilder | Function
  /// @param  String  $boolean
  /// @param  bool    $not
  /// @return $this
  ///
  QueryBuilder whereIn(String column, dynamic values,
      [String boolean = 'and', bool not = false]) {
    var type = not ? 'NotIn' : 'In';
    //TODO check isso if (values is static) {
    //static se refere ao instancia da propria class
    if (values is QueryBuilder) {
      return this.whereInExistingQuery(column, values, boolean, not);
    }

    // If the value of the where in clause is actually a Closure, we will assume that
    // the developer is using a full sub-select for this "in" statement, and will
    // execute those Closures, then we can re-construct the entire sub-selects.
    if (values is Function) {
      return this.whereInSub(column, values, boolean, not);
    }

    // if (values is Arrayable) {
    //     $values = $values->toArray();
    // }

    this.wheresProp.add(
        {'type': type, 'column': column, 'values': values, 'boolean': boolean});

    this.addBinding(values, 'where');

    return this;
  }

  ///
  /// Add an "or where in" clause to the query.
  ///
  /// @param  String  $column
  /// @param  mixed   $values
  /// @return \Illuminate\Database\Query\Builder|static
  ///
  QueryBuilder orWhereIn(String column, dynamic values) {
    return this.whereIn(column, values, 'or');
  }

  ///
  /// Add a "where not in" clause to the query.
  ///
  /// @param  String  $column
  /// @param  mixed   $values
  /// @param  String  $boolean
  /// @return \Illuminate\Database\Query\Builder|static
  ///
  QueryBuilder whereNotIn(String column, values, [boolean = 'and']) {
    return this.whereIn(column, values, boolean, true);
  }

  ///
  /// Add an "or where not in" clause to the query.
  ///
  /// @param  String  $column
  /// @param  mixed   $values
  /// @return \Illuminate\Database\Query\Builder|static
  ///
  QueryBuilder orWhereNotIn($column, $values) {
    return this.whereNotIn($column, $values, 'or');
  }

  ///
  /// Add a where in with a sub-select to the query.
  ///
  /// @param  String   $column
  /// @param  \Closure $callback
  /// @param  String   $boolean
  /// @param  bool     $not
  /// @return $this
  ///
  QueryBuilder whereInSub(
      String column, Function callback, String boolean, bool not) {
    var type = not ? 'NotInSub' : 'InSub';

    // To create the exists sub-select, we will actually create a query and call the
    // provided callback with the query so the developer may set any of the query
    // conditions they want for the in clause, then we'll put it in this array.
    var query = this.newQuery();
    callback(query);

    this.wheresProp.add(
        {'type': type, 'column': column, 'query': query, 'boolean': boolean});

    this.addBinding(query.getBindings(), 'where');

    return this;
  }

  ///
  /// Add a external sub-select to the query.
  ///
  /// @param  String   $column
  /// @param  \Illuminate\Database\Query\Builder|static  $query
  /// @param  String   $boolean
  /// @param  bool     $not
  /// @return $this
  ///
  QueryBuilder whereInExistingQuery(
      String column, QueryBuilder query, String boolean, bool not) {
    var type = not ? 'NotInSub' : 'InSub';

    this.wheresProp.add(
        {'type': type, 'column': column, 'query': query, 'boolean': boolean});

    this.addBinding(query.getBindings(), 'where');

    return this;
  }

  ///
  /// Add a "where null" clause to the query.
  ///
  /// @param  String  $column
  /// @param  String  $boolean
  /// @param  bool    $not
  /// @return $this
  ///
  QueryBuilder whereNull(String column,
      [String boolean = 'and', bool not = false]) {
    var type = not ? 'NotNull' : 'Null';

    this.wheresProp.add({'type': type, 'column': column, 'boolean': boolean});

    return this;
  }

  ///
  /// Add an "or where null" clause to the query.
  ///
  /// @param  String  $column
  /// @return \Illuminate\Database\Query\Builder|static
  ///
  QueryBuilder orWhereNull(String column) {
    return this.whereNull(column, 'or');
  }

  ///
  /// Add a "where not null" clause to the query.
  ///
  /// @param  String  $column
  /// @param  String  $boolean
  /// @return \Illuminate\Database\Query\Builder|static
  ///
  QueryBuilder whereNotNull(String column, [String boolean = 'and']) {
    return this.whereNull(column, boolean, true);
  }

  ///
  /// Add an "or where not null" clause to the query.
  ///
  /// @param  String  $column
  /// @return \Illuminate\Database\Query\Builder|static
  ///
  QueryBuilder orWhereNotNull(String column) {
    return this.whereNotNull(column, 'or');
  }

  ///
  /// Add a "where date" statement to the query.
  ///
  /// @param  String  $column
  /// @param  String   $operator
  /// @param  int   $value
  /// @param  String   $boolean
  /// @return \Illuminate\Database\Query\Builder|static
  ///
  QueryBuilder whereDate(String column, String? operator, int value,
      [String boolean = 'and']) {
    return this.addDateBasedWhere('Date', column, operator, value, boolean);
  }

  ///
  /// Add a "where day" statement to the query.
  ///
  /// @param  String  $column
  /// @param  String   $operator
  /// @param  int   $value
  /// @param  String   $boolean
  /// @return \Illuminate\Database\Query\Builder|static
  ///
  QueryBuilder whereDay(String column, String operator, int value,
      [String boolean = 'and']) {
    return this.addDateBasedWhere('Day', column, operator, value, boolean);
  }

  ///
  /// Add a "where month" statement to the query.
  ///
  /// @param  String  $column
  /// @param  String   $operator
  /// @param  int   $value
  /// @param  String   $boolean
  /// @return \Illuminate\Database\Query\Builder|static
  ///
  QueryBuilder whereMonth(String column, String operator, int value,
      [String boolean = 'and']) {
    return this.addDateBasedWhere('Month', column, operator, value, boolean);
  }

  ///
  /// Add a "where year" statement to the query.
  ///
  /// @param  String  $column
  /// @param  String   $operator
  /// @param  int   $value
  /// @param  String   $boolean
  /// @return \Illuminate\Database\Query\Builder|static
  ///
  QueryBuilder whereYear(String column, String operator, int value,
      [String boolean = 'and']) {
    return this.addDateBasedWhere('Year', column, operator, value, boolean);
  }

  ///
  /// Add a date based (year, month, day) statement to the query.
  ///
  /// @param  String  $type
  /// @param  String  $column
  /// @param  String  $operator
  /// @param  int  $value
  /// @param  String  $boolean
  /// @return $this
  ///
  QueryBuilder addDateBasedWhere(
      String type, String column, String? operator, int value,
      [String boolean = 'and']) {
    this.wheresProp.add({
      'column': column,
      'type': type,
      'boolean': boolean,
      'operator': operator,
      'value': value
    });

    this.addBinding(value, 'where');

    return this;
  }

  ///
  /// Handles dynamic "where" clauses to the query.
  ///
  /// @param  String  $method
  /// @param  String  $parameters
  /// @return $this
  ///
  // QueryBuilder dynamicWhere(String method, String parameters)
  // {
  //     var finder = Utils.substr(method, 5);

  //     var segments = preg_split('/(And|Or)(?=[A-Z])/', finder, -1, PREG_SPLIT_DELIM_CAPTURE);

  //     // The connector variable will determine which connector will be used for the
  //     // query condition. We will change it as we come across new boolean values
  //     // in the dynamic method strings, which could contain a number of these.
  //     $connector = 'and';

  //     $index = 0;

  //     foreach ($segments as $segment) {
  //         // If the segment is not a boolean connector, we can assume it is a column's name
  //         // and we will add it to the query as a new constraint as a where clause, then
  //         // we can keep iterating through the dynamic method string's segments again.
  //         if ($segment != 'And' && $segment != 'Or') {
  //             this.addDynamic($segment, $connector, $parameters, $index);

  //             $index++;
  //         }

  //         // Otherwise, we will store the connector so we know how the next where clause we
  //         // find in the query should be connected to the previous ones, meaning we will
  //         // have the proper boolean connector to connect the next where clause found.
  //         else {
  //             $connector = $segment;
  //         }
  //     }

  //     return this;
  // }

  ///
  /// Add a single dynamic where clause statement to the query.
  ///
  /// @param  String  $segment
  /// @param  String  $connector
  /// @param  array   $parameters
  /// @param  int     $index
  /// @return void
  ///
  // QueryBuilder addDynamic(segment, connector, parameters, index)
  // {
  //     // Once we have parsed out the columns and formatted the boolean operators we
  //     // are ready to add it to this query as a where clause just like any other
  //     // clause on the query. Then we'll increment the parameter index values.
  //     var boolean = Utils.strtolower(connector);

  //     this.where(Str::snake($segment), '=', $parameters[$index], $bool);
  // }

  ///
  /// Add a "group by" clause to the query.
  ///
  /// @param  array|string  $column,...
  /// @return $this
  ///
  QueryBuilder groupBy(dynamic column) {
    // for(func_get_args() as $arg) {
    //     this.groupsProp = array_merge((array) this.groupsProp, is_array($arg) ? $arg : [$arg]);
    // }
    if (Utils.is_array(column)) {
      this.groupsProp = Utils.array_merge(this.groupsProp, column);
    } else if (Utils.is_string(column)) {
      this.groupsProp = Utils.array_merge(this.groupsProp, [column]);
    }

    return this;
  }

  ///
  /// Add a "having" clause to the query.
  ///
  /// @param  String  $column
  /// @param  String  $operator
  /// @param  String  $value
  /// @param  String  $boolean
  /// @return $this
  ///
  QueryBuilder having(String column,
      [String? operator, dynamic value, String boolean = 'and']) {
    var type = 'basic';

    this.havingsProp.add({
      'type': type,
      'column': column,
      'operator': operator,
      'value': value,
      'boolean': boolean
    });

    if (!value is QueryExpression) {
      this.addBinding(value, 'having');
    }

    return this;
  }

  ///
  /// Add a "or having" clause to the query.
  ///
  /// @param  String  $column
  /// @param  String  $operator
  /// @param  String  $value
  /// @return \Illuminate\Database\Query\Builder|static
  ///
  QueryBuilder orHaving(String column, [String? operator, dynamic value]) {
    return this.having(column, operator, value, 'or');
  }

  ///
  /// Add a raw having clause to the query.
  ///
  /// @param  String  $sql
  /// @param  array   $bindings
  /// @param  String  $boolean
  /// @return $this
  ///
  // dynamic havingRaw($sql, array $bindings = [], $boolean = 'and')
  // {
  //     $type = 'raw';

  //     this.havings[] = compact('type', 'sql', 'boolean');

  //     this.addBinding($bindings, 'having');

  //     return this;
  // }

  ///
  /// Add a raw or having clause to the query.
  ///
  /// @param  String  $sql
  /// @param  array   $bindings
  /// @return \Illuminate\Database\Query\Builder|static
  ///
  // dynamic orHavingRaw($sql, array $bindings = [])
  // {
  //     return this.havingRaw($sql, $bindings, 'or');
  // }

  ///
  /// Add an "order by" clause to the query.
  ///
  /// @param  String  $column
  /// @param  String  $direction
  /// @return $this
  ///
  QueryBuilder orderBy(String column, [String direction = 'asc']) {
    //var property = this.unions.isNotEmpty ? 'unionOrders' : 'orders';
    var _direction = Utils.strtolower(direction) == 'asc' ? 'asc' : 'desc';

    //this.{$property}[] = compact('column', 'direction');
    var map = {'column': column, 'direction': _direction};
    if (this.unionsProp.isNotEmpty) {
      this.unionOrdersProp.add(map);
    } else {
      this.ordersProp.add(map);
    }

    return this;
  }

  ///
  /// Add an "order by" clause for a timestamp to the query.
  ///
  /// @param  String  $column
  /// @return \Illuminate\Database\Query\Builder|static
  ///
  QueryBuilder latest([String column = 'created_at']) {
    return this.orderBy(column, 'desc');
  }

  ///
  /// Add an "order by" clause for a timestamp to the query.
  ///
  /// @param  String  $column
  /// @return \Illuminate\Database\Query\Builder|static
  ///
  QueryBuilder oldest([String column = 'created_at']) {
    return this.orderBy(column, 'asc');
  }

  ///
  /// Add a raw "order by" clause to the query.
  ///
  /// @param  String  $sql
  /// @param  array  $bindings
  /// @return $this
  ///
  QueryBuilder orderByRaw(String sql, [bindings = const []]) {
    // $property = this.unions ? 'unionOrders' : 'orders';
    var type = 'raw';
    // this.{$property}[] = compact('type', 'sql');
    var map = {'type': type, 'sql': sql};
    if (this.unionsProp.isNotEmpty) {
      this.unionOrdersProp.add(map);
    } else {
      this.ordersProp.add(map);
    }

    this.addBinding(bindings, 'order');

    return this;
  }

  ///
  /// Set the "offset" value of the query.
  ///
  /// @param  int  $value
  /// @return $this
  ///
  QueryBuilder offset(int value) {
    // $property = this.unions ? 'unionOffset' : 'offset';

    //this.$property = max(0, $value);
    var v = Utils.int_max(0, value);
    if (this.unionsProp.isNotEmpty) {
      this.unionOffset = v;
    } else {
      this.offsetProp = v;
    }

    return this;
  }

  ///
  /// Alias to set the "offset" value of the query.
  ///
  /// @param  int  $value
  /// @return \Illuminate\Database\Query\Builder|static
  ///
  QueryBuilder skip(int value) {
    return this.offset(value);
  }

  ///
  /// Set the "limit" value of the query.
  ///
  /// @param  int  $value
  /// @return $this
  ///
  QueryBuilder limit(int value) {
    //$property = this.unions ? 'unionLimit' : 'limit';

    if (value >= 0) {
      //this.$property = $value;

      if (this.unionsProp.isNotEmpty) {
        this.unionLimit = value;
      } else {
        this.limitProp = value;
      }
    }

    return this;
  }

  ///
  /// Alias to set the "limit" value of the query.
  ///
  /// @param  int  $value
  /// @return \Illuminate\Database\Query\Builder|static
  ///
  QueryBuilder take(int value) {
    return this.limit(value);
  }

  ///
  /// Set the limit and offset for a given page.
  ///
  /// @param  int  $page
  /// @param  int  $perPage
  /// @return \Illuminate\Database\Query\Builder|static
  ///
  QueryBuilder forPage(int page, [int perPage = 15]) {
    return this.skip((page - 1));

    /// $perPage)->take($perPage);
  }

  ///
  /// Add a union statement to the query.
  ///
  /// @param  \Illuminate\Database\Query\Builder|\Closure  $query
  /// @param  bool  $all
  /// @return \Illuminate\Database\Query\Builder|static
  ///
  QueryBuilder union(dynamic queryP, [bool all = false]) {
    if (queryP is Function) {
      var query = this.newQuery();
      queryP(query);
    }

    this.unionsProp.add({'query': queryP, 'all': all});

    this.addBinding(queryP.getBindings(), 'union');

    return this;
  }

  ///
  /// Add a union all statement to the query.
  ///
  /// @param  \Illuminate\Database\Query\Builder|\Closure  $query
  /// @return \Illuminate\Database\Query\Builder|static
  ///
  dynamic unionAll($query) {
    return this.union($query, true);
  }

  ///
  /// Lock the selected rows in the table.
  ///
  /// @param  bool  $value
  /// @return $this
  ///
  QueryBuilder lock([value = true]) {
    this.lockProp = value;

    if (this.lockProp) {
      this.useWritePdo();
    }

    return this;
  }

  ///
  /// Lock the selected rows in the table for updating.
  ///
  /// @return \Illuminate\Database\Query\Builder
  ///
  QueryBuilder lockForUpdate() {
    return this.lock(true);
  }

  ///
  /// Share lock the selected rows in the table.
  ///
  /// @return \Illuminate\Database\Query\Builder
  ///
  QueryBuilder sharedLock() {
    return this.lock(false);
  }

  ///
  /// Get the SQL representation of the query.
  ///
  /// @return string
  ///
  String toSql() {
    return this.grammar.compileSelect(this);
  }

  ///
  /// Execute a query for a single record by ID.
  ///
  /// @param  int    $id
  /// @param  array  $columns
  /// @return mixed|static
  ///
  dynamic find(int id, [List<String> columns = const ['*']]) {
    return this.where('id', '=', id).first(columns);
  }

  ///
  /// Get a single column's value from the first result of a query.
  ///
  /// @param  String  $column
  /// @return mixed
  ///
  Future<dynamic> value(String column) async {
    final result = await this.first([column]);
    return result;
  }

  ///
  /// Execute the query and get the first result.
  ///
  /// [columns] columns
  /// `Return` Map<String,dynamic>
  ///
  Future<Map<String, dynamic>?> first(
      [List<String> columns = const ['*'], int? timeoutInSeconds]) async {
    final results = await this.take(1).get(columns, timeoutInSeconds);
    return results.isNotEmpty ? results.first : null;
  }

  ///
  /// Execute the query as a "select" statement.
  ///
  /// @param  array  $columns
  /// @return array|static[]
  ///
  Future<List<Map<String, dynamic>>> get(
      [List<String> columnsP = const ['*'], int? timeoutInSeconds]) async {
    var original = this.columnsProp != null ? [...this.columnsProp!] : null;

    if (Utils.is_null(original)) {
      this.columnsProp = columnsP;
    }

    final resultRunSelect = await this.runSelect(timeoutInSeconds);

    final results = this.processor.processSelect(this, resultRunSelect);
    this.columnsProp = original;
    return results;
  }

  ///
  /// Run the query as a "select" statement against the connection.
  ///
  /// @return array
  ///
  Future<List<Map<String, dynamic>>> runSelect([int? timeoutInSeconds]) async {
    final sqlStr = this.toSql();
    //print('QueryGrammar@runSelect sql: $sqlStr');
    final bid = this.getBindings();
    // print('QueryGrammar@runSelect getBindings: $bid');
    final com = this.connection;

    final results = await com.select(sqlStr, bid, !this.useWritePdoProp);
    // print('QueryGrammar@runSelect results: $results');
    return results;
  }

  ///
  /// Paginate the given query into a simple paginator.
  ///
  /// @param  int  $perPage
  /// @param  array  $columns
  /// @param  String  $pageName
  /// @param  int|null  $page
  /// @return \Illuminate\Contracts\Pagination\LengthAwarePaginator
  ///
  // dynamic paginate([int perPage = 15, columns = const['*'], pageName = 'page', page = null])
  // {
  //     var page = $page ?: Paginator::resolveCurrentPage($pageName);

  //     $total = this.getCountForPagination($columns);

  //     $results = this.forPage($page, $perPage)->get($columns);

  //     return new LengthAwarePaginator($results, $total, $perPage, $page, [
  //         'path' => Paginator::resolveCurrentPath(),
  //         'pageName' => $pageName,
  //     ]);
  // }

  ///
  /// Get a paginator only supporting simple next and previous links.
  ///
  /// This is more efficient on larger data-sets, etc.
  ///
  /// @param  int  $perPage
  /// @param  array  $columns
  /// @param  String  $pageName
  /// @return \Illuminate\Contracts\Pagination\Paginator
  ///
  // dynamic simplePaginate($perPage = 15, $columns = ['///'], $pageName = 'page')
  // {
  //     $page = Paginator::resolveCurrentPage($pageName);

  //     this.skip(($page - 1) /// $perPage)->take($perPage + 1);

  //     return new Paginator(this.get($columns), $perPage, $page, [
  //         'path' => Paginator::resolveCurrentPath(),
  //         'pageName' => $pageName,
  //     ]);
  // }

  ///
  /// Get the count of the total records for the paginator.
  ///
  /// @param  array  $columns
  /// @return int
  ///
  // dynamic getCountForPagination($columns = ['///'])
  // {
  //     this.backupFieldsForCount();

  //     this.aggregate = ['function' => 'count', 'columns' => this.clearSelectAliases($columns)];

  //     $results = this.get();

  //     this.aggregate = null;

  //     this.restoreFieldsForCount();

  //     if (isset(this.groupsProp)) {
  //         return count($results);
  //     }

  //     return isset($results[0]) ? (int) array_change_key_case((array) $results[0])['aggregate'] : 0;
  // }

  ///
  /// Backup some fields for the pagination count.
  ///
  /// @return void
  ///
  // void backupFieldsForCount()
  // {
  //     for (['orders', 'limit', 'offset', 'columns'] as $field) {
  //         this.backups[$field] = this.{$field};

  //         this.{$field} = null;
  //     }

  //     for (['order', 'select'] as $key) {
  //         this.bindingBackups[$key] = this.bindings[$key];

  //         this.bindings[$key] = [];
  //     }
  // }

  ///
  /// Remove the column aliases since they will break count queries.
  ///
  /// @param  array  $columns
  /// @return array
  ///
  // dynamic clearSelectAliases( $columns)
  // {
  //     return array_map(function ($column) {
  //         return is_string($column) && ($aliasPosition = strpos(strtolower($column), ' as ')) != false
  //                 ? substr($column, 0, $aliasPosition) : $column;
  //     }, $columns);
  // }

  ///
  /// Restore some fields after the pagination count.
  ///
  /// @return void
  ///
  // protected function restoreFieldsForCount()
  // {
  //     foreach (['orders', 'limit', 'offset', 'columns'] as $field) {
  //         this.{$field} = this.backups[$field];
  //     }

  //     foreach (['order', 'select'] as $key) {
  //         this.bindings[$key] = this.bindingBackups[$key];
  //     }

  //     this.backups = [];
  //     this.bindingBackups = [];
  // }

  ///
  /// Chunk the results of the query.
  ///
  /// @param  int  $count
  /// @param  callable  $callback
  /// @return bool
  ///
  // dynamic chunk(int count, Function callback)
  // {
  //     $results = this.forPage($page = 1, $count)->get();

  //     while (count($results) > 0) {
  //         // On each chunk result set, we will pass them to the callback and then let the
  //         // developer take care of everything within the callback, which allows us to
  //         // keep the memory low for spinning through large result sets for working.
  //         if (call_user_func($callback, $results) === false) {
  //             return false;
  //         }

  //         $page++;

  //         $results = this.forPage($page, $count)->get();
  //     }

  //     return true;
  // }

  ///
  /// Get an array with the values of a given column.
  ///
  /// @param  String  $column
  /// @param  String|null  $key
  /// @return array
  ///
  dynamic pluck(String column, [String? key]) {
    var results = this.get(Utils.is_null(key) ? [column] : [column, key!]);

    // If the columns are qualified with a table or have an alias, we cannot use
    // those directly in the "pluck" operations since the results from the DB
    // are only keyed by the column itself. We'll strip the table out here.
    return Utils.array_pluck(results, this.stripeTableForPluck(column),
        this.stripeTableForPluck(key));
  }

  ///
  /// Alias for the "pluck" method.
  ///
  /// @param  String  $column
  /// @param  String|null  $key
  /// @return array
  ///
  /// @deprecated since version 5.2. Use the "pluck" method directly.
  ///
  // dynamic lists($column, $key = null)
  // {
  //     return this.pluck($column, $key);
  // }

  ///
  /// Strip off the table name or alias from a column identifier.
  ///
  /// @param  String  $column
  /// @return string|null
  ///
  dynamic stripeTableForPluck(column) {
    return Utils.is_null(column) ? column : column.split(RegExp(r'\.| ')).last;
  }

  ///
  /// Concatenate values of a given column as a string.
  ///
  /// @param  String  $column
  /// @param  String  $glue
  /// @return string
  ///
  // String implode(String column, [String glue = ''])
  // {
  //     return Utils.implode(glue, this.pluck($column));
  // }

  ///
  /// Determine if any rows exist for the current query.
  ///
  /// @return bool
  ///
  dynamic exists() {
    var sql = this.grammar.compileExists(this);

    dynamic results =
        this.connection.select(sql, this.getBindings(), this.useWritePdoProp);

    if (results[0] != null) {
      results = results[0];

      return results['exists'];
    }

    return false;
  }

  ///
  /// Retrieve the "count" result of the query.
  ///
  /// @param  String|List<String>  columns
  /// @return int
  ///
  Future<int> count([dynamic columns = '*']) async {
    if (!Utils.is_array(columns)) {
      columns = <String>[columns];
    }
    //var cols = (columns as List).map((e) => e.toString()).toList();

    //__FUNCTION__	The function name, or {closure} for anonymous functions.
    //a constant __FUNCTION__  retorna o nome da corrent função https://www.php.net/manual/en/language.constants.magic.php
    final result = await this.aggregate('count', columns);
    return result is int ? result : 0;
  }

  ///
  /// Retrieve the minimum value of a given column.
  ///
  /// @param  String  $column
  /// @return float|int
  ///
  // dynamic min($column)
  // {
  //     return this.aggregate(__FUNCTION__, [$column]);
  // }

  ///
  /// Retrieve the maximum value of a given column.
  ///
  /// @param  String  $column
  /// @return float|int
  ///
  // dynamic max($column)
  // {
  //     return this.aggregate(__FUNCTION__, [$column]);
  // }

  ///
  /// Retrieve the sum of the values of a given column.
  ///
  /// @param  String  $column
  /// @return float|int
  ///
  // dynamic sum($column)
  // {
  //     $result = this.aggregate(__FUNCTION__, [$column]);

  //     return $result ?: 0;
  // }

  ///
  /// Retrieve the average of the values of a given column.
  ///
  /// @param  String  $column
  /// @return float|int
  ///
  // dynamic avg($column)
  // {
  //     return this.aggregate(__FUNCTION__, [$column]);
  // }

  ///
  /// Alias for the "avg" method.
  ///
  /// @param  String  $column
  /// @return float|int
  ///
  // dynamic average($column)
  // {
  //     return this.avg($column);
  // }

  ///
  /// Execute an aggregate function on the database.
  ///
  /// @param  String  $function
  /// @param  array   $columns
  /// @return float|int
  ///
  Future<dynamic> aggregate(String function,
      [List<String> columnsP = const <String>['*']]) async {
    this.aggregateProp = {'function': function, 'columns': columnsP};

    List<dynamic>? cols =
        this.columnsProp != null ? [...this.columnsProp!] : null;
    var previousColumns = cols;

    // We will also back up the select bindings since the select clause will be
    // removed when performing the aggregate function. Once the query is run
    // we will add the bindings back onto this query so they can get used.
    // ignore: unused_local_variable
    var previousSelectBindings = [...(this.bindings['select'] as List)];

    this.bindings['select'] = [];

    var results = await this.get(columnsP);

    // Once we have executed the query, we will reset the aggregate property so
    // that more select queries can be executed against the database without
    // the aggregate value getting in the way when the grammar builds it.
    this.aggregateProp = null;
    this.columnsProp = previousColumns;
    this.bindings['select'] = previousSelectBindings;

    if (results.isNotEmpty) {
      var result = Utils.map_change_key_case_sd(results[0]);
      return result['aggregate'];
    }
  }

  ///
  /// Insert a new record into the database.
  ///
  /// [values]  values Map<String, dynamic>
  /// Return bool
  ///
  Future<dynamic> insert(Map<String, dynamic> values, [Duration? timeout]) {
    // if (empty($values)) {
    //     return true;
    // }

    // Since every insert gets treated like a batch insert, we will make sure the
    // bindings are structured in a way that is convenient for building these
    // inserts statements by verifying the elements are actually an array.
    // if (! Utils.is_map(values)) {
    //     values = [values];
    // }

    // Since every insert gets treated like a batch insert, we will make sure the
    // bindings are structured in a way that is convenient for building these
    // inserts statements by verifying the elements are actually an array.

    // for (var entry in values.entries) {
    //   var key =entry.key;
    //   var value=entry.value;
    //    // ksort($value);
    //     values[key] = value;
    // }

    // We'll treat every insert like a batch insert so we can easily insert each
    // of the records into the database consistently. This will make it much
    // easier on the grammars to just handle one type of record insertion.
    var bindings = [];

    for (var entry in values.entries) {
      var value = entry.value;
      bindings.add(value);
    }

    var sql = this.grammar.compileInsert(this, values);

    // Once we have compiled the insert statement's SQL we can execute it on the
    // connection and return a result as a boolean success indicator as that
    // is the same type of result returned by the raw connection instance.
    bindings = this.cleanBindings(bindings);

    return this.connection.insert(sql, bindings);
  }

  ///
  /// Insert a new record and get the value of the primary key.
  ///
  /// @param  array   $values
  /// @param  String  $sequence
  /// @return int
  ///
  Future<dynamic> insertGetId(Map<String, dynamic> keyValues,
      [String sequence = 'id']) async {
    final sql = this.grammar.compileInsertGetId(this, keyValues, sequence);
    final values = this.cleanBindings(keyValues.values.toList());
    return await this.processor.processInsertGetId(this, sql, values, sequence);
  }

  ///
  /// Update a record in the database.
  ///
  /// [keyValues] Map
  /// Return int
  ///
  Future<dynamic> update(Map<String, dynamic> keyValues,
      [Duration? timeout = Connection.defaultTimeout]) {
    var curentBindings = this.getBindings();
    var values = keyValues.values.toList();
    var mergedBindings = Utils.array_merge(values, curentBindings);

    final sql = this.grammar.compileUpdate(this, keyValues);
    return this.connection.update(sql, this.cleanBindings(mergedBindings));
  }

  ///
  /// Increment a column's value by a given amount.
  ///
  /// @param  String  $column
  /// @param  int     $amount
  /// @param  array   $extra
  /// @return int
  ///
  // dynamic increment($column, $amount = 1, array $extra = [])
  // {
  //     $wrapped = this.grammar->wrap($column);

  //     $columns = array_merge([$column => this.raw("$wrapped + $amount")], $extra);

  //     return this.update($columns);
  // }

  ///
  /// Decrement a column's value by a given amount.
  ///
  /// @param  String  $column
  /// @param  int     $amount
  /// @param  array   $extra
  /// @return int
  ///
  // dynamic decrement($column, $amount = 1, array $extra = [])
  // {
  //     $wrapped = this.grammar->wrap($column);

  //     $columns = array_merge([$column => this.raw("$wrapped - $amount")], $extra);

  //     return this.update($columns);
  // }

  ///
  /// Delete a record from the database.
  ///
  /// @param  mixed  $id
  /// @return int
  ///
  Future<int> delete(
      [dynamic id, Duration? timeout = Connection.defaultTimeout]) {
    // If an ID is passed to the method, we will set the where clause to check
    // the ID to allow developers to simply and quickly remove a single row
    // from their database without manually specifying the where clauses.
    if (!Utils.is_null(id)) {
      this.where('id', '=', id);
    }

    var sql = this.grammar.compileDelete(this);

    return this.connection.delete(sql, this.getBindings());
  }

  ///
  /// Run a truncate statement on the table.
  ///
  /// @return void
  ///
  void truncate() {
    for (var entry in this.grammar.compileTruncate(this).entries) {
      var sql = entry.key;
      var bindings = entry.value;
      this.connection.statement(sql, bindings);
    }
  }

  ///
  /// Get a new instance of the query builder.
  ///
  /// @return \Illuminate\Database\Query\Builder
  ///
  QueryBuilder newQuery() {
    return QueryBuilder(this.connection, this.grammar, this.processor);
  }

  ///
  /// Create a new query instance for a sub-query.
  ///
  /// @return \Illuminate\Database\Query\Builder
  ///
  QueryBuilder forSubQuery() {
    return this.newQuery();
  }

  ///
  /// Merge an array of where clauses and bindings.
  ///
  /// @param  array  $wheres
  /// @param  array  $bindings
  /// @return void
  ///
  dynamic mergeWheres(List<Map<String, dynamic>> wheresP, bindingsP) {
    //TODO checar se a mesclagem esta correta
    this.wheresProp = Utils.array_merge_ms(this.wheresProp, wheresP);

    this
        .bindings['where']
        .add(Utils.array_merge(this.bindings['where'], bindingsP));
  }

  ///
  /// Remove all of the expressions from a list of bindings.
  ///
  /// @param  array  $bindings
  /// @return array
  ///
  List cleanBindings(List bindings) {
    return Utils.array_filter(bindings, (binding) {
      return !(binding is QueryExpression);
    });
  }

  ///
  /// Create a raw database expression.
  ///
  /// @param  mixed  $value
  /// @return \Illuminate\Database\Query\Expression
  ///
  QueryExpression raw(dynamic value) {
    return this.connection.raw(value);
  }

  ///
  /// Get the current query value bindings in a flattened array.
  ///
  /// @return array
  ///
  List getBindings() {
    // return array_flatten(this.bindings);

    //TODO verificar isso

    var result = [];
    if (this.bindings['select'] != null) {
      result.addAll(this.bindings['select']);
    }
    if (this.bindings['join'] != null) {
      result.addAll(this.bindings['join']);
    }
    if (this.bindings['where'] != null) {
      result.addAll(this.bindings['where']);
    }
    if (this.bindings['having'] != null) {
      result.addAll(this.bindings['having']);
    }
    if (this.bindings['order'] != null) {
      result.addAll(this.bindings['order']);
    }
    if (this.bindings['union'] != null) {
      result.addAll(this.bindings['union']);
    }

    return result;
  }

  ///
  /// Get the raw array of bindings.
  ///
  /// @return array
  ///
  dynamic getRawBindings() {
    return this.bindings;
  }

  ///
  /// Set the bindings on the query builder.
  ///
  /// @param  array   $bindings
  /// @param  String  $type
  /// @return $this
  ///
  /// @throws \InvalidArgumentException
  ///
  dynamic setBindings(bindings, [type = 'where']) {
    if (!Utils.map_key_exists(type, this.bindings)) {
      throw InvalidArgumentException('Invalid binding type: $type.');
    }

    this.bindings[type] = bindings;

    return this;
  }

  ///
  /// Add a binding to the query.
  ///
  /// [value]  dynamic
  /// [type]  String
  /// @return $this
  ///
  /// @throws \InvalidArgumentException
  ///
  QueryBuilder addBinding(dynamic value, [String type = 'where']) {
    if (!Utils.map_key_exists(type, this.bindings)) {
      throw InvalidArgumentException("Invalid binding type: $type.");
    }

    if (Utils.is_array(value)) {
      /// TODO: checar isso pois acho que é array em vez de Map ?
      this.bindings[type] = Utils.array_merge(this.bindings[type], value);
    } else {
      this.bindings[type].add(value);
    }

    return this;
  }

  ///
  /// Merge an array of bindings into our bindings.
  ///
  /// @param  \Illuminate\Database\Query\Builder  $query
  /// @return $this
  ///
  QueryBuilder mergeBindings(QueryBuilder query) {
    //this.bindings = array_merge_recursive(this._bindings, query.bindings);
    return this;
  }

  ///
  /// Get the database connection instance.
  ///
  /// @return \Illuminate\Database\ConnectionInterface
  ///
  ConnectionInterface getConnection() {
    return this.connection;
  }

  ///
  /// Get the database query processor instance.
  ///
  /// @return \Illuminate\Database\Query\Processors\Processor
  ///
  Processor getProcessor() {
    return this.processor;
  }

  ///
  /// Get the query grammar instance.
  ///
  /// @return \Illuminate\Database\Query\Grammars\Grammar
  ///
  QueryGrammar getGrammar() {
    return this.grammar;
  }

  ///
  /// Use the write pdo for query.
  ///
  /// @return $this
  ///
  QueryBuilder useWritePdo() {
    this.useWritePdoProp = true;

    return this;
  }

  ///
  /// Handle dynamic method calls into the method.
  ///
  /// @param  String  $method
  /// @param  array   $parameters
  /// @return mixed
  ///
  /// @throws \BadMethodCallException
  ///
  // dynamic __call($method, $parameters)
  // {
  //     if (static::hasMacro($method)) {
  //         return this.macroCall($method, $parameters);
  //     }

  //     if (Str::startsWith($method, 'where')) {
  //         return this.dynamicWhere($method, $parameters);
  //     }

  //     $className = get_class($this);

  //     throw new BadMethodCallException("Call to undefined method {$className}::{$method}()");
  // }
}

// File: C:\MyDartProjects\eloquent\lib\src\schema\blueprint.dart
import 'package:eloquent/eloquent.dart';

/// namespace Illuminate\Database\Schema;
class Blueprint {
  ///
  /// The table the blueprint describes.
  ///
  /// @var string
  ///
  String? _table;

  ///
  /// The columns that should be added to the table.
  ///
  /// @var array
  ///
  List _columns = [];

  ///
  /// The commands that should be run for the table.
  ///
  /// @var array
  ///
  List<Fluent> _commands = [];

  ///
  /// The storage engine that should be used for the table.
  ///
  /// @var string
  ///
  String? engine;

  ///
  /// The default character set that should be used for the table.
  ///
  String? charset;

  ///
  /// The collation that should be used for the table.
  ///
  String? collation;

  ///
  /// Whether to make the table temporary.
  ///
  /// @var bool
  ///
  bool temporaryV = false;

  ///
  /// Create a new schema blueprint.
  ///
  /// @param  string  $table
  /// @param  \Closure|null  $callback
  /// @return void
  ///
  Blueprint(String tableP, [Function? callback]) {
    _table = tableP;

    if (!Utils.is_null(callback)) {
      callback!(this);
    }
  }

  ///
  /// Execute the blueprint against the database.
  ///
  /// @param  \Illuminate\Database\Connection  $connection
  /// @param  \Illuminate\Database\Schema\Grammars\Grammar $grammar
  /// @return void
  ///
  void build(Connection connection, SchemaGrammar grammar) {
    for (var statement in toSql(connection, grammar)) {
      connection.statement(statement);
    }
  }

  ///
  /// Get the raw SQL statements for the blueprint.
  ///
  /// @param  \Illuminate\Database\Connection  $connection
  /// @param  \Illuminate\Database\Schema\Grammars\Grammar  $grammar
  /// @return array
  ///
  List toSql(Connection connection, SchemaGrammar grammar) {
    addImpliedCommands();

    // var statements = [];
    // Each type of command has a corresponding compiler function on the schema
    // grammar which is used to build the necessary SQL statements to build
    // the blueprint element, so we'll just call that compilers function.
    // Cada tipo de comando tem uma função de compilação correspondente no esquema
    // gramática que é usada para construir as instruções SQL necessárias para construir
    // o elemento blueprint, então vamos chamar essa função de compiladores.
    //for (var command in _commands) {
    //  var method = 'compile' + Utils.ucfirst(command['name']);

    // if (Utils.method_exists(grammar, method)) {
    //   var sql =
    //       Utils.call_method(grammar, method, [this, command, connection]);
    //   if (!Utils.is_null(sql)) {
    //     statements = Utils.array_merge(statements, sql as List);
    //   }
    // }
    //}
    // return statements;
    throw UnimplementedError();
  }

  ///
  /// Add the commands that are implied by the blueprint.
  ///
  /// @return void
  ///
  void addImpliedCommands() {
    if (Utils.count(getAddedColumns()) > 0 && !creating()) {
      Utils.array_unshift(_commands, createCommand('add'));
    }

    if (Utils.count(getChangedColumns()) > 0 && !creating()) {
      Utils.array_unshift(_commands, createCommand('change'));
    }

    addFluentIndexes();
  }

  ///
  /// Add the index commands fluently specified on columns.
  ///
  /// @return void
  ///
  void addFluentIndexes() {
    // for (var column in columns  ) {
    //     for (var index in ['primary', 'unique', 'index'] ) {
    //         // If the index has been specified on the given column, but is simply
    //         // equal to "true" (boolean), no name has been specified for this
    //         // index, so we will simply call the index methods without one.
    //         if ($column->$index == true) {
    //             this.$index($column->name);

    //             continue 2;
    //         }

    //         // If the index has been specified on the column and it is something
    //         // other than boolean true, we will assume a name was provided on
    //         // the index specification, and pass in the name to the method.
    //         else if (isset($column->$index)) {
    //             this.$index($column->name, $column->$index);

    //             continue 2;
    //         }
    //     }
    // }
  }

  ///
  /// Determine if the blueprint has a create command.
  ///
  /// @return bool
  ///
  bool creating() {
    for (var command in _commands) {
      if (command['name'] == 'create') {
        return true;
      }
    }

    return false;
  }

  ///
  /// Indicate that the table needs to be created.
  ///
  /// @return \Illuminate\Support\Fluent
  ///
  Fluent create() {
    return addCommand('create');
  }

  ///
  /// Indicate that the table needs to be temporary.
  ///
  /// @return void
  ///
  void temporary() {
    temporaryV = true;
  }

  ///
  /// Indicate that the table should be dropped.
  ///
  /// @return \Illuminate\Support\Fluent
  ///
  Fluent drop() {
    return addCommand('drop');
  }

  ///
  /// Indicate that the table should be dropped if it exists.
  ///
  /// @return \Illuminate\Support\Fluent
  ///
  Fluent dropIfExists() {
    return addCommand('dropIfExists');
  }

  ///
  /// Indicate that the given columns should be dropped.
  ///
  /// @param  array|mixed  $columns
  /// @return \Illuminate\Support\Fluent
  ///
  Fluent dropColumn(dynamic columnsP,
      [dynamic col1, dynamic col2, dynamic col3, dynamic col4, dynamic col5]) {
    var func_get_args = [];
    if (col1 != null) {
      func_get_args.add(col1);
    }
    if (col2 != null) {
      func_get_args.add(col2);
    }
    if (col3 != null) {
      func_get_args.add(col3);
    }
    if (col4 != null) {
      func_get_args.add(col4);
    }
    if (col5 != null) {
      func_get_args.add(col5);
    }
    var cols =
        Utils.is_array(columnsP) ? columnsP : func_get_args; //func_get_args()

    return addCommand('dropColumn', {'columns': cols});
  }

  ///
  /// Indicate that the given columns should be renamed.
  ///
  /// @param  string  $from
  /// @param  string  $to
  /// @return \Illuminate\Support\Fluent
  ///
  Fluent renameColumn(String from, String to) {
    return addCommand('renameColumn', {'from': from, 'to': to});
  }

  ///
  /// Indicate that the given primary key should be dropped.
  ///
  /// @param  string|array  $index
  /// @return \Illuminate\Support\Fluent
  ///
  Fluent dropPrimary([dynamic index = null]) {
    return dropIndexCommand('dropPrimary', 'primary', index);
  }

  ///
  /// Indicate that the given unique key should be dropped.
  ///
  /// @param  string|array  $index
  /// @return \Illuminate\Support\Fluent
  ///
  Fluent dropUnique(dynamic index) {
    return dropIndexCommand('dropUnique', 'unique', index);
  }

  ///
  /// Indicate that the given index should be dropped.
  ///
  /// @param  string|array  $index
  /// @return \Illuminate\Support\Fluent
  ///
  Fluent dropIndex(dynamic index) {
    return dropIndexCommand('dropIndex', 'index', index);
  }

  ///
  /// Indicate that the given foreign key should be dropped.
  ///
  /// @param  string  $index
  /// @return \Illuminate\Support\Fluent
  ///
  Fluent dropForeign(String index) {
    return dropIndexCommand('dropForeign', 'foreign', index);
  }

  ///
  /// Indicate that the timestamp columns should be dropped.
  ///
  /// @return void
  ///
  void dropTimestamps() {
    dropColumn('created_at', 'updated_at');
  }

  ///
  /// Indicate that the timestamp columns should be dropped.
  ///
  /// @return void
  ///
  void dropTimestampsTz() {
    dropTimestamps();
  }

  ///
  /// Indicate that the soft delete column should be dropped.
  ///
  /// @return void
  ///
  void dropSoftDeletes() {
    dropColumn('deleted_at');
  }

  ///
  /// Indicate that the remember token column should be dropped.
  ///
  /// @return void
  ///
  void dropRememberToken() {
    dropColumn('remember_token');
  }

  ///
  /// Rename the table to a given name.
  ///
  /// @param  string  $to
  /// @return \Illuminate\Support\Fluent
  ///
  Fluent rename(String to) {
    return addCommand('rename', {'to': to});
  }

  ///
  /// Specify the primary key(s) for the table.
  ///
  /// @param  string|array  $columns
  /// @param  string  $name
  /// @return \Illuminate\Support\Fluent
  ///
  Fluent primary(dynamic columns, [String? name]) {
    return indexCommand('primary', columns, name);
  }

  ///
  /// Specify a unique index for the table.
  ///
  /// @param  string|array  $columns
  /// @param  string  $name
  /// @return \Illuminate\Support\Fluent
  ///
  Fluent unique(dynamic columns, [String? name]) {
    return indexCommand('unique', columns, name);
  }

  ///
  /// Specify an index for the table.
  ///
  /// @param  string|array  $columns
  /// @param  string  $name
  /// @return \Illuminate\Support\Fluent
  ///
  Fluent index(dynamic columns, [String? name]) {
    return indexCommand('index', columns, name);
  }

  ///
  /// Specify a foreign key for the table.
  ///
  /// @param  string|array  $columns
  /// @param  string  $name
  /// @return \Illuminate\Support\Fluent
  ///
  Fluent foreign(dynamic columns, [String? name]) {
    return indexCommand('foreign', columns, name);
  }

  ///
  /// Create a new auto-incrementing integer (4-byte) column on the table.
  ///
  /// @param  string  $column
  /// @return \Illuminate\Support\Fluent
  ///
  Fluent increments(String column) {
    return unsignedInteger(column, true);
  }

  ///
  /// Create a new auto-incrementing small integer (2-byte) column on the table.
  ///
  /// @param  string  $column
  /// @return \Illuminate\Support\Fluent
  ///
  Fluent smallIncrements(String column) {
    return unsignedSmallInteger(column, true);
  }

  ///
  /// Create a new auto-incrementing medium integer (3-byte) column on the table.
  ///
  /// @param  string  $column
  /// @return \Illuminate\Support\Fluent
  ///
  mediumIncrements(String column) {
    return unsignedMediumInteger(column, true);
  }

  ///
  /// Create a new auto-incrementing big integer (8-byte) column on the table.
  ///
  /// @param  string  $column
  /// @return \Illuminate\Support\Fluent
  ///
  bigIncrements(String column) {
    return unsignedBigInteger(column, true);
  }

  ///
  /// Create a new char column on the table.
  ///
  /// @param  string  $column
  /// @param  int  $length
  /// @return \Illuminate\Support\Fluent
  ///
  char(String column, [int length = 255]) {
    return this.addColumn('char', column, {'length': length});
  }

  ///
  /// Create a new string column on the table.
  ///
  /// @param  string  $column
  /// @param  int  $length
  /// @return \Illuminate\Support\Fluent
  ///
  string(String column, [int length = 255]) {
    return this.addColumn('string', column, {'length': length});
  }

  ///
  /// Create a new text column on the table.
  ///
  /// @param  string  $column
  /// @return \Illuminate\Support\Fluent
  ///
  text(String column) {
    return this.addColumn('text', column);
  }

  ///
  /// Create a new medium text column on the table.
  ///
  /// @param  string  $column
  /// @return \Illuminate\Support\Fluent
  ///
  mediumText(String column) {
    return this.addColumn('mediumText', column);
  }

  ///
  /// Create a new long text column on the table.
  ///
  /// @param  string  $column
  /// @return \Illuminate\Support\Fluent
  ///
  longText(String column) {
    return this.addColumn('longText', column);
  }

  ///
  /// Create a new integer (4-byte) column on the table.
  ///
  /// @param  string  $column
  /// @param  bool  $autoIncrement
  /// @param  bool  $unsigned
  /// @return \Illuminate\Support\Fluent
  ///
  Fluent integer(String column,
      [bool autoIncrement = false, bool unsigned = false]) {
    return addColumn('integer', column,
        {'autoIncrement': autoIncrement, 'unsigned': unsigned});
  }

  ///
  /// Create a new tiny integer (1-byte) column on the table.
  ///
  /// @param  string  $column
  /// @param  bool  $autoIncrement
  /// @param  bool  $unsigned
  /// @return \Illuminate\Support\Fluent
  ///
  tinyInteger(String column, [bool autoIncrement = false, unsigned = false]) {
    return addColumn('tinyInteger', column,
        {'autoIncrement': autoIncrement, 'unsigned': unsigned});
  }

  ///
  /// Create a new small integer (2-byte) column on the table.
  ///
  /// @param  string  $column
  /// @param  bool  $autoIncrement
  /// @param  bool  $unsigned
  /// @return \Illuminate\Support\Fluent
  ///
  smallInteger(String column,
      [bool autoIncrement = false, bool unsigned = false]) {
    return addColumn('smallInteger', column,
        {'autoIncrement': autoIncrement, 'unsigned': unsigned});
  }

  ///
  /// Create a new medium integer (3-byte) column on the table.
  ///
  /// @param  string  $column
  /// @param  bool  $autoIncrement
  /// @param  bool  $unsigned
  /// @return \Illuminate\Support\Fluent
  ///
  mediumInteger(String column,
      [bool autoIncrement = false, bool unsigned = false]) {
    return addColumn('mediumInteger', column,
        {'autoIncrement': autoIncrement, 'unsigned': unsigned});
  }

  ///
  /// Create a new big integer (8-byte) column on the table.
  ///
  /// @param  string  $column
  /// @param  bool  $autoIncrement
  /// @param  bool  $unsigned
  /// @return \Illuminate\Support\Fluent
  ///
  bigInteger(String column,
      [bool autoIncrement = false, bool unsigned = false]) {
    return addColumn('bigInteger', column,
        {'autoIncrement': autoIncrement, 'unsigned': unsigned});
  }

  ///
  /// Create a new unsigned tiny integer (1-byte) column on the table.
  ///
  /// @param  string  $column
  /// @param  bool  $autoIncrement
  /// @return \Illuminate\Support\Fluent
  ///
  unsignedTinyInteger(String column, [bool autoIncrement = false]) {
    return tinyInteger(column, autoIncrement, true);
  }

  ///
  /// Create a new unsigned small integer (2-byte) column on the table.
  ///
  /// @param  string  $column
  /// @param  bool  $autoIncrement
  /// @return \Illuminate\Support\Fluent
  ///
  unsignedSmallInteger(String column, [bool autoIncrement = false]) {
    return smallInteger(column, autoIncrement, true);
  }

  ///
  /// Create a new unsigned medium integer (3-byte) column on the table.
  ///
  /// @param  string  $column
  /// @param  bool  $autoIncrement
  /// @return \Illuminate\Support\Fluent
  ///
  unsignedMediumInteger(String column, [bool autoIncrement = false]) {
    return mediumInteger(column, autoIncrement, true);
  }

  ///
  /// Create a new unsigned integer (4-byte) column on the table.
  ///
  /// @param  string  $column
  /// @param  bool  $autoIncrement
  /// @return \Illuminate\Support\Fluent
  ///
  unsignedInteger(String column, [bool autoIncrement = false]) {
    return integer(column, autoIncrement, true);
  }

  ///
  /// Create a new unsigned big integer (8-byte) column on the table.
  ///
  /// @param  string  $column
  /// @param  bool  $autoIncrement
  /// @return \Illuminate\Support\Fluent
  ///
  unsignedBigInteger(String column, [bool autoIncrement = false]) {
    return bigInteger(column, autoIncrement, true);
  }

  ///
  /// Create a new float column on the table.
  ///
  /// @param  string  $column
  /// @param  int     $total
  /// @param  int     $places
  /// @return \Illuminate\Support\Fluent
  ///
  float(String column, [int total = 8, int places = 2]) {
    return addColumn('float', column, {'total': total, 'places': places});
  }

  ///
  /// Create a new double column on the table.
  ///
  /// @param  string   $column
  /// @param  int|null    $total
  /// @param  int|null $places
  /// @return \Illuminate\Support\Fluent
  ///
  double(String column, [int? total = null, int? places = null]) {
    return addColumn('double', column, {'total': total, 'places': places});
  }

  ///
  /// Create a new decimal column on the table.
  ///
  /// @param  string  $column
  /// @param  int     $total
  /// @param  int     $places
  /// @return \Illuminate\Support\Fluent
  ///
  decimal(String column, [int total = 8, int places = 2]) {
    return addColumn('decimal', column, {'total': total, 'places': places});
  }

  ///
  /// Create a new boolean column on the table.
  ///
  /// @param  string  $column
  /// @return \Illuminate\Support\Fluent
  ///
  boolean(String column) {
    return addColumn('boolean', column);
  }

  ///
  /// Create a new enum column on the table.
  ///
  /// @param  string  $column
  /// @param  array   $allowed
  /// @return \Illuminate\Support\Fluent
  ///
  enumeration(String column, allowed) {
    return addColumn('enum', column, {'allowed': allowed});
  }

  ///
  /// Create a new json column on the table.
  ///
  /// @param  string  $column
  /// @return \Illuminate\Support\Fluent
  ///
  json(String column) {
    return addColumn('json', column);
  }

  ///
  /// Create a new jsonb column on the table.
  ///
  /// @param  string  $column
  /// @return \Illuminate\Support\Fluent
  ///
  jsonb(String column) {
    return addColumn('jsonb', column);
  }

  ///
  /// Create a new date column on the table.
  ///
  /// @param  string  $column
  /// @return \Illuminate\Support\Fluent
  ///
  date(String column) {
    return addColumn('date', column);
  }

  ///
  /// Create a new date-time column on the table.
  ///
  /// @param  string  $column
  /// @return \Illuminate\Support\Fluent
  ///
  dateTime(String column) {
    return addColumn('dateTime', column);
  }

  ///
  /// Create a new date-time column (with time zone) on the table.
  ///
  /// @param  string  $column
  /// @return \Illuminate\Support\Fluent
  ///
  dateTimeTz(String column) {
    return addColumn('dateTimeTz', column);
  }

  ///
  /// Create a new time column on the table.
  ///
  /// @param  string  $column
  /// @return \Illuminate\Support\Fluent
  ///
  time(String column) {
    return addColumn('time', column);
  }

  ///
  /// Create a new time column (with time zone) on the table.
  ///
  /// @param  string  $column
  /// @return \Illuminate\Support\Fluent
  ///
  timeTz(String column) {
    return addColumn('timeTz', column);
  }

  ///
  /// Create a new timestamp column on the table.
  ///
  /// @param  string  $column
  /// @return \Illuminate\Support\Fluent
  ///
  Fluent timestamp(String column) {
    return addColumn('timestamp', column);
  }

  ///
  /// Create a new timestamp (with time zone) column on the table.
  ///
  /// @param  string  $column
  /// @return \Illuminate\Support\Fluent
  ///
  timestampTz(String column) {
    return addColumn('timestampTz', column);
  }

  ///
  /// Add nullable creation and update timestamps to the table.
  ///
  /// @return void
  ///
  nullableTimestamps() {
    // this.timestamp('created_at')->nullable();
    // this.timestamp('updated_at')->nullable();
  }

  ///
  /// Add creation and update timestamps to the table.
  ///
  /// @return void
  ///
  timestamps() {
    this.timestamp('created_at');
    this.timestamp('updated_at');
  }

  ///
  /// Add creation and update timestampTz columns to the table.
  ///
  /// @return void
  ///
  timestampsTz() {
    this.timestampTz('created_at');
    this.timestampTz('updated_at');
  }

  ///
  /// Add a "deleted at" timestamp for the table.
  ///
  /// @return \Illuminate\Support\Fluent
  ///
  softDeletes() {
    //return this.timestamp('deleted_at')->nullable();
  }

  ///
  /// Create a new binary column on the table.
  ///
  /// @param  string  $column
  /// @return \Illuminate\Support\Fluent
  ///
  binary($column) {
    return this.addColumn('binary', $column);
  }

  ///
  /// Create a new uuid column on the table.
  ///
  /// @param  string  $column
  /// @return \Illuminate\Support\Fluent
  ///
  uuid($column) {
    return this.addColumn('uuid', $column);
  }

  ///
  /// Add the proper columns for a polymorphic table.
  ///
  /// @param  string  $name
  /// @param  string|null  $indexName
  /// @return void
  ///
  morphs(String name, [String? indexName]) {
    this.unsignedInteger("${name}_id");

    this.string("${name}_type");

    this.index(["${name}_id", "${name}_type"], indexName);
  }

  ///
  /// Adds the `remember_token` column to the table.
  ///
  /// @return \Illuminate\Support\Fluent
  ///
  rememberToken() {
    //return this.string('remember_token', 100)->nullable();
  }

  ///
  /// Create a new drop index command on the blueprint.
  ///
  /// @param  string  $command
  /// @param  string  $type
  /// @param  string|array  $index
  /// @return \Illuminate\Support\Fluent
  ///
  dropIndexCommand(String command, String type, dynamic index) {
    var cols = [];

    // If the given "index" is actually an array of columns, the developer means
    // to drop an index merely by specifying the columns involved without the
    // conventional name, so we will build the index name from the columns.
    if (Utils.is_array(index)) {
      cols = index;

      index = this.createIndexName(type, cols);
    }

    return this.indexCommand(command, cols, index);
  }

  ///
  /// Add a new index command to the blueprint.
  ///
  /// @param  string        $type
  /// @param  string|array  $columns
  /// @param  string        $index
  /// @return \Illuminate\Support\Fluent
  ///
  indexCommand(String type, dynamic columnsP, String? index) {
    var cols = columnsP;

    // If no name was specified for this index, we will create one using a basic
    // convention of the table name, followed by the columns, followed by an
    // index type, such as primary or index, which makes the index unique.
    if (Utils.is_null(index)) {
      index = this.createIndexName(type, cols);
    }

    return this.addCommand(type, {'index': index, 'columns': cols});
  }

  ///
  /// Create a default index name for the table.
  ///
  /// @param  string  $type
  /// @param  array   $columns
  /// @return string
  ///
  createIndexName(String type, List columns) {
    var index = Utils.strtolower(
        this._table! + '_' + Utils.implode('_', columns) + '_' + type);

    return Utils.str_replace(['-', '.'], '_', index);
  }

  ///
  /// Add a new column to the blueprint.
  ///
  /// @param  string  $type
  /// @param  string  $name
  /// @param  array   $parameters
  /// @return \Illuminate\Support\Fluent
  ///
  Fluent addColumn(String type, String name,
      [Map<String, dynamic> parameters = const {}]) {
    var attributes =
        Utils.map_merge_sd({'type': type, 'name': name}, parameters);
    var column = new Fluent(attributes);
    this._columns.add(column);
    return column;
  }

  ///
  /// Remove a column from the schema blueprint.
  ///
  /// @param  string  $name
  /// @return $this
  ///
  removeColumn(String name) {
    // this.columns = array_values(array_filter(this.columns, function ($c) use ($name) {
    //     return $c['attributes']['name'] != $name;
    // }));

    return this;
  }

  ///
  /// Add a new command to the blueprint.
  ///
  /// @param  string  $name
  /// @param  array  $parameters
  /// @return \Illuminate\Support\Fluent
  ///
  Fluent addCommand(String name, [Map<String, dynamic>? parameters]) {
    var command = createCommand(name, parameters);
    _commands.add(command);

    return command;
  }

  ///
  /// Create a new Fluent command.
  ///
  /// [name]  String
  /// [parameters]  Map
  /// Return \Support\Fluent
  ///
  Fluent createCommand(String name, [Map<String, dynamic>? parameters]) {
    var attributesP = <String, dynamic>{'name': name};
    if (parameters != null) {
      attributesP.addAll(parameters);
    }
    return Fluent(attributesP);
  }

  ///
  /// Get the table the blueprint describes.
  ///
  /// @return string
  ///
  String getTable() {
    return _table!;
  }

  ///
  /// Get the columns on the blueprint.
  ///
  /// @return array
  ///
  List getColumns() {
    return _columns;
  }

  ///
  /// Get the commands on the blueprint.
  ///
  /// @return array
  ///
  List getCommands() {
    return _commands;
  }

  ///
  /// Get the columns on the blueprint that should be added.
  ///
  /// @return array
  ///
  List getAddedColumns() {
    return Utils.array_filter(this._columns, (column) {
      return !column['change'];
    });
    //return [];
  }

  ///
  /// Get the columns on the blueprint that should be changed.
  ///
  /// @return array
  ///
  List getChangedColumns() {
    return Utils.array_filter(this._columns, (column) {
      return column['change'];
    });
  }
}

// File: C:\MyDartProjects\eloquent\lib\src\schema\grammars\schema_grammar.dart
import 'package:eloquent/eloquent.dart';

/// in PHP is \Illuminate\Database\Schema\Grammars\Grammar
class SchemaGrammar extends BaseGrammar {
  ///
  /// The possible column modifiers.
  ///
  /// @var array
  ///
  List<String> modifiers = [];

  ///
  /// Compile the query to determine if a table exists.
  ///
  /// @return string
  ///
  String compileTableExists() {
    return 'select * from information_schema.tables where table_name = ?';
  }

  ///
  /// Compile the query to determine the list of columns.
  ///
  /// @param  string  $table
  /// @return string
  ///
  String compileColumnExists(String table) {
    return "select column_name from information_schema.columns where table_name = '$table'";
  }

  ///
  /// Compile a rename column command.
  ///
  /// @param  \Illuminate\Database\Schema\Blueprint  $blueprint
  /// @param  \Illuminate\Support\Fluent  $command
  /// @param  \Illuminate\Database\Connection  $connection
  /// @return array
  ///
  dynamic compileRenameColumn(
      Blueprint blueprint, Fluent command, Connection connection) {
    var schema = connection.getDoctrineSchemaManager();

    var table = this.getTablePrefix() + blueprint.getTable();

    var column = connection.getDoctrineColumn(table, command['from']);

    var tableDiff = this.getRenamedDiff(blueprint, command, column, schema);

    return schema.getDatabasePlatform().getAlterTableSQL(tableDiff);
  }

  ///
  /// Get a new column instance with the new column name.
  ///
  /// @param  \Illuminate\Database\Schema\Blueprint  $blueprint
  /// @param  \Illuminate\Support\Fluent  $command
  /// @param  \Doctrine\DBAL\Schema\Column  $column
  /// @param  \Doctrine\DBAL\Schema\AbstractSchemaManager  $schema
  /// @return \Doctrine\DBAL\Schema\TableDiff
  ///
  dynamic getRenamedDiff(
      Blueprint blueprint, Fluent command, dynamic column, dynamic schema) {
    var tableDiff = this.getDoctrineTableDiff(blueprint, schema);
    return this.setRenamedColumns(tableDiff, command, column);
  }

  ///
  /// Set the renamed columns on the table diff.
  ///
  /// @param  \Doctrine\DBAL\Schema\TableDiff  $tableDiff
  /// @param  \Illuminate\Support\Fluent  $command
  /// @param  \Doctrine\DBAL\Schema\Column  $column
  /// @return \Doctrine\DBAL\Schema\TableDiff
  ///
  dynamic setRenamedColumns(dynamic tableDiff, Fluent command, dynamic column) {
    // $newColumn = new Column($command->to, $column->getType(), $column->toArray());
    // $tableDiff->renamedColumns = [$command->from => $newColumn];
    // return $tableDiff;
  }

  ///
  /// Compile a foreign key command.
  ///
  /// @param  \Illuminate\Database\Schema\Blueprint  $blueprint
  /// @param  \Illuminate\Support\Fluent  $command
  /// @return string
  ///
  String compileForeign(Blueprint $blueprint, Fluent command) {
    var table = this.wrapTable($blueprint);

    var on = this.wrapTable(command['on']);

    // We need to prepare several of the elements of the foreign key definition
    // before we can create the SQL, such as wrapping the tables and convert
    // an array of columns to comma-delimited strings for the SQL queries.
    var columns = this.columnize(command['columns']);

    var onColumns = this.columnize(command['references']);

    var sql = "alter table {$table} add constraint {$command->index} ";

    sql += "foreign key (${columns}) references ${on} (${onColumns})";

    // Once we have the basic foreign key creation statement constructed we can
    // build out the syntax for what should happen on an update or delete of
    // the affected columns, which will get something like "cascade", etc.
    if (!Utils.is_null(command['onDelete'])) {
      sql += " on delete ${command['onDelete']}";
    }

    if (!Utils.is_null(command['onUpdate'])) {
      sql += " on update {$command['onUpdate']}";
    }

    return sql;
  }

  ///
  /// Compile the blueprint's column definitions.
  ///
  /// @param  \Illuminate\Database\Schema\Blueprint $blueprint
  /// @return array
  ///
  dynamic getColumns(Blueprint blueprint) {
    var columns = [];

    for (var column in blueprint.getAddedColumns()) {
      // Each of the column types have their own compiler functions which are tasked
      // with turning the column definition into its SQL format for this platform
      // used by the connection. The column's modifiers are compiled and added.
      var sql = this.wrap(column) + ' ' + this.getType(column);

      columns.add(this.addModifiers(sql, blueprint, column));
    }

    return columns;
  }

  ///
  /// Add the column modifiers to the definition.
  ///
  /// @param  string  $sql
  /// @param  \Illuminate\Database\Schema\Blueprint  $blueprint
  /// @param  \Illuminate\Support\Fluent  $column
  /// @return string
  ///
  String addModifiers(sql, Blueprint blueprint, Fluent column) {
    // for (var modifier in this.modifiers) {
    //   var method = "modify${modifier}";
    //   // if (Utils.method_exists(this, method)) {
    //   //   //sql += this.{$method}(blueprint, column);
    //   //   sql += Utils.call_method(this, method, [blueprint, column]);
    //   // }

    // }
    // return sql;

    throw UnimplementedError();
  }

  ///
  /// Get the primary key command if it exists on the blueprint.
  ///
  /// @param  \Illuminate\Database\Schema\Blueprint  $blueprint
  /// @param  string  $name
  /// @return \Illuminate\Support\Fluent|null
  ///
  dynamic getCommandByName(Blueprint blueprint, String name) {
    var commands = this.getCommandsByName(blueprint, name);

    if (Utils.count(commands) > 0) {
      // return reset(commands);
      return commands;
    }
  }

  ///
  /// Get all of the commands with a given name.
  ///
  /// @param  \Illuminate\Database\Schema\Blueprint  $blueprint
  /// @param  string  $name
  /// @return array
  ///
  List getCommandsByName(Blueprint blueprint, name) {
    return Utils.array_filter(blueprint.getCommands(), (value) {
      return value['name'] == name;
    });
  }

  ///
  /// Get the SQL for the column data type.
  ///
  /// @param  \Illuminate\Support\Fluent  $column
  /// @return string
  ///
  String getType(Fluent column) {
    //return this.{'type'.ucfirst($column->type)}($column);
    // return Utils.call_method(
    //     this, 'type' + Utils.ucfirst(column['type']), [column]);
    throw UnimplementedError();
  }

  ///
  /// Add a prefix to an array of values.
  ///
  /// @param  string  $prefix
  /// @param  array   $values
  /// @return array
  ///
  List prefixArray(String prefix, List values) {
    return Utils.array_map((value) {
      return prefix + ' ' + value;
    }, values);
  }

  ///
  /// Wrap a table in keyword identifiers.
  ///
  /// @param  mixed   $table
  /// @return string
  ///
  String wrapTable(dynamic table) {
    if (table is Blueprint) {
      table = table.getTable();
    }

    return super.wrapTable(table);
  }

  ///
  /// 
  ///
  String wrap(dynamic value, [bool prefixAlias = false]) {
    if (value is Fluent) {
      value = value['name'];
    }

    return super.wrap(value, prefixAlias);
  }

  ///
  /// Format a value so that it can be used in "default" clauses.
  ///
  /// @param  mixed   $value
  /// @return string
  ///
  dynamic getDefaultValue(dynamic value) {
    if (value is QueryExpression) {
      return value;
    }

    if (Utils.is_bool(value)) {
      return "'" + value + "'";
    }

    return "'" + Utils.strval(value) + "'";
  }

  ///
  /// Create an empty Doctrine DBAL TableDiff from the Blueprint.
  ///
  /// @param  \Illuminate\Database\Schema\Blueprint  $blueprint
  /// @param  \Doctrine\DBAL\Schema\AbstractSchemaManager  $schema
  /// @return \Doctrine\DBAL\Schema\TableDiff
  ///
  dynamic getDoctrineTableDiff(Blueprint blueprint, dynamic schema) {
    // $table = this.getTablePrefix().$blueprint->getTable();
    // $tableDiff = new TableDiff($table);
    // $tableDiff->fromTable = $schema->listTableDetails($table);
    // return $tableDiff;
  }

  ///
  /// Compile a change column command into a series of SQL statements.
  ///
  /// @param  \Illuminate\Database\Schema\Blueprint  $blueprint
  /// @param  \Illuminate\Support\Fluent  $command
  /// @param  \Illuminate\Database\Connection $connection
  /// @return array
  ///
  dynamic compileChange(
      Blueprint blueprint, Fluent command, Connection connection) {
    // if (! $connection->isDoctrineAvailable()) {
    //     throw new RuntimeException(sprintf(
    //         'Changing columns for table "%s" requires Doctrine DBAL; install "doctrine/dbal".',
    //         $blueprint->getTable()
    //     ));
    // }

    // $schema = $connection->getDoctrineSchemaManager();

    // $tableDiff = this.getChangedDiff($blueprint, $schema);

    // if ($tableDiff !== false) {
    //     return (array) $schema->getDatabasePlatform()->getAlterTableSQL($tableDiff);
    // }

    // return [];
  }

  ///
  /// Get the Doctrine table difference for the given changes.
  ///
  /// @param  \Illuminate\Database\Schema\Blueprint  $blueprint
  /// @param  \Doctrine\DBAL\Schema\AbstractSchemaManager  $schema
  /// @return \Doctrine\DBAL\Schema\TableDiff|bool
  ///
  dynamic getChangedDiff(Blueprint blueprint, dynamic schema) {
    // $table = $schema->listTableDetails(this.getTablePrefix().$blueprint->getTable());
    // return (new Comparator)->diffTable($table, this.getTableWithColumnChanges($blueprint, $table));
  }

  ///
  /// Get a copy of the given Doctrine table after making the column changes.
  ///
  /// @param  \Illuminate\Database\Schema\Blueprint  $blueprint
  /// @param  \Doctrine\DBAL\Schema\Table  $table
  /// @return \Doctrine\DBAL\Schema\TableDiff
  ///
  dynamic getTableWithColumnChanges(Blueprint blueprint, dynamic table) {
    // $table = clone $table;
    // foreach ($blueprint->getChangedColumns() as $fluent) {
    //     $column = this.getDoctrineColumnForChange($table, $fluent);

    //     // Here we will spin through each fluent column definition and map it to the proper
    //     // Doctrine column definitions - which is necessary because Laravel and Doctrine
    //     // use some different terminology for various column attributes on the tables.
    //     foreach ($fluent->getAttributes() as $key => $value) {
    //         if (! is_null($option = this.mapFluentOptionToDoctrine($key))) {
    //             if (method_exists($column, $method = 'set'.ucfirst($option))) {
    //                 $column->{$method}(this.mapFluentValueToDoctrine($option, $value));
    //             }
    //         }
    //     }
    // }
    // return $table;
  }

  ///
  /// Get the Doctrine column instance for a column change.
  ///
  /// @param  \Doctrine\DBAL\Schema\Table  $table
  /// @param  \Illuminate\Support\Fluent  $fluent
  /// @return \Doctrine\DBAL\Schema\Column
  ///
  dynamic getDoctrineColumnForChange(dynamic table, Fluent fluent) {
    // return $table->changeColumn(
    //     $fluent['name'], this.getDoctrineColumnChangeOptions($fluent)
    // )->getColumn($fluent['name']);
  }

  ///
  /// Get the Doctrine column change options.
  ///
  /// @param  \Illuminate\Support\Fluent  $fluent
  /// @return array
  ///
  dynamic getDoctrineColumnChangeOptions(Fluent fluent) {
    // $options = ['type' => this.getDoctrineColumnType($fluent['type'])];

    // if (in_array($fluent['type'], ['text', 'mediumText', 'longText'])) {
    //     $options['length'] = this.calculateDoctrineTextLength($fluent['type']);
    // }

    // return $options;
  }

  ///
  /// Get the doctrine column type.
  ///
  /// @param  string  $type
  /// @return \Doctrine\DBAL\Types\Type
  ///
  dynamic getDoctrineColumnType($type) {
    // $type = strtolower($type);

    // switch ($type) {
    //     case 'biginteger':
    //         $type = 'bigint';
    //         break;
    //     case 'smallinteger':
    //         $type = 'smallint';
    //         break;
    //     case 'mediumtext':
    //     case 'longtext':
    //         $type = 'text';
    //         break;
    // }

    // return Type::getType($type);
  }

  ///
  /// Calculate the proper column length to force the Doctrine text type.
  ///
  /// @param  string  $type
  /// @return int
  ///
  dynamic calculateDoctrineTextLength(String type) {
    switch (type) {
      case 'mediumText':
        return 65535 + 1;

      case 'longText':
        return 16777215 + 1;

      default:
        return 255 + 1;
    }
  }

  ///
  /// Get the matching Doctrine option for a given Fluent attribute name.
  ///
  /// @param  string  $attribute
  /// @return string|null
  ///
  dynamic mapFluentOptionToDoctrine($attribute) {
    switch ($attribute) {
      case 'type':
      case 'name':
        return;

      case 'nullable':
        return 'notnull';

      case 'total':
        return 'precision';

      case 'places':
        return 'scale';

      default:
        return $attribute;
    }
  }

  ///
  /// Get the matching Doctrine value for a given Fluent attribute.
  ///
  /// @param  string  $option
  /// @param  mixed  $value
  /// @return mixed
  ///
  dynamic mapFluentValueToDoctrine(String option, dynamic value) {
    return option == 'notnull' ? !value : value;
  }
}

// File: C:\MyDartProjects\eloquent\lib\src\schema\grammars\schema_mysql_grammar.dart
import 'package:eloquent/eloquent.dart';

class SchemaMySqlGrammar extends SchemaGrammar {}

// File: C:\MyDartProjects\eloquent\lib\src\schema\grammars\schema_postgres_grammar.dart
import 'package:eloquent/eloquent.dart';

class SchemaPostgresGrammar extends SchemaGrammar {}

// File: C:\MyDartProjects\eloquent\lib\src\schema\schema_builder.dart
import 'package:eloquent/eloquent.dart';

class SchemaBuilder {
  ///
  /// The database connection instance.
  ///
  /// @var \Illuminate\Database\Connection
  ///
  late Connection connection;

  ///
  /// The schema grammar instance.
  ///
  /// @var \Illuminate\Database\Schema\Grammars\Grammar
  ///
  late SchemaGrammar grammar;

  ///
  /// The Blueprint resolver callback.
  ///
  /// @var \Closure
  ///
  Function? resolver;

  ///
  /// Create a new database Schema manager.
  ///
  /// @param  \Illuminate\Database\Connection  $connection
  ///
  ///
  SchemaBuilder(this.connection) {
    grammar = connection.getSchemaGrammar();
  }

  ///
  /// Determine if the given table exists.
  ///
  /// @param  string  $table
  /// @return bool
  ///
  Future<bool> hasTable(String tableP)async {
    var sql = grammar.compileTableExists();

    var table = this.connection.getTablePrefix() + tableP;

    return Utils.count(await this.connection.select(sql, [table])) > 0;
  }

  ///
  /// Determine if the given table has a given column.
  ///
  /// @param  string  $table
  /// @param  string  $column
  /// @return bool
  ///
  bool hasColumn(String table, String columnP) {
    var column = Utils.strtolower(columnP);
    return Utils.in_array(
        column, Utils.array_map(Utils.strtolower, getColumnListing(table)));
  }

  ///
  /// Determine if the given table has given columns.
  ///
  /// @param  string  $table
  /// @param  array   $columns
  /// @return bool
  ///
  bool hasColumns(String table, List columns) {
    var tableColumns =
        Utils.array_map(Utils.strtolower, getColumnListing(table));

    for (var column in columns) {
      if (!Utils.in_array(Utils.strtolower(column), tableColumns)) {
        return false;
      }
    }

    return true;
  }

  ///
  /// Get the column listing for a given table.
  ///
  /// @param  string  $table
  /// @return array
  ///
  List getColumnListing(String tableP) {
    var table = connection.getTablePrefix() + tableP;
    var results = connection.select(grammar.compileColumnExists(table));
    return connection.getPostProcessor().processColumnListing(results);
  }

  ///
  /// Modify a table on the schema.
  ///
  /// @param  string    $table
  /// @param  \Closure  $callback
  /// @return \Illuminate\Database\Schema\Blueprint
  ///
  dynamic table(String table, Function callback) {
    build(createBlueprint(table, callback));
  }

  ///
  /// Create a new table on the schema.
  ///
  /// @param  string    $table
  /// @param  \Closure  $callback
  /// @return \Illuminate\Database\Schema\Blueprint
  ///
  dynamic create(String table, Function callback) {
    var blueprint = createBlueprint(table);

    blueprint.create();

    callback(blueprint);

    build(blueprint);
  }

  ///
  /// Drop a table from the schema.
  ///
  /// @param  string  $table
  /// @return \Illuminate\Database\Schema\Blueprint
  ///
  dynamic drop(String table) {
    var blueprint = createBlueprint(table);

    blueprint.drop();

    build(blueprint);
  }

  ///
  /// Drop a table from the schema if it exists.
  ///
  /// @param  string  $table
  /// @return \Illuminate\Database\Schema\Blueprint
  ///
  dynamic dropIfExists(String table) {
    var blueprint = createBlueprint(table);

    blueprint.dropIfExists();

    build(blueprint);
  }

  ///
  /// Rename a table on the schema.
  ///
  /// @param  string  $from
  /// @param  string  $to
  /// @return \Illuminate\Database\Schema\Blueprint
  ///
  dynamic rename(String from, String to) {
    var blueprint = createBlueprint(from);

    blueprint.rename(to);

    build(blueprint);
  }

  ///
  /// Execute the blueprint to build / modify the table.
  ///
  /// @param  \Illuminate\Database\Schema\Blueprint  $blueprint
  /// @return void
  ///
  void build(Blueprint blueprint) {
    blueprint.build(connection, grammar);
  }

  ///
  /// Create a new command set with a Closure.
  ///
  /// @param  string  $table
  /// @param  \Closure|null  $callback
  /// @return \Illuminate\Database\Schema\Blueprint
  ///
  dynamic createBlueprint(String table, [Function? callback]) {
    if (this.resolver != null) {
      //return call_user_func($this->resolver, $table, $callback);
      this.resolver!(table, callback);
    }

    return Blueprint(table, callback);
  }

  ///
  /// Get the database connection instance.
  ///
  /// @return \Illuminate\Database\Connection
  ///
  Connection getConnection() {
    return connection;
  }

  ///
  /// Set the database connection instance.
  ///
  /// @param  \Illuminate\Database\Connection  $connection
  /// @return $this
  ///
  dynamic setConnection(Connection connectionP) {
    connection = connectionP;
    return this;
  }

  ///
  /// Set the Schema Blueprint resolver callback.
  ///
  /// @param  \Closure  $resolver
  /// @return void
  ///
  void blueprintResolver(Function resolver) {
    resolver = resolver;
  }
}

// File: C:\MyDartProjects\eloquent\lib\src\support\fluent.dart
import 'dart:convert';

import '../utils/utils.dart';

class Fluent {
  ///
  /// All of the attributes set on the container.
  ///
  /// @var array
  ///
  Map<String, dynamic> attributes = {};

  ///
  /// Create a new fluent container instance.
  ///
  /// @param  array|object    $attributes
  /// @return void
  ///
  Fluent([Map<String, dynamic>? attributesP]) {
    if (attributesP != null) {
      for (var at in attributesP.entries) {
        attributes.addAll({at.key: at.value});
      }
    }
  }

  operator [](String key) => offsetGet(key); // get
  operator []=(String key, dynamic value) => offsetSet(key, value); // set

  ///
  /// Get an attribute from the container.
  ///
  /// @param  string  $key
  /// @param  mixed   $default
  /// @return mixed
  ///
  dynamic get(String key, [dynamic defaultP]) {
    // for (var item in attributes.entries) {
    //   if (item.key == key) {
    //     return item;
    //   }
    // }
    if (attributes.containsKey(key)) {
      return attributes[key];
    }

    return Utils.value(defaultP);
  }

  ///
  /// Get the attributes from the container.
  ///
  /// @return array
  ///
  Map getAttributes() {
    return attributes;
  }

  ///
  /// Convert the Fluent instance to JSON.
  ///
  /// @param  int  $options
  /// @return string
  ///
  String toJson() {
    return jsonEncode(attributes);
  }

  ///
  /// Determine if the given offset exists.
  ///
  /// @param  string  $offset
  /// @return bool
  ///
  bool offsetExists(String offset) {
    // return isset($this->{$offset});
    return this.attributes.containsKey(offset);
  }

  ///
  /// Get the value for a given offset.
  ///
  /// @param  string  $offset
  /// @return mixed
  ///
  dynamic offsetGet(String offset) {
    //return $this->{$offset};
    //return false;
    return get(offset);
  }

  ///
  /// Set the value at the given offset.
  ///
  /// @param  string  $offset
  /// @param  mixed   $value
  /// @return void
  ///
  void offsetSet(String offset, dynamic value) {
    //$this->{$offset} = $value;
    this.attributes[offset] = value;
  }

  ///
  /// Unset the value at the given offset.
  ///
  /// @param  string  $offset
  /// @return void
  ///
  void offsetUnset(String offset) {
    //unset($this->{$offset});
    this.attributes.remove(offset);
  }

  ///
  /// Handle dynamic calls to the container to set attributes.
  ///
  /// @param  string  $method
  /// @param  array   $parameters
  /// @return $this
  ///
  //  __call($method, $parameters)
  // {
  //     $this->attributes[$method] = count($parameters) > 0 ? $parameters[0] : true;
  //     return $this;
  // }

  ///
  /// Dynamically set the value of an attribute.
  ///
  /// @param  string  $key
  /// @param  mixed   $value
  /// @return void
  ///
  void set(String key, dynamic value) {
    attributes[key] = value;
  }

  ///
  /// Dynamically check if an attribute is set.
  ///
  /// @param  string  $key
  /// @return bool
  ///
  bool isset(String key) {
    return attributes.containsKey(key);
  }

  ///
  /// Dynamically unset an attribute.
  ///
  /// @param  string  $key
  /// @return void
  ///
  void unset(String key) {
    attributes.remove(key);
  }
}

// File: C:\MyDartProjects\eloquent\lib\src\support\traits\capsule_manager_trait.dart
import 'package:eloquent/eloquent.dart';
import 'package:eloquent/src/container/container.dart';

mixin CapsuleManagerTrait {
  ///
  /// The current globally used instance.
  ///
  /// @var object
  ///
  static dynamic instance;

  ///
  /// The container instance.
  ///
  /// @var \Illuminate\Contracts\Container\Container
  ///
  late Container container;

  ///
  /// Setup the IoC container instance.
  ///
  /// @param  \Illuminate\Contracts\Container\Container  $container
  /// @return void
  ///
  void setupContainer(Container containerP) {
    this.container = containerP;

    if (!this.container.bound('config')) {
      this.container.instance('config', new Fluent());
    }
  }

  ///
  /// Make this capsule instance available globally.
  ///
  /// @return void
  ///
  void setAsGlobal() {
    CapsuleManagerTrait.instance = this;
  }

  ///
  /// Get the IoC container instance.
  ///
  /// @return \Illuminate\Contracts\Container\Container
  ///
  Container? getContainer() {
    return this.container;
  }

  ///
  /// Set the IoC container instance.
  ///
  /// @param  \Illuminate\Contracts\Container\Container  $container
  /// @return void
  ///
  void setContainer(Container containerP) {
    this.container = containerP;
  }
}

// File: C:\MyDartProjects\eloquent\lib\src\utils\arr_utils.dart
/// Array Map Utils
class ArrUtils {
  /// Flatten a multi-dimensional map into a single level.  
  static List<dynamic> flattenMap(Map<dynamic, dynamic> map, [int depth = -1]) {
    List<dynamic> result = [];

    void recursiveFlatten(dynamic item, int currentDepth) {
      if (item is Map) {
        if (currentDepth == 1) {
          result.addAll(item.values);
        } else if (currentDepth < 0 || currentDepth > 1) {
          item.forEach((key, value) {
            recursiveFlatten(value, currentDepth - 1);
          });
        }
      } else {
        result.add(item);
      }
    }

    map.forEach((key, value) {
      recursiveFlatten(value, depth);
    });

    return result;
  }

  /// Flatten a multi-dimensional List into a single level. 
  /// Example usage:
  /// ```dart
  /// List<dynamic> multiDimensionalArray = [
  ///   [1, 2, [3, 4, [5, 6]]],
  ///   [7, 8],
  ///   9,
  ///   [10]
  /// ];
  ///
  /// List<dynamic> flattenedArray = flatten(multiDimensionalArray);
  /// print('Original: $multiDimensionalArray');
  /// print('Flattened: $flattenedArray');
  /// ```
  static List<dynamic> flattenList(dynamic array, [int depth = 0]) {
    List<dynamic> result = [];

    if (array is List) {
      for (dynamic item in array) {
        if (item is List || item is Iterable) {
          if (depth == 1) {
            result.addAll(item);
          } else {
            result.addAll(flattenList(item, depth - 1));
          }
        } else {
          result.add(item);
        }
      }
    } else if (array is Iterable) {
      for (dynamic item in array) {
        if (item is Iterable) {
          if (depth == 1) {
            result.addAll(item);
          } else {
            result.addAll(flattenList(item, depth - 1));
          }
        } else {
          result.add(item);
        }
      }
    } else {
      result.add(array);
    }

    return result;
  }

  /// Get all of the given array except for a specified array of keys.
  /// Obtenha todo o map fornecido, exceto um map especificado pela chave.
  /// [keys] array|string
  static exceptMap(Map<String, dynamic> map, dynamic keys) {
    forgetMap(map, keys);
    return map;
  }

  static void forgetMap(Map<String, dynamic> map, dynamic keys) {
    Map<String, dynamic>? original = {...map};

    if (keys is String) {
      keys = [keys];
    }

    if (keys is! List<String> || keys.isEmpty) {
      return;
    }

    for (var key in keys) {
      // if the exact key exists in the top-level, remove it
      if (exists(map, key)) {
        map.remove(key);
        continue;
      }

      List<String> parts = key.split('.');

      // clean up before each pass
      map = original;

      while (parts.length > 1) {
        String part = parts.removeAt(0);

        if (map.containsKey(part) && map[part] is Map<String, dynamic>) {
          map = map[part];
        } else {
          continue;
        }
      }

      map.remove(parts.removeAt(0));
    }
  }

  /// Determine if the given key exists in the provided map using dot notation.
  static bool exists(Map<String, dynamic> map, String key) {
    final parts = key.split('.');

    for (String part in parts) {
      if (map.containsKey(part) && map[part] is Map<String, dynamic>) {
        map = map[part];
      } else {
        return false;
      }
    }

    return true;
  }

  /// Flatten a multi-dimensional associative array/map with dots.
  Map<String, dynamic> dot(Map<String, dynamic> array, [String prepend = '']) {
    Map<String, dynamic> results = {};

    array.forEach((key, value) {
      if (value is Map<String, dynamic> && value.isNotEmpty) {
        results.addAll(dot(value, '$prepend$key.'));
      } else {
        results['$prepend$key'] = value;
      }
    });

    return results;
  }
}

// File: C:\MyDartProjects\eloquent\lib\src\utils\dsn_parser.dart
import 'dart:convert';

enum DsnType { pdoMySql, pdoPostgreSql, jdbc, heroku }

/// JDBC URL EXAMPLE: jdbc:sqlserver://localhost;encrypt=true;user=MyUserName;password=*****;
/// O pdoPostgreSql Data Source Name (DSN) é composto dos seguintes elementos:
///
/// DSN prefix
/// O prefixo DSN é pgsql:
/// host => O hostname no qual o servidor do banco de dados está.
/// port -> O número da porta onde o servidor do banco de dados está escutando.
/// dbname -> O nome do banco de dados.
/// unix_socket -> O socket Unix do MySQL (não deve ser usado com host ou port).
/// charset
///
/// Example:
/// ```dart
///  var d = DSNParser('pgsql:host=localhost;port=5432;dbname=dvdrental;', DsnType.pdoPostgreSql);
///  print(d.getDnsParts());
///  //Result: {driver: pgsql, user: null, password: null, host: localhost, port: 5432, database: dvdrental, params: {}}
///
///  var d = DSNParser('pgsql://user:pass@127.0.0.1:5432/my_db?pram=0', DsnType.heroku);
///  print(d.getDnsParts());
///  //Result: {driver: pgsql, user: null, password: null, host: localhost, port: 5432, database: dvdrental, params: {}}
/// ```
///
class DSNParser {
  String dsn;
  DsnType dsnType = DsnType.pdoPostgreSql;

  Map<String, dynamic> dsnParts = {
    'driver': null,
    'user': null,
    'password': null,
    'host': null,
    'port': null,
    'database': null,
    'charset': null,
    'params': {}
  };

  String get password => dsnParts['password'];
  String get user => dsnParts['user'];
  String get host => dsnParts['host'];
  String get driver => dsnParts['driver'];
  int get port => dsnParts['port'] != null ? int.parse(dsnParts['port']) : 0;
  String get database => dsnParts['database'];
  String? get charset => dsnParts['charset'];

  bool get pool => dsnParts['pool'].toString() == 'true';
  int get poolSize => int.tryParse(dsnParts['poolsize'] ?? '') ?? 1;
  bool get allowReconnect => dsnParts['allowreconnect'].toString() == 'true';
  String? get applicationName => dsnParts['application_name'];
  String? get sslmode => dsnParts['sslmode'];
  String? get timezone => dsnParts['timezone'];
  String? get schema => dsnParts['schema'];

  Map<String, dynamic>? get options => dsnParts['options'];
  Map<String, dynamic> get params => dsnParts['params'];

  DSNParser(this.dsn, [this.dsnType = DsnType.pdoPostgreSql]) {
    parse();
  }

  DSNParser parse() {
    //dado isso: pgsql:host=localhost;port=5432;dbname=dvdrental;
    //dsn: pgsql:host=localhost;dbname=siamweb;port=5433;charset=latin1;pool=true;poolsize=1;allowreconnect=true
    if (dsnType == DsnType.pdoPostgreSql) {
      if (dsn.contains(':')) {
        dsnParts['driver'] = dsn.split(':').first.trim();
      } else {
        throw Exception('Syntax error: DSN not contains "driver:..." ');
      }
      var parts = <String>[];
      parts = dsn.split(':');
      parts.removeAt(0);
      parts = parts.join().split(';');

      if (parts.last.trim() == '') {
        parts.removeLast();
      }

      //dsnParts['host'] = parts.lastWhere((p) => p == 'host').split('=').last;
      //dsnParts['port'] = parts.lastWhere((p) => p == 'port').split('=').last;
      //dsnParts['database'] = parts.lastWhere((p) => p == 'dbname').split('=').last;

      if (parts.join().contains('dbname=')) {
        dsnParts['database'] =
            parts.lastWhere((p) => p.contains('dbname=')).split('=').last;
      }

      if (parts.join().contains('port=')) {
        dsnParts['port'] =
            parts.lastWhere((p) => p.contains('port=')).split('=').last;
      }

      //print('dsn_parser $parts');
      if (parts.join().contains('host=')) {
        dsnParts['host'] =
            parts.lastWhere((p) => p.contains('host=')).split('=').last;
      }

      if (parts.join().contains('charset=')) {
        dsnParts['charset'] =
            parts.lastWhere((p) => p.contains('charset=')).split('=').last;
      }
      if (parts.join().contains('pool=')) {
        dsnParts['pool'] =
            parts.lastWhere((p) => p.contains('pool=')).split('=').last;
      }
      if (parts.join().contains('poolsize=')) {
        dsnParts['poolsize'] =
            parts.lastWhere((p) => p.contains('poolsize=')).split('=').last;
      }
      if (parts.join().contains('allowreconnect=')) {
        dsnParts['allowreconnect'] = parts
            .lastWhere((p) => p.contains('allowreconnect='))
            .split('=')
            .last;
      }
      if (parts.join().contains('application_name=')) {
        dsnParts['application_name'] = parts
            .lastWhere((p) => p.contains('application_name='))
            .split('=')
            .last;
      }
      if (parts.join().contains('sslmode=')) {
        dsnParts['sslmode'] =
            parts.lastWhere((p) => p.contains('sslmode=')).split('=').last;
      }
      if (parts.join().contains('options=')) {
        dsnParts['options'] =
            parts.lastWhere((p) => p.contains('options=')).split('=').last;
      }

      if (parts.join().contains('timezone=')) {
        dsnParts['timezone'] =
            parts.lastWhere((p) => p.contains('timezone=')).split('=').last;
      }

      if (parts.join().contains('schema=')) {
        dsnParts['schema'] =
            parts.lastWhere((p) => p.contains('schema=')).split('=').last;
      }
    } else if (dsnType == DsnType.heroku) {
      var patternString = '^' +
          '(?:' +
          '([^:/?#.]+)' + // driver
          ':)?' +
          r'(?://' +
          '(?:([^/?#]*)@)?' + // auth
          '([\\w\\d\\-\\u0100-\\uffff.%]*)' + // host
          '(?::([0-9]+))?' + // port
          ')?' +
          '([^?#]+)?' + // database
          r'(?:\?([^#]*))?' + // params
          r'$';

      var regexp = RegExp(patternString, multiLine: true, caseSensitive: true);

      var matche = regexp.firstMatch(dsn);

      if (matche != null) {
        var split = <String?>[];
        for (var i = 0; i < matche.groupCount + 1; i++) {
          split.add(matche[i]);
        }

        var auth = split[2] != null ? split[2]?.split(':') : [];

        this.dsnParts = {
          'driver': split[1],
          'user': auth?[0],
          'password': auth?[1],
          'host': split[3],
          'port': split[4] != null ? int.parse(split[4]!, radix: 10) : null,
          'database': stripLeadingSlash(split[5]),
          'params': split.length < 7 ? {} : fromQueryParams(split[6])
        };
      }
    }
    return this;
  }

  String getDSN() {
    var dsn = (dsnParts['driver'] ?? '') +
        '://' +
        (dsnParts['user']
            ? ((dsnParts['user'] ?? '') +
                (dsnParts['password'] ? ':' + dsnParts['password'] : '') +
                '@')
            : '') +
        (dsnParts['host'] ?? '') +
        (dsnParts['port'] ? ':' + dsnParts['port'] : '') +
        '/' +
        (dsnParts['database'] ?? '');

    if (dsnParts['params'] && (dsnParts['params'] as Map).keys.length > 0) {
      dsn += '?' + toQueryParams(dsnParts['params']);
    }
    return dsn;
  }

  Map<String, dynamic> getDnsParts() {
    return dsnParts;
  }

  Map<String, dynamic> fromQueryParams(String? params) {
    if (params == null) {
      return {};
    }

    return jsonDecode('{"' +
        Uri.decodeComponent(params)
            .replaceAll('"', '\\"')
            .replaceAll('&', '","')
            .replaceAll('=', '":"') +
        '"}');
  }

  String toQueryParams(Map<String, dynamic> obj) {
    var str = [];
    for (var entry in obj.entries) {
      str.add(Uri.encodeComponent(entry.key) +
          '=' +
          Uri.encodeComponent(entry.value));
    }
    return str.join('&');
  }

  String stripLeadingSlash(String? strP) {
    var str = strP ?? '';
    if (str.substring(0, 1) == '/') {
      return str.substring(1, str.length);
    }
    return str;
  }
}

// File: C:\MyDartProjects\eloquent\lib\src\utils\utils.dart
//import 'dart:mirrors';
import 'package:intl/intl.dart';

import 'dart:math';

enum StringCase { CASE_UPPER, CASE_LOWER }

class Utils {
  static const int intMinValueNative = -9223372036854775808;
  static const int intMaxValueNative = 9223372036854775807;

  static const int intMinValueJS = -9007199254740992;
  static const int intMaxValueJS = 9007199254740992;

  ///  Aplica o retorno de chamada aos elementos dos arrays fornecidos
  static List array_map(Function callback, List values) {
    var result = [];

    values.forEach((element) {
      result.add(callback(element));
    });

    return result;
  }

  /// Filtra elementos de um array utilizando uma função callback
  static List array_filter(List array, Function callback) {
    var result = [];

    array.forEach((element) {
      if (callback(element)) {
        result.add(element);
      }
    });

    return result;
  }

  /// in_array — Verifica se existe um valor em um array
  static bool in_array(dynamic needle, List array) {
    return array.contains(needle);
  }

  /// implode — Junta elementos de uma matriz em uma string
  static String implode(String glue, List pieces) {
    return pieces.join(glue);
  }

  ///  Substitui todas as ocorrências da string de pesquisa pela string de substituição
  static String str_replace(dynamic search, String replace, String subject) {
    var result = subject;
    if (search is List) {
      for (var s in search) {
        result = result.replaceAll(s, replace);
      }
    } else {
      result = result.replaceAll(search, replace);
    }

    return result;
  }

  ///
  /// Return the default value of the given value.
  ///
  /// @param  mixed  $value
  /// @return mixed
  ///
  static dynamic value(dynamic value) {
    return value is Function ? value() : value;
  }

  /// Converte uma string para minúsculas
  static String strtolower(String str) {
    return str.toLowerCase();
  }

  /// Encontra a posição da primeira ocorrência de uma substring em uma string
  /// return int|false
  static dynamic strpos(String str, Pattern needle) {
    var index = str.indexOf(needle);
    if (index == -1) {
      return false;
    }
    return index;
  }

  /// Dividir uma string por uma string
  ///
  /// PHP_INT_MAX = 9223372036854775807 [int limit = 9223372036854775807]
  static List explode(Pattern separator, String string, [int? limit]) {
    var items = string.split(separator);
    if (limit == null) {
      return items;
    } else {
      limit = limit > items.length ? items.length : limit;
      var result = [];
      for (var i = 0; i < limit; i++) {
        result.add(items[i]);
      }
      return result;
    }
  }

  /// Conta todos os elementos em uma matriz ou em um objeto Countable
  static int count(Iterable items) {
    return items.length;
  }

  /// Torna o primeiro caractere de uma string maiúsculo
  static String ucfirst(String string) {
    if (string.length == 0) {
      return string;
    } else if (string.length == 1) {
      return string[0].toUpperCase();
    }

    return string[0].toUpperCase() + string.substring(1);
  }

  ///
  /// Explode the "value" and "key" arguments passed to "pluck".
  ///
  /// @param  string|array  $value
  /// @param  string|array|null  $key
  /// @return array return [value, key];
  ///
  static List explodePluckParameters(dynamic valueP, dynamic keyP) {
    var value = is_string(valueP) ? explode('.', valueP) : valueP;

    var key = is_null(keyP) || is_array(keyP) ? keyP : explode('.', keyP);

    return [value, key];
  }

  ///
  /// Pluck an array of values from an array.
  ///
  /// @param  array  $array
  /// @param  string|array  $value
  /// @param  string|array|null  $key
  /// @return array
  ///
  static array_pluck(arrayP, valueP, [keyP = null]) {
    var results = [];

    var re = explodePluckParameters(valueP, keyP);
    var value = re[0];
    var key = re[1];

    for (var item in arrayP) {
      var itemValue = data_get(item, value);

      // If the key is "null", we will just append the value to the array and keep
      // looping. Otherwise we will key the array using the value of the key we
      // received from the developer. Then we'll return the final array form.
      if (is_null(key)) {
        results.add(itemValue);
      } else {
        var itemKey = data_get(item, key);

        results[itemKey] = itemValue;
      }
    }

    return results;
  }

  /// change all keys to case defined
  static Map<String, dynamic> map_change_key_case_sd(Map<String, dynamic> map,
      [StringCase typeCase = StringCase.CASE_LOWER]) {
    var clone = <String, dynamic>{}..addAll(map);
    var length = clone.entries.length;
    var entries = clone.entries.toList();
    for (var i = 0; i < length; i++) {
      var entry = entries[i];
      if (entry.value is Map) {
        map_change_key_case_sd(map[entry.key], typeCase);
      } else {
        var key = entry.key;
        var val = map[key];
        map.remove(key);
        map[key] = val;
      }
    }
    return map;
  }

  ///
  /// Get an item from an array using "dot" notation.
  ///
  /// @param  \ArrayAccess|array  $array
  /// @param  string  $key
  /// @param  mixed   $default
  /// @return mixed
  /// equivalente a Arr::get($connections, $name)
  ///
  static dynamic array_get(array, String key, [dynamic defaultP]) {
    if (!array_accessible(array)) {
      return value(defaultP);
    }

    if (is_null(key)) {
      return array;
    }

    if (array_exists(array, key)) {
      return array[key];
    }

    for (var segment in explode('.', key)) {
      if (array_accessible(array) && array_exists(array, segment)) {
        array = array[segment];
      } else {
        return value(defaultP);
      }
    }

    return array;
  }

  ///
  /// Get an item from an array or object using "dot" notation.
  ///
  /// @param  mixed   $target
  /// @param  string|array  $key
  /// @param  mixed   $default
  /// @return mixed
  ///
  static dynamic data_get(dynamic target, dynamic key, [dynamic defaultP]) {
    if (is_null(key)) {
      return target;
    }

    key = is_array(key) ? key : explode('.', key);
    var segment;
    while ((segment = array_shift(key)) != null) {
      if (segment == '*') {
        // if ($target instanceof Collection) {
        //     $target = $target->all();
        //}

        if (!is_array(target)) {
          return value(defaultP);
        }

        var result = array_pluck(target, key);

        return in_array('*', key) ? array_collapse(result) : result;
      }

      if (array_accessible(target) && array_exists(target, segment)) {
        target = target[segment];
      }
      // else if (is_object($target) && isset($target->{$segment})) {
      //     target = target->{$segment};
      // }
      else {
        return value(defaultP);
      }
    }

    return target;
  }

  ///
  /// Determine whether the given value is array accessible.
  ///
  /// @param  mixed  $value
  /// @return bool
  ///
  static bool array_accessible(dynamic value) {
    return is_array(value) ||
        is_map(value); // || $value instanceof ArrayAccess;
  }

  static bool is_object(dynamic value) {
    return value is Object;
  }

  /**
     * Collapse an array of arrays into a single array.
     *
     * @param  array  $array
     * @return array
     */
  static dynamic array_collapse(dynamic array) {
    var results = array is List ? [] : <String, dynamic>{};

    for (var values in array) {
      // if ($values instanceof Collection) {
      //     $values = $values->all();
      // } elseif (! is_array($values)) {
      //     continue;
      // }
      if (!is_array(values)) {
        continue;
      }
      if (results is List) {
        results = array_merge(results, values);
      } else if (results is Map<String, dynamic>) {
        results = map_merge_sd(results, values);
      }
    }

    return results;
  }

  /// desloca o primeiro valor do arrayoff e o retorna, encurtando o array
  /// por um elemento e movendo tudo para baixo. Todas as chaves de matriz
  /// numérica serão modificadas para começar a contar do zero,
  /// enquanto as chaves literais não serão afetadas.
  static dynamic array_shift(dynamic array) {
    if (array is List && array.length > 0) {
      var fistItem = array.first;
      array.removeAt(0);
      return fistItem;
    } else if (array is Map && array.isNotEmpty) {
      var fistItem = array.entries.first;
      array.remove(fistItem.key);
      return fistItem;
    }

    return null;
  }

  /**
     * Determine if the given key exists in the provided array or Map
     *
     * [array] @param  \ArrayAccess|array   Map | List
     * @param  string|int  $key
     * @return bool
     */
  static bool array_exists(dynamic array, dynamic key) {
    // if ($array instanceof ArrayAccess) {
    //     return $array->offsetExists($key);
    // }
    if (array is Map) {
      return map_key_exists(key, array);
    } else if (array is List) {
      return key >= 0 && array.length > key;
    }
    throw Exception('array is not List or Map');
  }

  ///
  /// Determine if a given string contains a given substring.
  ///
  /// @param  string  $haystack
  /// @param  string|array  $needles
  /// @return bool
  ///
  static bool string_contains(String haystack, List<String> needles) {
    for (var needle in needles) {
      if (needle != '' && haystack.indexOf(needle) != -1) {
        return true;
      }
    }

    return false;
  }

  /// array1 => ['A', 'B']  and array2 => ['C', 'D'] return ['A', 'B', 'C', 'D']
  static List array_merge(List? array1, List? array2) {
    var a1 = array1;
    var a2 = array2;
    if (a1 == null) {
      a1 = [];
    }
    if (a2 == null) {
      a2 = [];
    }
    return [...a1, ...a2];
  }

  /// mescla duas List de String Null Safety
  static List<String> array_merge_ss(List<String> array1, List<String> array2) {
    return [...array1, ...array2];
  }

  /// mescla duas List Map String dynamic Null Safety
  static List<Map<String, dynamic>> array_merge_ms(
      List<Map<String, dynamic>> array1, List<Map<String, dynamic>> array2) {
    return [...array1, ...array2];
  }

  /// mescla duas List de String anulavel
  static List<String> array_merge_sa(
      List<String>? array1, List<String>? array2) {
    if (array1 == null) {
      throw Exception(
          'array_merge(): Expected parameter 1 to be an array, null given');
    }
    if (array2 == null) {
      throw Exception(
          'array_merge(): Expected parameter 2 to be an array, null given');
    }
    return [...array1, ...array2];
  }

  ///
  /// Flatten a multi-dimensional array into a single level.
  ///
  /// @param  array  $array
  /// @param  int  $depth
  /// @return array
  ///
  static List array_flatten(List array, [int depth = intMaxValueNative]) {
    var result = [];

    for (var item in array) {
      //var item = itemP is Collection ? item.all() : item;

      if (is_array(item)) {
        if (depth == 1) {
          result = array_merge(result, item);
          continue;
        }

        result = array_merge(result, array_flatten(item, depth - 1));
        continue;
      }

      result.add(item);
    }

    return result;
  }

  ///
  /// esquivale ao array_merge para Array Associativo do PHP
  /// Example:
  ///  var map1 = {'driver': 'pgsql', 'host': 'localhost'};
  ///  var map2 = {'driver': 'mysql', 'host': '127.0.0.1'};
  ///  print(map_merge_sd(map1, map2));
  ///  result {driver: mysql, host: 127.0.0.1}
  static Map<String, dynamic> map_merge_sd(
      Map<String, dynamic> firstMap, Map<String, dynamic> secondMap) {
    return {
      ...firstMap,
      ...secondMap,
    };
  }

  /// Add an element to an map of String, dynamic if it doesn't exist.
  static Map<String, dynamic> map_add_sd(
      Map<String, dynamic> map, String key, dynamic value) {
    if (map.containsKey(key)) {
      return map;
    }
    map[key] = value;

    return map;
  }

  ///
  /// Get all of the given Map except for a specified Map of items.
  ///
  /// [map]  Map<String, dynamic>
  /// [keys]  List<String>|String  keys
  /// Return Map<String, dynamic>
  ///
  /// Example:
  ///  var map = {
  ///    'driver': 'mysql',
  ///    'host': '127.0.0.1',
  ///    'level1': {
  ///       'read': true,
  ///       'write': false,
  ///       'level2': {'banana': 'good'}
  ///     }
  ///   };
  /// map_except_sd(map, ['read', 'write']);
  /// result: {driver: mysql, host: 127.0.0.1, level1: {level2: {banana: good}}}
  ///
  static Map<String, dynamic> map_except_sd(
      Map<String, dynamic> map, dynamic keys) {
    if (keys is List<String>) {
      for (var key in keys) {
        map_unset_deep_sd(map, key);
      }
    } else if (keys is String) {
      map_unset_deep_sd(map, keys);
    } else {
      throw Exception('keys is not List<String> or String');
    }
    return map;
  }

  /// remove um item varrendo o map recursivamente
  static void map_unset_deep_sd(Map<String, dynamic> map, String key) {
    var clone = <String, dynamic>{}..addAll(map);
    var length = clone.entries.length;
    var entries = clone.entries.toList();
    for (var i = 0; i < length; i++) {
      var entry = entries[i];
      if (entry.value is Map) {
        map_unset_deep_sd(map[entry.key], key);
      } else {
        if (entry.key == key) {
          map.remove(key);
        }
      }
    }
  }

  static int array_unshift(List array, dynamic value) {
    //var result = [...array, value];
    array.insert(0, value);
    return array.length;
  }

  /// array_rand — Escolhe uma ou mais chaves aleatórias de um array
  /// numero Especifica quantos elementos deseja obter.
  static dynamic array_rand(List array, [int numero = 1]) {
    var rng = Random();
    var len = array.length;

    var list = [];
    for (var i = 0; i < numero; i++) {
      list.add(rng.nextInt(len));
    }
    return list;
  }

  /// verifica se value é um List
  static bool is_array(dynamic value) {
    return value is List;
  }

  static bool is_map(dynamic value) {
    return value is Map;
  }

  /// verifica se value é um bool
  static bool is_bool(dynamic value) {
    return value is bool;
  }

  /// verifica se value é um String
  static bool is_string(dynamic value) {
    return value is String;
  }

  static bool array_is_empty(List val) {
    return val.isEmpty;
  }

  /// replica o comportamento da função empty do PHP
  /// retorn true se val é 0, '' ou null;
  static bool empty(dynamic val) {
    if (val == '') {
      return true;
    } else if (val == null) {
      return true;
    } else if (val == 0) {
      return true;
    }
    return false;
  }

  /// Informa se a variável é null
  static bool is_null(dynamic val) {
    return val == null;
  }

  /// verifica se o valor é nulo
  /// e se val for um List ou Map verifica se esta vazio
  static bool is_null_or_empty(dynamic val) {
    if (val is List) {
      return val.isEmpty;
    } else if (val is Map) {
      return val.isEmpty;
    }
    return val == null;
  }

  /// Verifica se a variável é definida.
  /// se val == null => FALSE
  /// se val is List empty => FALSE
  /// se val is Map empty => FALSE
  static bool isset(dynamic val) {
    if (val == null) {
      return false;
    } else if (val is List && val.isEmpty) {
      return false;
    } else if (val is Map && val.isEmpty) {
      return false;
    }
    return true;
  }

  static String trim(String str) {
    return str.trim();
  }

  static String strval(dynamic val) {
    return val.toString();
  }

  static bool map_key_exists(dynamic key, Map map) {
    return map.containsKey(key);
  }

  static dynamic map_first_key(Map map) {
    return map.entries.first.key;
  }

  /// if array is Empty return false
  static dynamic array_end(List array) {
    return array.isEmpty ? false : array.last;
  }

  static void var_dump(dynamic val) {
    print(val);
  }

  static int str_length(String str) {
    return str.length;
  }

  ///
  /// Determine if a given string ends with a given substring.
  ///
  /// @param  string  $haystack
  /// @param  string|array  $needles
  /// @return bool
  ///
  static bool endsWith(String haystack, dynamic needles) {
    if (needles is List) {
      for (var needle in needles) {
        if (needle == substr(haystack, -str_length(needle))) {
          return true;
        }
      }
    } else if (needles is String) {
      return haystack.endsWith(needles);
    }
    return false;
  }

  /// trim characters from the left-side of the input
  /// chars = " \n\r\t\v\x00"
  static ltrim(String string, [String? chars = " \n\r\t"]) {
    //chars =chars.replaceAll('from', replace)
    var pattern = chars != null ? RegExp('^[$chars]+') : RegExp(r'^\s+');
    return string.replaceAll(pattern, '');
  }

  /// array_pop — Pop the element off the end of array
  static void array_pop(dynamic array) {
    var last;
    if (array is Map) {
      last = array.entries.last;
      array.remove(last.key);
    } else if (array is List) {
      last = array.last;
      array.removeLast();
    }
  }

  /// equivale ao array_values do PHP para Array Associativo
  static List map_values(Map map) {
    return map.values.toList();
  }

  ///
  /// Example:
  ///  echo(substr("abcdef", -2,10));
  ///  ef
  static String substr(String str, int offset, [int? length]) {
    if (length != null && length > str.length) {
      length = str.length;
    }
    if (offset >= 0) {
      return str.substring(offset, length);
    } else {
      var reverStr = str.substring(str.length - offset.abs(), length);
      return reverStr;
    }
  }

  /// max — Find highest value
  static int_max(int value1, int value2) {
    return value1 > value2 ? value1 : value2;
  }

  static reset(List array) {
    return array.isEmpty ? false : array.first;
  }

  /// microtime() retorna o timestamp atual do Unix com microssegundos.
  /// Esta função está disponível apenas em sistemas
  /// operacionais que suportam a chamada de sistema gettimeofday().
  static int microtime() {
    return DateTime.now().microsecondsSinceEpoch;
  }

  static dynamic round(num numero) {
    return numero.round();
  }

  static String formatDate(DateTime dt, [String format = 'yyyy-MM-dd']) {
    final formatter = DateFormat(format);
    final formatted = formatter.format(dt);
    return formatted;
  }

  /// Verifica se o método da classe existe
  /// this use  dart:mirrors
  /// Example:
  /// class FooBar {
  ///  String showMessage(String msg) {
  ///    print("message $msg");
  ///    return msg;
  ///  }
  /// }
  /// var c = FooBar();
  /// var result = Utils.method_exists(c, 'showMessage');
  /// print(result);
  /// true
  // static bool method_exists(dynamic object_or_class, String methodName) {
  //   var mirror = reflect(object_or_class);
  //   return mirror.type.instanceMembers.values
  //       .map((MethodMirror method) => MirrorSystem.getName(method.simpleName))
  //       .contains(methodName);
  // }

  /// Verifica se uma propriedade da classe existe
  /// this use  dart:mirrors
  // static bool property_exists(dynamic object_or_class, String propName) {
  //   var mirror = reflect(object_or_class);
  //   return mirror.type.declarations.values
  //       .map((value) => MirrorSystem.getName(value.simpleName))
  //       .contains(propName);
  // }

  /// callMethod of class
  /// somente testado em metodos sem Future
  // static dynamic call_method(
  //   dynamic object_or_class,
  //   String methodName, [
  //   List<dynamic>? positionalArguments,
  //   Map<Symbol, dynamic> namedArguments = const <Symbol, dynamic>{},
  // ]) {
  //   var mirror = reflect(object_or_class);
  //   var methods = mirror.type.instanceMembers.entries;
  //   //print(methods);
  //   for (var m in methods) {
  //     //print(MirrorSystem.getName(m.value.simpleName));
  //     if (MirrorSystem.getName(m.value.simpleName) == methodName) {
  //       var result = mirror.invoke(
  //           m.value.simpleName,
  //           positionalArguments == null ? [] : positionalArguments,
  //           namedArguments);

  //       //var resultValue = await (result.reflectee as Future<MyData>);
  //       var resultValue = (result.reflectee as dynamic);

  //       return resultValue;
  //     }
  //   }
  // }

  static List array_fill(int start_index, int count, dynamic value) {
    return List.generate(count, (v) => value);
  }

  
}

